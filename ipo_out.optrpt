Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.

Intel(R) C Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 19.0.5.281 Build 20190815

Compiler options: -I/home/mcabrera/lib/openmpi-4.0.2/include -o milosMPI -ipo -O3 -xHost -fno-omit-frame-pointer -qopt-report=5 -lm -lcfitsio -lnsl -lgsl -lgslcblas -lfftw3 -ldl -lpthread -pthread -Wl,-rpath -Wl,/home/mcabrera/lib/openmpi-4.0.2/lib -Wl,--enable-new-dtags -L/home/mcabrera/lib/openmpi-4.0.2/lib -lmpi

    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: true
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: true

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: disabled
  -inline-max-per-compile: disabled

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

Begin optimization report for: main(int, char **)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (main(int, char **)) [1/70=1.4%] src/milosMPI.c(96,1)
  -> EXTERN: (103,2) MPI_Init(int *, char ***)
  -> EXTERN: (104,2) MPI_Comm_size(MPI_Comm, int *)
  -> EXTERN: (105,4) MPI_Comm_rank(MPI_Comm, int *)
  -> EXTERN: (110,32) ?1memcpy
  -> EXTERN: (111,35) ?1memcpy
  -> EXTERN: (124,2) MPI_Type_create_struct(int, const int *, const MPI_Aint *, const MPI_Datatype *, MPI_Datatype *)
  -> EXTERN: (125,2) MPI_Type_commit(MPI_Datatype *)
  -> EXTERN: (134,2) MPI_Type_create_struct(int, const int *, const MPI_Aint *, const MPI_Datatype *, MPI_Datatype *)
  -> EXTERN: (135,2) MPI_Type_commit(MPI_Datatype *)
  -> EXTERN: (190,6) _vla_alloc(long)
  -> EXTERN: (191,6) _vla_alloc(long)
  -> EXTERN: (192,6) _vla_alloc(long)
  -> EXTERN: (193,6) _vla_alloc(long)
  -> EXTERN: (194,6) _vla_alloc(long)
  -> EXTERN: (195,6) _vla_alloc(long)
  -> EXTERN: (197,6) _vla_alloc(long)
  -> (201,2) loadInitialValues(ConfigControl *) (isz = 57) (sz = 62)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (203,6) readInitFile(char *, ConfigControl *, int) (isz = 777) (sz = 817)
     [[ Inlining would exceed -inline-max-size value (817>230) <2>]]
  -> EXTERN: (205,4) printf(const char *__restrict__, ...)
  -> EXTERN: (206,3) exit(int)
  -> EXTERN: (210,5) strcmp(const char *, const char *)
  -> EXTERN: (212,4) printf(const char *__restrict__, ...)
  -> EXTERN: (213,3) exit(int)
  -> EXTERN: (218,6) strcmp(const char *, const char *)
  -> INLINE: (218,13) file_ext(const char *) (isz = 56) (sz = 65)
    -> EXTERN: src/readConfig.c:(2277,5) __assert_fail(const char *, const char *, unsigned int, const char *)
    -> EXTERN: src/readConfig.c:(2278,17) strrchr(const char *, int)
    -> EXTERN: src/readConfig.c:(2281,33) strlen(const char *)
    -> EXTERN: src/readConfig.c:(2284,14) __ctype_b_loc(void)
    -> EXTERN: src/readConfig.c:(2285,37) strlen(const char *)
  -> EXTERN: (220,5) printf(const char *__restrict__, ...)
  -> EXTERN: (221,5) printf(const char *__restrict__, ...)
  -> EXTERN: (222,5) printf(const char *__restrict__, ...)
  -> EXTERN: (224,4) exit(int)
  -> (232,6) readInitialModel(Init_Model *, char *) (isz = 177) (sz = 187)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (233,3) printf(const char *__restrict__, ...)
  -> EXTERN: (234,3) exit(int)
  -> INLINE: (241,15) readMallaGrid(const char *, double *, double *, double *, int) (isz = 73) (sz = 90)
    -> EXTERN: src/readConfig.c:(634,7) fopen(const char *__restrict__, const char *__restrict__)
    -> EXTERN: src/readConfig.c:(643,17) getline(char **__restrict__, size_t *__restrict__, FILE *__restrict__)
    -> EXTERN: src/readConfig.c:(643,17) getline(char **__restrict__, size_t *__restrict__, FILE *__restrict__)
    -> EXTERN: src/readConfig.c:(647,4) sscanf(const char *__restrict__, const char *__restrict__, ...)
    -> EXTERN: src/readConfig.c:(651,7) strncmp(const char *, const char *, size_t)
    -> EXTERN: src/readConfig.c:(658,3) printf(const char *__restrict__, ...)
  -> EXTERN: (243,20) calloc(size_t, size_t)
  -> EXTERN: (252,19) calloc(size_t, size_t)
  -> (253,42) readFileCuanticLines(const char *, double *, int, int) (isz = 249) (sz = 264)
     [[ Inlining would exceed -inline-max-size value (264>230) <2>]]
  -> EXTERN: (255,4) printf(const char *__restrict__, ...)
  -> EXTERN: (256,4) exit(int)
  -> INLINE: (264,19) readFitsLambdaToArray(const char *, int *, int *) (isz = 230) (sz = 247)
    -> EXTERN: src/utilsFits.c:(1144,17) ?1memcpy
    -> EXTERN: src/utilsFits.c:(1148,7) ffopentest(int, fitsfile **, const char *, int, int *)
    -> EXTERN: src/utilsFits.c:(1149,8) ffgipr(fitsfile *, int, int *, int *, long *, int *)
    -> EXTERN: src/utilsFits.c:(1156,16) calloc(size_t, size_t)
    -> EXTERN: src/utilsFits.c:(1160,8) ffgpxv(fitsfile *, int, long *, LONGLONG, void *, void *, int *, int *)
    -> EXTERN: src/utilsFits.c:(1167,6) printf(const char *__restrict__, ...)
    -> EXTERN: src/utilsFits.c:(1169,7) printf(const char *__restrict__, ...)
    -> EXTERN: src/utilsFits.c:(1171,6) printf(const char *__restrict__, ...)
    -> EXTERN: src/utilsFits.c:(1174,7) ffrprt(FILE *, int)
    -> EXTERN: src/utilsFits.c:(1175,7) free(void *)
    -> EXTERN: src/utilsFits.c:(1184,22) ?1memcpy
    -> EXTERN: src/utilsFits.c:(1185,6) ffgpxv(fitsfile *, int, long *, LONGLONG, void *, void *, int *, int *)
    -> EXTERN: src/utilsFits.c:(1187,7) ffrprt(FILE *, int)
    -> EXTERN: src/utilsFits.c:(1188,7) free(void *)
    -> EXTERN: src/utilsFits.c:(1194,5) printf(const char *__restrict__, ...)
    -> EXTERN: src/utilsFits.c:(1198,4) ffclos(fitsfile *, int *)
    -> EXTERN: src/utilsFits.c:(1200,5) ffrprt(FILE *, int)
    -> EXTERN: src/utilsFits.c:(1205,4) printf(const char *__restrict__, ...)
    -> EXTERN: src/utilsFits.c:(1206,16) ffrprt(FILE *, int)
    -> EXTERN: src/utilsFits.c:(1211,3) printf(const char *__restrict__, ...)
    -> EXTERN: src/utilsFits.c:(1212,15) ffrprt(FILE *, int)
  -> EXTERN: (266,4) printf(const char *__restrict__, ...)
  -> EXTERN: (267,4) free(void *)
  -> EXTERN: (268,4) exit(int)
  -> (270,42) readFileCuanticLines(const char *, double *, int, int) (isz = 249) (sz = 264)
     [[ Inlining would exceed -inline-max-size value (264>230) <2>]]
  -> EXTERN: (272,4) printf(const char *__restrict__, ...)
  -> EXTERN: (273,4) exit(int)
  -> EXTERN: (278,2) MPI_Barrier(MPI_Comm)
  -> EXTERN: (284,24) calloc(size_t, size_t)
  -> EXTERN: (290,2) MPI_Barrier(MPI_Comm)
  -> (291,12) create_cuantic(double *, int) (isz = 932) (sz = 941)
     [[ Inlining would exceed -inline-max-size value (941>230) <2>]]
  -> EXTERN: (295,2) MPI_Barrier(MPI_Comm)
  -> EXTERN: (296,5) access(const char *, int)
  -> (297,12) readFitsStrayLightFile(const char *, int *, int) (isz = 142) (sz = 159)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (304,33) fftw_malloc(size_t)
  -> EXTERN: (305,34) fftw_malloc(size_t)
  -> EXTERN: (306,18) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> EXTERN: (307,39) fftw_malloc(size_t)
  -> EXTERN: (308,40) fftw_malloc(size_t)
  -> EXTERN: (309,24) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> EXTERN: (312,36) fftw_malloc(size_t)
  -> EXTERN: (313,37) fftw_malloc(size_t)
  -> EXTERN: (314,19) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> EXTERN: (315,36) fftw_malloc(size_t)
  -> EXTERN: (316,37) fftw_malloc(size_t)
  -> EXTERN: (317,20) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> INLINE: (323,8) fgauss_WL(double, double, double, double, int, int *) (isz = 170) (sz = 187)
    -> EXTERN: src/fgauss.c:(137,22) calloc(size_t, size_t)
    -> EXTERN: src/fgauss.c:(147,9) calloc(size_t, size_t)
    -> EXTERN: src/fgauss.c:(160,9) calloc(size_t, size_t)
    -> EXTERN: src/fgauss.c:(165,14) exp(double)
    -> EXTERN: src/fgauss.c:(174,9) malloc(size_t)
    -> EXTERN: src/fgauss.c:(177,13) exp(double)
    -> EXTERN: src/fgauss.c:(195,2) free(void *)
    -> EXTERN: src/fgauss.c:(196,2) free(void *)
  -> EXTERN: (325,11) access(const char *, int)
  -> EXTERN: (331,8) fopen(const char *__restrict__, const char *__restrict__)
  -> EXTERN: (334,6) _vla_free(void *, long)
  -> EXTERN: (334,6) _vla_free(void *, long)
  -> EXTERN: (334,6) _vla_free(void *, long)
  -> EXTERN: (334,6) _vla_free(void *, long)
  -> EXTERN: (334,6) _vla_free(void *, long)
  -> EXTERN: (334,6) _vla_free(void *, long)
  -> EXTERN: (334,6) _vla_free(void *, long)
  -> EXTERN: (334,6) printf(const char *__restrict__, ...)
  -> EXTERN: (340,15) fgetc(FILE *)
  -> EXTERN: (340,15) fgetc(FILE *)
  -> EXTERN: (347,5) fclose(FILE *)
  -> EXTERN: (349,20) calloc(size_t, size_t)
  -> EXTERN: (350,12) calloc(size_t, size_t)
  -> INLINE: (351,6) readPSFFile(double *, double *, const char *, double) (isz = 57) (sz = 71)
    -> EXTERN: src/readConfig.c:(683,5) fopen(const char *__restrict__, const char *__restrict__)
    -> EXTERN: src/readConfig.c:(686,2) printf(const char *__restrict__, ...)
    -> EXTERN: src/readConfig.c:(690,17) getline(char **__restrict__, size_t *__restrict__, FILE *__restrict__)
    -> EXTERN: src/readConfig.c:(690,17) getline(char **__restrict__, size_t *__restrict__, FILE *__restrict__)
    -> EXTERN: src/readConfig.c:(692,3) sscanf(const char *__restrict__, const char *__restrict__, ...)
    -> EXTERN: src/readConfig.c:(699,2) fclose(FILE *)
  -> EXTERN: (353,11) trunc(double)
  -> EXTERN: (353,40) trunc(double)
  -> EXTERN: (353,68) trunc(double)
  -> EXTERN: (353,105) trunc(double)
  -> EXTERN: (355,8) printf(const char *__restrict__, ...)
  -> EXTERN: (357,7) exit(int)
  -> EXTERN: (359,10) calloc(size_t, size_t)
  -> EXTERN: (363,12) trunc(double)
  -> EXTERN: (363,50) trunc(double)
  -> INLINE: (371,6) interpolationLinearPSF(double *, double *, double *, size_t, double *, size_t, double) (isz = 123) (sz = 142)
    -> EXTERN: src/milosUtils.c:(764,30) gsl_interp_alloc(const gsl_interp_type *, size_t)
    -> EXTERN: src/milosUtils.c:(765,4) gsl_interp_init(gsl_interp *, const double *, const double *, size_t)
    -> EXTERN: src/milosUtils.c:(766,38) gsl_interp_accel_alloc(void)
    -> EXTERN: src/milosUtils.c:(773,11) gsl_interp_eval(const gsl_interp *, const double *, const double *, double, gsl_interp_accel *)
    -> EXTERN: src/milosUtils.c:(775,9) gsl_isnan(const double)
    -> EXTERN: src/milosUtils.c:(787,11) gsl_interp_eval(const gsl_interp *, const double *, const double *, double, gsl_interp_accel *)
    -> EXTERN: src/milosUtils.c:(789,9) gsl_isnan(const double)
    -> EXTERN: src/milosUtils.c:(801,4) gsl_interp_free(gsl_interp *)
    -> EXTERN: src/milosUtils.c:(802,4) gsl_interp_accel_free(gsl_interp_accel *)
  -> EXTERN: (377,7) printf(const char *__restrict__, ...)
  -> EXTERN: (378,6) exit(int)
  -> EXTERN: (384,37) fftw_malloc(size_t)
  -> EXTERN: (385,38) fftw_malloc(size_t)
  -> EXTERN: (386,20) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> EXTERN: (387,37) fftw_malloc(size_t)
  -> EXTERN: (388,38) fftw_malloc(size_t)
  -> EXTERN: (389,21) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> EXTERN: (391,39) fftw_malloc(size_t)
  -> EXTERN: (397,32) fftw_malloc(size_t)
  -> EXTERN: (398,17) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> EXTERN: (399,3) fftw_execute(const fftw_plan)
  -> EXTERN: (404,3) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (405,3) fftw_free(void *)
  -> EXTERN: (407,32) fftw_malloc(size_t)
  -> EXTERN: (408,37) fftw_malloc(size_t)
  -> EXTERN: (409,24) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> EXTERN: (410,34) fftw_malloc(size_t)
  -> EXTERN: (411,37) fftw_malloc(size_t)
  -> EXTERN: (412,25) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> EXTERN: (415,38) fftw_malloc(size_t)
  -> EXTERN: (416,43) fftw_malloc(size_t)
  -> EXTERN: (417,30) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> EXTERN: (418,39) fftw_malloc(size_t)
  -> EXTERN: (419,42) fftw_malloc(size_t)
  -> EXTERN: (420,31) fftw_plan_dft_1d(int, fftw_complex *, fftw_complex *, int, unsigned int)
  -> EXTERN: (425,2) MPI_Barrier(MPI_Comm)
  -> EXTERN: (432,42) malloc(size_t)
  -> EXTERN: (433,10) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (435,42) malloc(size_t)
  -> EXTERN: (436,10) strcpy(char *__restrict__, const char *__restrict__)
  -> INLINE: (436,43) get_basefilename(const char *) (isz = 42) (sz = 49)
    -> EXTERN: src/readConfig.c:(2300,16) malloc(size_t)
    -> EXTERN: src/readConfig.c:(2302,12) strlen(const char *)
  -> EXTERN: (438,4) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (440,47) malloc(size_t)
  -> EXTERN: (441,4) strcpy(char *__restrict__, const char *__restrict__)
  -> INLINE: (441,48) get_basefilename(const char *) (isz = 42) (sz = 49)
    -> EXTERN: src/readConfig.c:(2300,16) malloc(size_t)
    -> EXTERN: src/readConfig.c:(2302,12) strlen(const char *)
  -> EXTERN: (442,4) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (449,37) malloc(size_t)
  -> EXTERN: (450,37) malloc(size_t)
  -> EXTERN: (451,48) malloc(size_t)
  -> EXTERN: (458,6) sprintf(char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (460,6) sprintf(char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (462,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (463,5) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (464,5) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (466,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (467,5) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (468,5) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (470,6) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (471,6) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (473,5) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (475,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (476,5) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (477,5) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (479,6) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (480,6) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (482,5) strcat(char *__restrict__, const char *__restrict__)
  -> EXTERN: (489,2) MPI_Barrier(MPI_Comm)
  -> EXTERN: (491,2) MPI_Bcast(void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (492,2) MPI_Barrier(MPI_Comm)
  -> EXTERN: (524,2) MPI_Comm_group(MPI_Comm, MPI_Group *)
  -> EXTERN: (526,12) _vla_alloc(long)
  -> EXTERN: (533,4) MPI_Group_incl(MPI_Group, int, const int *, MPI_Group *)
  -> EXTERN: (544,5) MPI_Group_incl(MPI_Group, int, const int *, MPI_Group *)
  -> EXTERN: (550,5) MPI_Group_incl(MPI_Group, int, const int *, MPI_Group *)
  -> EXTERN: (555,11) _vla_alloc(long)
  -> EXTERN: (557,3) MPI_Comm_create(MPI_Comm, MPI_Group, MPI_Comm *)
  -> EXTERN: (560,2) MPI_Barrier(MPI_Comm)
  -> EXTERN: (568,2) MPI_Group_rank(MPI_Group, int *)
  -> EXTERN: (569,2) MPI_Group_size(MPI_Group, int *)
  -> EXTERN: (570,2) MPI_Barrier(MPI_Comm)
  -> EXTERN: (577,48) malloc(size_t)
  -> EXTERN: (578,48) malloc(size_t)
  -> EXTERN: (579,59) malloc(size_t)
  -> EXTERN: (582,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (583,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (584,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (588,45) malloc(size_t)
  -> EXTERN: (589,45) malloc(size_t)
  -> EXTERN: (590,56) malloc(size_t)
  -> EXTERN: (593,6) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (594,6) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (595,6) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (599,39) malloc(size_t)
  -> EXTERN: (600,39) malloc(size_t)
  -> EXTERN: (601,56) malloc(size_t)
  -> EXTERN: (604,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (605,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (606,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (608,4) free(void *)
  -> EXTERN: (609,4) free(void *)
  -> EXTERN: (610,4) free(void *)
  -> EXTERN: (630,49) malloc(size_t)
  -> EXTERN: (631,49) malloc(size_t)
  -> EXTERN: (632,60) malloc(size_t)
  -> EXTERN: (634,6) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (635,6) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (636,6) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (640,44) malloc(size_t)
  -> EXTERN: (641,44) malloc(size_t)
  -> EXTERN: (642,55) malloc(size_t)
  -> EXTERN: (645,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (646,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (647,5) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (649,4) free(void *)
  -> EXTERN: (651,4) free(void *)
  -> EXTERN: (653,4) free(void *)
  -> EXTERN: (659,2) MPI_Barrier(MPI_Comm)
  -> EXTERN: (663,48) malloc(size_t)
  -> EXTERN: (664,48) malloc(size_t)
  -> EXTERN: (665,59) malloc(size_t)
  -> EXTERN: (667,3) MPI_Barrier(MPI_Comm)
  -> EXTERN: (668,3) MPI_Bcast(void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (669,3) MPI_Bcast(void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (670,3) MPI_Bcast(void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (671,3) MPI_Barrier(MPI_Comm)
  -> EXTERN: (676,44) malloc(size_t)
  -> EXTERN: (677,44) malloc(size_t)
  -> EXTERN: (678,55) malloc(size_t)
  -> EXTERN: (680,3) MPI_Barrier(MPI_Comm)
  -> EXTERN: (681,3) MPI_Bcast(void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (682,3) MPI_Bcast(void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (683,3) MPI_Bcast(void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (684,3) MPI_Barrier(MPI_Comm)
  -> EXTERN: (691,29) malloc(size_t)
  -> EXTERN: (692,37) malloc(size_t)
  -> EXTERN: (693,39) malloc(size_t)
  -> EXTERN: (694,36) malloc(size_t)
  -> EXTERN: (695,34) malloc(size_t)
  -> EXTERN: (696,39) malloc(size_t)
  -> EXTERN: (697,45) malloc(size_t)
  -> EXTERN: (698,26) malloc(size_t)
  -> EXTERN: (699,52) malloc(size_t)
  -> EXTERN: (700,57) malloc(size_t)
  -> EXTERN: (701,39) malloc(size_t)
  -> EXTERN: (702,34) malloc(size_t)
  -> EXTERN: (703,30) malloc(size_t)
  -> EXTERN: (704,35) malloc(size_t)
  -> EXTERN: (705,40) malloc(size_t)
  -> EXTERN: (706,48) malloc(size_t)
  -> EXTERN: (707,47) malloc(size_t)
  -> EXTERN: (708,6) _vla_alloc(long)
  -> EXTERN: (709,6) _vla_alloc(long)
  -> EXTERN: (710,6) _vla_alloc(long)
  -> EXTERN: (712,6) _vla_alloc(long)
  -> EXTERN: (713,6) _vla_alloc(long)
  -> EXTERN: (716,32) calloc(size_t, size_t)
  -> EXTERN: (720,15) clock(void)
  -> EXTERN: (724,9) access(const char *, int)
  -> EXTERN: (725,18) clock(void)
  -> CP_CLONE (726,35) readFitsSpectroImage..0(const char *, int) (isz = 732) (sz = 750)
     [[ Inlining would exceed -inline-max-size value (750>230) <3>]]
  -> EXTERN: (727,10) clock(void)
  -> EXTERN: (729,6) printf(const char *__restrict__, ...)
  -> EXTERN: (734,4) MPI_Barrier(MPI_Comm)
  -> EXTERN: (736,4) MPI_Bcast(void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (737,4) MPI_Barrier(MPI_Comm)
  -> EXTERN: (743,6) printf(const char *__restrict__, ...)
  -> EXTERN: (744,48) calloc(size_t, size_t)
  -> EXTERN: (745,39) calloc(size_t, size_t)
  -> EXTERN: (746,40) calloc(size_t, size_t)
  -> EXTERN: (748,48) calloc(size_t, size_t)
  -> EXTERN: (778,5) MPI_Barrier(MPI_Comm)
  -> EXTERN: (779,19) MPI_Wtime(void)
  -> EXTERN: (782,39) calloc(size_t, size_t)
  -> EXTERN: (784,48) calloc(size_t, size_t)
  -> EXTERN: (786,27) MPI_Wtime(void)
  -> EXTERN: (789,5) MPI_Barrier(MPI_Comm)
  -> EXTERN: (792,6) MPI_Iscatterv(const void *, const int *, const int *, MPI_Datatype, void *, int, MPI_Datatype, int, MPI_Comm, MPI_Request *)
  -> EXTERN: (796,6) MPI_Iscatterv(const void *, const int *, const int *, MPI_Datatype, void *, int, MPI_Datatype, int, MPI_Comm, MPI_Request *)
  -> EXTERN: (798,28) MPI_Wtime(void)
  -> EXTERN: (800,42) calloc(size_t, size_t)
  -> EXTERN: (801,34) calloc(size_t, size_t)
  -> EXTERN: (802,34) calloc(size_t, size_t)
  -> EXTERN: (805,5) printf(const char *__restrict__, ...)
  -> EXTERN: (808,3) MPI_Waitall(int, MPI_Request *, MPI_Status *)
  -> EXTERN: (810,8) clock(void)
  -> EXTERN: (812,4) printf(const char *__restrict__, ...)
  -> (816,2) AllocateMemoryDerivedSynthesis(int) (isz = 574) (sz = 579)
     [[ Inlining would exceed -inline-max-size value (579>230) <2>]]
  -> EXTERN: (825,29) MPI_Wtime(void)
  -> (843,6) estimacionesClasicas(double, double *, int, float *, Init_Model *, int) (isz = 329) (sz = 344)
     [[ Inlining would exceed -inline-max-size value (344>230) <3>]]
  -> EXTERN: (844,10) __isnan(double)
  -> EXTERN: (846,10) __isnan(double)
  -> EXTERN: (848,10) __isnan(double)
  -> EXTERN: (850,10) __isnan(double)
  -> (865,6) lm_mils(Cuantic *, double *, double *, int, float *, int, Init_Model *, float *, float *, double *, double, int, float *, int *, float *, float, int *, int *) (isz = 900) (sz = 942)
     [[ Inlining would exceed -inline-max-size value (942>230) <3>]]
  -> EXTERN: (879,5) MPI_Igatherv(const void *, int, MPI_Datatype, void *, const int *, const int *, MPI_Datatype, int, MPI_Comm, MPI_Request *)
  -> EXTERN: (880,5) MPI_Igatherv(const void *, int, MPI_Datatype, void *, const int *, const int *, MPI_Datatype, int, MPI_Comm, MPI_Request *)
  -> EXTERN: (881,5) MPI_Igatherv(const void *, int, MPI_Datatype, void *, const int *, const int *, MPI_Datatype, int, MPI_Comm, MPI_Request *)
  -> EXTERN: (884,6) MPI_Igatherv(const void *, int, MPI_Datatype, void *, const int *, const int *, MPI_Datatype, int, MPI_Comm, MPI_Request *)
  -> EXTERN: (885,31) MPI_Wtime(void)
  -> EXTERN: (886,5) MPI_Ireduce(const void *, void *, int, MPI_Datatype, MPI_Op, int, MPI_Comm, MPI_Request *)
  -> EXTERN: (895,5) MPI_Wait(MPI_Request *, MPI_Status *)
  -> EXTERN: (896,5) MPI_Wait(MPI_Request *, MPI_Status *)
  -> EXTERN: (897,5) MPI_Wait(MPI_Request *, MPI_Status *)
  -> EXTERN: (898,5) MPI_Wait(MPI_Request *, MPI_Status *)
  -> EXTERN: (900,6) MPI_Wait(MPI_Request *, MPI_Status *)
  -> EXTERN: (904,10) clock(void)
  -> (906,10) writeFitsImageModels(const char *, int, int, Init_Model *, float *, int *, int) (isz = 355) (sz = 377)
     [[ Inlining would exceed -inline-max-size value (377>230) <3>]]
  -> EXTERN: (907,8) printf(const char *__restrict__, ...)
  -> EXTERN: (909,10) clock(void)
  -> EXTERN: (914,44) calloc(size_t, size_t)
  -> EXTERN: (916,56) calloc(size_t, size_t)
  -> (928,11) writeFitsImageProfiles(const char *, const char *, FitsImage *) (isz = 303) (sz = 319)
     [[ Inlining would exceed -inline-max-size value (319>230) <3>]]
  -> EXTERN: (929,8) printf(const char *__restrict__, ...)
  -> EXTERN: (933,8) free(void *)
  -> EXTERN: (937,7) free(void *)
  -> EXTERN: (941,6) free(void *)
  -> EXTERN: (942,6) free(void *)
  -> EXTERN: (943,6) free(void *)
  -> EXTERN: (945,7) free(void *)
  -> EXTERN: (948,6) printf(const char *__restrict__, ...)
  -> EXTERN: (949,6) printf(const char *__restrict__, ...)
  -> EXTERN: (951,6) printf(const char *__restrict__, ...)
  -> EXTERN: (952,6) printf(const char *__restrict__, ...)
  -> INLINE: (953,6) freeFitsImage(FitsImage *) (isz = 56) (sz = 61)
    -> EXTERN: src/utilsFits.c:(1308,6) free(void *)
    -> EXTERN: src/utilsFits.c:(1310,6) free(void *)
    -> EXTERN: src/utilsFits.c:(1313,4) free(void *)
    -> EXTERN: src/utilsFits.c:(1316,4) free(void *)
    -> EXTERN: src/utilsFits.c:(1318,4) free(void *)
    -> EXTERN: src/utilsFits.c:(1319,3) free(void *)
  -> EXTERN: (968,3) free(void *)
  -> EXTERN: (969,3) free(void *)
  -> EXTERN: (970,3) free(void *)
  -> EXTERN: (971,3) free(void *)
  -> EXTERN: (972,3) free(void *)
  -> EXTERN: (973,3) free(void *)
  -> EXTERN: (974,3) free(void *)
  -> EXTERN: (975,3) free(void *)
  -> EXTERN: (976,3) free(void *)
  -> EXTERN: (977,3) free(void *)
  -> EXTERN: (978,3) free(void *)
  -> EXTERN: (979,3) free(void *)
  -> EXTERN: (980,3) free(void *)
  -> EXTERN: (981,3) free(void *)
  -> EXTERN: (982,3) free(void *)
  -> EXTERN: (983,3) free(void *)
  -> EXTERN: (984,3) free(void *)
  -> EXTERN: (991,41) malloc(size_t)
  -> EXTERN: (992,41) malloc(size_t)
  -> EXTERN: (993,52) malloc(size_t)
  -> EXTERN: (996,4) MPI_Scatterv(const void *, const int *, const int *, MPI_Datatype, void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (997,4) MPI_Scatterv(const void *, const int *, const int *, MPI_Datatype, void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (998,4) MPI_Scatterv(const void *, const int *, const int *, MPI_Datatype, void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1001,4) MPI_Scatterv(const void *, const int *, const int *, MPI_Datatype, void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1002,4) MPI_Scatterv(const void *, const int *, const int *, MPI_Datatype, void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1003,4) MPI_Scatterv(const void *, const int *, const int *, MPI_Datatype, void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1005,3) MPI_Barrier(MPI_Comm)
  -> EXTERN: (1014,8) clock(void)
  -> EXTERN: (1015,16) clock(void)
  -> CP_CLONE (1016,16) readFitsSpectroImage..1(const char *, int) (isz = 732) (sz = 750)
     [[ Inlining would exceed -inline-max-size value (750>230) <3>]]
  -> EXTERN: (1017,8) clock(void)
  -> EXTERN: (1020,4) printf(const char *__restrict__, ...)
  -> EXTERN: (1021,4) printf(const char *__restrict__, ...)
  -> EXTERN: (1022,4) printf(const char *__restrict__, ...)
  -> EXTERN: (1029,26) malloc(size_t)
  -> EXTERN: (1039,34) calloc(size_t, size_t)
  -> EXTERN: (1041,46) calloc(size_t, size_t)
  -> EXTERN: (1051,15) calloc(size_t, size_t)
  -> EXTERN: (1052,16) calloc(size_t, size_t)
  -> EXTERN: (1053,16) calloc(size_t, size_t)
  -> EXTERN: (1056,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1057,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1058,5) printf(const char *__restrict__, ...)
  -> (1079,6) estimacionesClasicas(double, double *, int, float *, Init_Model *, int) (isz = 329) (sz = 344)
     [[ Inlining would exceed -inline-max-size value (344>230) <3>]]
  -> EXTERN: (1080,10) __isnan(double)
  -> EXTERN: (1082,10) __isnan(double)
  -> EXTERN: (1084,10) __isnan(double)
  -> EXTERN: (1086,10) __isnan(double)
  -> (1100,6) lm_mils(Cuantic *, double *, double *, int, float *, int, Init_Model *, float *, float *, double *, double, int, float *, int *, float *, float, int *, int *) (isz = 900) (sz = 942)
     [[ Inlining would exceed -inline-max-size value (942>230) <3>]]
  -> EXTERN: (1116,23) clock(void)
  -> (1117,9) writeFitsImageModels(const char *, int, int, Init_Model *, float *, int *, int) (isz = 355) (sz = 377)
     [[ Inlining would exceed -inline-max-size value (377>230) <3>]]
  -> EXTERN: (1118,6) printf(const char *__restrict__, ...)
  -> (1125,10) writeFitsImageProfiles(const char *, const char *, FitsImage *) (isz = 303) (sz = 319)
     [[ Inlining would exceed -inline-max-size value (319>230) <3>]]
  -> EXTERN: (1126,7) printf(const char *__restrict__, ...)
  -> EXTERN: (1129,17) clock(void)
  -> EXTERN: (1130,15) clock(void)
  -> EXTERN: (1133,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1134,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1135,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1139,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1140,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1141,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1144,7) free(void *)
  -> EXTERN: (1146,6) free(void *)
  -> EXTERN: (1147,6) free(void *)
  -> EXTERN: (1149,5) free(void *)
  -> EXTERN: (1150,5) free(void *)
  -> EXTERN: (1151,5) free(void *)
  -> EXTERN: (1156,5) printf(const char *__restrict__, ...)
  -> INLINE: (1160,4) freeFitsImage(FitsImage *) (isz = 56) (sz = 61)
    -> EXTERN: src/utilsFits.c:(1308,6) free(void *)
    -> EXTERN: src/utilsFits.c:(1310,6) free(void *)
    -> EXTERN: src/utilsFits.c:(1313,4) free(void *)
    -> EXTERN: src/utilsFits.c:(1316,4) free(void *)
    -> EXTERN: src/utilsFits.c:(1318,4) free(void *)
    -> EXTERN: src/utilsFits.c:(1319,3) free(void *)
  -> EXTERN: (1164,3) free(void *)
  -> EXTERN: (1165,3) free(void *)
  -> EXTERN: (1166,3) free(void *)
  -> EXTERN: (1178,3) MPI_Barrier(MPI_Comm)
  -> EXTERN: (1182,32) access(const char *, int)
  -> EXTERN: (1184,16) clock(void)
  -> EXTERN: (1185,16) clock(void)
  -> CP_CLONE (1186,16) readFitsSpectroImage..0(const char *, int) (isz = 732) (sz = 750)
     [[ Inlining would exceed -inline-max-size value (750>230) <3>]]
  -> EXTERN: (1187,8) clock(void)
  -> EXTERN: (1189,4) printf(const char *__restrict__, ...)
  -> EXTERN: (1193,3) MPI_Barrier(MPI_Comm)
  -> EXTERN: (1194,3) MPI_Bcast(void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1195,3) MPI_Barrier(MPI_Comm)
  -> EXTERN: (1201,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1202,29) calloc(size_t, size_t)
  -> EXTERN: (1203,20) calloc(size_t, size_t)
  -> EXTERN: (1204,21) calloc(size_t, size_t)
  -> EXTERN: (1206,29) calloc(size_t, size_t)
  -> EXTERN: (1214,8) _vla_alloc(long)
  -> EXTERN: (1215,8) _vla_alloc(long)
  -> EXTERN: (1216,8) _vla_alloc(long)
  -> EXTERN: (1217,8) _vla_alloc(long)
  -> EXTERN: (1218,8) _vla_alloc(long)
  -> EXTERN: (1234,4) MPI_Barrier(MPI_Comm)
  -> EXTERN: (1236,18) MPI_Wtime(void)
  -> EXTERN: (1237,26) MPI_Wtime(void)
  -> EXTERN: (1238,20) calloc(size_t, size_t)
  -> EXTERN: (1241,29) calloc(size_t, size_t)
  -> EXTERN: (1244,5) MPI_Scatterv(const void *, const int *, const int *, MPI_Datatype, void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1247,5) MPI_Scatterv(const void *, const int *, const int *, MPI_Datatype, void *, int, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1249,27) MPI_Wtime(void)
  -> EXTERN: (1251,23) calloc(size_t, size_t)
  -> EXTERN: (1252,15) calloc(size_t, size_t)
  -> EXTERN: (1253,15) calloc(size_t, size_t)
  -> EXTERN: (1255,28) MPI_Wtime(void)
  -> (1272,5) estimacionesClasicas(double, double *, int, float *, Init_Model *, int) (isz = 329) (sz = 344)
     [[ Inlining would exceed -inline-max-size value (344>230) <3>]]
  -> EXTERN: (1274,9) __isnan(double)
  -> EXTERN: (1276,9) __isnan(double)
  -> EXTERN: (1278,9) __isnan(double)
  -> EXTERN: (1280,9) __isnan(double)
  -> (1295,5) lm_mils(Cuantic *, double *, double *, int, float *, int, Init_Model *, float *, float *, double *, double, int, float *, int *, float *, float, int *, int *) (isz = 900) (sz = 942)
     [[ Inlining would exceed -inline-max-size value (942>230) <3>]]
  -> EXTERN: (1307,29) MPI_Wtime(void)
  -> EXTERN: (1308,25) MPI_Wtime(void)
  -> EXTERN: (1309,4) MPI_Gatherv(const void *, int, MPI_Datatype, void *, const int *, const int *, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1310,4) MPI_Gatherv(const void *, int, MPI_Datatype, void *, const int *, const int *, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1311,4) MPI_Gatherv(const void *, int, MPI_Datatype, void *, const int *, const int *, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1314,5) MPI_Gatherv(const void *, int, MPI_Datatype, void *, const int *, const int *, MPI_Datatype, int, MPI_Comm)
  -> EXTERN: (1316,26) MPI_Wtime(void)
  -> EXTERN: (1317,19) MPI_Wtime(void)
  -> EXTERN: (1322,4) MPI_Reduce(const void *, void *, int, MPI_Datatype, MPI_Op, int, MPI_Comm)
  -> EXTERN: (1323,4) MPI_Reduce(const void *, void *, int, MPI_Datatype, MPI_Op, int, MPI_Comm)
  -> EXTERN: (1324,4) MPI_Reduce(const void *, void *, int, MPI_Datatype, MPI_Op, int, MPI_Comm)
  -> EXTERN: (1325,4) MPI_Reduce(const void *, void *, int, MPI_Datatype, MPI_Op, int, MPI_Comm)
  -> EXTERN: (1332,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1333,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1338,9) clock(void)
  -> (1339,9) writeFitsImageModels(const char *, int, int, Init_Model *, float *, int *, int) (isz = 355) (sz = 377)
     [[ Inlining would exceed -inline-max-size value (377>230) <3>]]
  -> EXTERN: (1340,7) printf(const char *__restrict__, ...)
  -> EXTERN: (1342,9) clock(void)
  -> EXTERN: (1344,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1346,26) calloc(size_t, size_t)
  -> EXTERN: (1348,38) calloc(size_t, size_t)
  -> (1360,10) writeFitsImageProfiles(const char *, const char *, FitsImage *) (isz = 303) (sz = 319)
     [[ Inlining would exceed -inline-max-size value (319>230) <3>]]
  -> EXTERN: (1361,7) printf(const char *__restrict__, ...)
  -> EXTERN: (1365,7) free(void *)
  -> EXTERN: (1369,6) free(void *)
  -> EXTERN: (1372,17) clock(void)
  -> EXTERN: (1374,5) free(void *)
  -> EXTERN: (1375,5) free(void *)
  -> EXTERN: (1376,5) free(void *)
  -> EXTERN: (1378,6) free(void *)
  -> EXTERN: (1380,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1381,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1382,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1386,6) free(void *)
  -> EXTERN: (1387,5) free(void *)
  -> EXTERN: (1388,5) free(void *)
  -> EXTERN: (1389,5) free(void *)
  -> EXTERN: (1390,5) free(void *)
  -> EXTERN: (1392,3) _vla_free(void *, long)
  -> EXTERN: (1392,3) _vla_free(void *, long)
  -> EXTERN: (1392,3) _vla_free(void *, long)
  -> EXTERN: (1392,3) _vla_free(void *, long)
  -> EXTERN: (1392,3) _vla_free(void *, long)
  -> EXTERN: (1396,5) printf(const char *__restrict__, ...)
  -> INLINE: (1400,4) freeFitsImage(FitsImage *) (isz = 56) (sz = 61)
    -> EXTERN: src/utilsFits.c:(1308,6) free(void *)
    -> EXTERN: src/utilsFits.c:(1310,6) free(void *)
    -> EXTERN: src/utilsFits.c:(1313,4) free(void *)
    -> EXTERN: src/utilsFits.c:(1316,4) free(void *)
    -> EXTERN: src/utilsFits.c:(1318,4) free(void *)
    -> EXTERN: src/utilsFits.c:(1319,3) free(void *)
  -> INLINE: (1406,2) FreeMemoryDerivedSynthesis() (isz = 220) (sz = 223)
    -> EXTERN: src/calculosCompartidos.c:(159,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(160,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(161,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(162,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(163,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(164,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(166,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(167,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(168,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(170,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(171,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(172,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(173,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(174,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(175,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(176,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(177,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(179,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(181,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(182,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(183,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(184,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(185,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(186,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(187,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(189,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(190,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(191,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(192,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(193,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(194,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(195,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(197,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(198,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(200,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(201,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(202,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(205,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(206,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(207,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(208,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(212,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(213,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(214,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(215,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(216,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(217,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(219,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(220,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(221,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(222,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(223,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(224,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(225,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(227,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(228,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(229,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(230,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(232,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(233,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(234,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(236,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(237,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(238,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(240,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(241,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(242,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(244,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(245,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(246,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(251,3) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(256,3) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(261,3) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(264,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(265,2) free(void *)
    -> EXTERN: src/calculosCompartidos.c:(266,2) free(void *)
  -> EXTERN: (1408,2) fftw_free(void *)
  -> EXTERN: (1409,2) fftw_free(void *)
  -> EXTERN: (1410,2) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (1411,2) fftw_free(void *)
  -> EXTERN: (1412,2) fftw_free(void *)
  -> EXTERN: (1413,2) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (1414,2) fftw_free(void *)
  -> EXTERN: (1415,2) fftw_free(void *)
  -> EXTERN: (1416,2) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (1417,2) fftw_free(void *)
  -> EXTERN: (1418,2) fftw_free(void *)
  -> EXTERN: (1419,2) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (1422,3) fftw_free(void *)
  -> EXTERN: (1423,3) fftw_free(void *)
  -> EXTERN: (1424,3) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (1425,3) fftw_free(void *)
  -> EXTERN: (1426,3) fftw_free(void *)
  -> EXTERN: (1427,3) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (1429,3) fftw_free(void *)
  -> EXTERN: (1430,3) fftw_free(void *)
  -> EXTERN: (1431,3) fftw_free(void *)
  -> EXTERN: (1433,3) fftw_free(void *)
  -> EXTERN: (1434,3) fftw_free(void *)
  -> EXTERN: (1435,3) fftw_free(void *)
  -> EXTERN: (1436,3) fftw_free(void *)
  -> EXTERN: (1437,3) fftw_free(void *)
  -> EXTERN: (1438,3) fftw_free(void *)
  -> EXTERN: (1440,3) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (1441,3) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (1442,3) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (1443,3) fftw_destroy_plan(fftw_plan)
  -> EXTERN: (1446,32) free(void *)
  -> EXTERN: (1447,40) free(void *)
  -> EXTERN: (1448,44) free(void *)
  -> EXTERN: (1449,32) free(void *)
  -> EXTERN: (1450,40) free(void *)
  -> EXTERN: (1451,44) free(void *)
  -> EXTERN: (1452,43) free(void *)
  -> EXTERN: (1453,51) free(void *)
  -> EXTERN: (1454,55) free(void *)
  -> EXTERN: (1459,2) free(void *)
  -> EXTERN: (1460,2) free(void *)
  -> EXTERN: (1461,2) free(void *)
  -> EXTERN: (1464,2) MPI_Type_free(MPI_Datatype *)
  -> EXTERN: (1465,2) MPI_Finalize(void)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) _vla_free(void *, long)
  -> EXTERN: (1466,2) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/readConfig.c(2283,5) inlined into src/milosMPI.c(218,13)
   remark #15523: loop was not vectorized: loop control variable iter was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at src/readConfig.c(643,2) inlined into src/milosMPI.c(241,15)
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at src/milosMPI.c(245,3)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between vOffsetsLambda[i] (246:4) and vOffsetsLambda[i-1] (246:4)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at src/milosMPI.c(245,3)
<Remainder>
LOOP END

LOOP BEGIN at src/milosMPI.c(259,6)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between vGlobalLambda[i] (260:10) and vGlobalLambda[i-1] (260:10)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at src/milosMPI.c(259,6)
<Remainder>
LOOP END

LOOP BEGIN at src/utilsFits.c(1157,6) inlined into src/milosMPI.c(264,19)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop

   LOOP BEGIN at src/utilsFits.c(1158,7) inlined into src/milosMPI.c(264,19)
      remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   LOOP END
LOOP END

LOOP BEGIN at src/utilsFits.c(1168,6) inlined into src/milosMPI.c(264,19)
   remark #15382: vectorization support: call to function printf(const char *__restrict__, ...) cannot be vectorized   [ src/utilsFits.c(1169,7) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
LOOP END

LOOP BEGIN at src/fgauss.c(139,2) inlined into src/milosMPI.c(323,8)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/fgauss.c(139,2) inlined into src/milosMPI.c(323,8)
   remark #15388: vectorization support: reference term[i] has aligned access   [ src/fgauss.c(143,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.102
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 47 
   remark #15477: vector cost: 24.500 
   remark #15478: estimated potential speedup: 1.890 
   remark #15486: divides: 1 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(139,2) inlined into src/milosMPI.c(323,8)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference term[i] has aligned access   [ src/fgauss.c(143,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.408
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15457: masked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 23 
   remark #15477: vector cost: 22.500 
   remark #15478: estimated potential speedup: 1.010 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(139,2) inlined into src/milosMPI.c(323,8)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/fgauss.c(148,2) inlined into src/milosMPI.c(323,8)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/fgauss.c(148,2) inlined into src/milosMPI.c(323,8)
   remark #15389: vectorization support: reference loai[i] has unaligned access   [ src/fgauss.c(153,4) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.161
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15457: masked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 23 
   remark #15477: vector cost: 22.500 
   remark #15478: estimated potential speedup: 1.010 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(148,2) inlined into src/milosMPI.c(323,8)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/fgauss.c(161,3) inlined into src/milosMPI.c(323,8)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/fgauss.c(161,3) inlined into src/milosMPI.c(323,8)
   remark #15389: vectorization support: reference term[i] has unaligned access   [ src/fgauss.c(165,19) ]
   remark #15389: vectorization support: reference mtb[i] has unaligned access   [ src/fgauss.c(165,5) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.082
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15456: masked unaligned unit stride loads: 1 
   remark #15457: masked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 140 
   remark #15477: vector cost: 73.000 
   remark #15478: estimated potential speedup: 1.900 
   remark #15482: vectorized math library calls: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(161,3) inlined into src/milosMPI.c(323,8)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/fgauss.c(175,3) inlined into src/milosMPI.c(323,8)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/fgauss.c(175,3) inlined into src/milosMPI.c(323,8)
   remark #15388: vectorization support: reference term[i] has aligned access   [ src/fgauss.c(177,18) ]
   remark #15388: vectorization support: reference mtb[i] has aligned access   [ src/fgauss.c(177,4) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.192
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 108 
   remark #15477: vector cost: 39.000 
   remark #15478: estimated potential speedup: 2.730 
   remark #15482: vectorized math library calls: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(175,3) inlined into src/milosMPI.c(323,8)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/fgauss.c(175,3) inlined into src/milosMPI.c(323,8)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/fgauss.c(184,2) inlined into src/milosMPI.c(323,8)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/fgauss.c(184,2) inlined into src/milosMPI.c(323,8)
   remark #15388: vectorization support: reference mtb[i] has aligned access   [ src/fgauss.c(186,10) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 1.450
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 6 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 2.260 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(184,2) inlined into src/milosMPI.c(323,8)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/fgauss.c(189,2) inlined into src/milosMPI.c(323,8)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/fgauss.c(189,2) inlined into src/milosMPI.c(323,8)
   remark #15388: vectorization support: reference mtb[i] has aligned access   [ src/fgauss.c(191,3) ]
   remark #15388: vectorization support: reference mtb[i] has aligned access   [ src/fgauss.c(191,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.086
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 31 
   remark #15477: vector cost: 17.500 
   remark #15478: estimated potential speedup: 1.740 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(189,2) inlined into src/milosMPI.c(323,8)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference mtb[i] has aligned access   [ src/fgauss.c(191,3) ]
   remark #15388: vectorization support: reference mtb[i] has aligned access   [ src/fgauss.c(191,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.343
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 31 
   remark #15477: vector cost: 17.500 
   remark #15478: estimated potential speedup: 1.740 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(189,2) inlined into src/milosMPI.c(323,8)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/milosMPI.c(340,5)
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at src/readConfig.c(690,2) inlined into src/milosMPI.c(351,6)
   remark #15523: loop was not vectorized: loop control variable index was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at src/milosMPI.c(362,6)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ src/milosMPI.c(363,7) ]
LOOP END

LOOP BEGIN at src/milosUtils.c(768,2) inlined into src/milosMPI.c(371,6)
<Predicate Optimized v1>
   remark #25422: Invariant Condition at line 771 hoisted out of this loop
   remark #15382: vectorization support: call to function gsl_interp_eval(const gsl_interp *, const double *, const double *, double, gsl_interp_accel *) cannot be vectorized   [ src/milosUtils.c(773,11) ]
   remark #15382: vectorization support: call to function gsl_isnan(const double) cannot be vectorized   [ src/milosUtils.c(775,9) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at src/milosUtils.c(768,2) inlined into src/milosMPI.c(371,6)
<Remainder, Predicate Optimized v1>
LOOP END

LOOP BEGIN at src/milosUtils.c(768,2) inlined into src/milosMPI.c(371,6)
<Predicate Optimized v2>
   remark #15382: vectorization support: call to function gsl_interp_eval(const gsl_interp *, const double *, const double *, double, gsl_interp_accel *) cannot be vectorized   [ src/milosUtils.c(787,11) ]
   remark #15382: vectorization support: call to function gsl_isnan(const double) cannot be vectorized   [ src/milosUtils.c(789,9) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at src/milosUtils.c(768,2) inlined into src/milosMPI.c(371,6)
<Remainder, Predicate Optimized v2>
LOOP END

LOOP BEGIN at src/milosUtils.c(806,2) inlined into src/milosMPI.c(371,6)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/milosUtils.c(806,2) inlined into src/milosMPI.c(371,6)
   remark #15388: vectorization support: reference G[i] has aligned access   [ src/milosUtils.c(807,10) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 1.450
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 6 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 2.260 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosUtils.c(806,2) inlined into src/milosMPI.c(371,6)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/milosUtils.c(809,2) inlined into src/milosMPI.c(371,6)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/milosUtils.c(809,2) inlined into src/milosMPI.c(371,6)
   remark #15388: vectorization support: reference G[i] has aligned access   [ src/milosUtils.c(810,3) ]
   remark #15388: vectorization support: reference G[i] has aligned access   [ src/milosUtils.c(810,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.086
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 31 
   remark #15477: vector cost: 17.500 
   remark #15478: estimated potential speedup: 1.740 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosUtils.c(809,2) inlined into src/milosMPI.c(371,6)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference G[i] has aligned access   [ src/milosUtils.c(810,3) ]
   remark #15388: vectorization support: reference G[i] has aligned access   [ src/milosUtils.c(810,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.343
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 31 
   remark #15477: vector cost: 17.500 
   remark #15478: estimated potential speedup: 1.740 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosUtils.c(809,2) inlined into src/milosMPI.c(371,6)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/milosMPI.c(393,3)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/milosMPI.c(393,3)
   remark #15388: vectorization support: reference in[i] has aligned access   [ src/milosMPI.c(395,4) ]
   remark #15388: vectorization support: reference G[i] has aligned access   [ src/milosMPI.c(395,12) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.438
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 14 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 3.340 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosMPI.c(393,3)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/milosMPI.c(393,3)
<Remainder loop for vectorization>
   remark #15516: remainder loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 68 
   remark #15477: vector cost: 5.000 
   remark #15478: estimated potential speedup: 13.500 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosMPI.c(400,3)
   remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 68 
   remark #15477: vector cost: 5.000 
   remark #15478: estimated potential speedup: 13.500 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 8  
LOOP END

LOOP BEGIN at src/milosMPI.c(400,3)
<Remainder>
   remark #25436: completely unrolled by 7  
LOOP END

LOOP BEGIN at src/readConfig.c(2302,2) inlined into src/milosMPI.c(436,43)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/readConfig.c(2304,4) inlined into src/milosMPI.c(436,43)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=15
   LOOP END

   LOOP BEGIN at src/readConfig.c(2304,4) inlined into src/milosMPI.c(436,43)
      remark #15388: vectorization support: reference ext[j] has aligned access   [ src/readConfig.c(2305,5) ]
      remark #15388: vectorization support: reference *(&configCrontrolFile+j+20484) has aligned access   [ src/readConfig.c(2305,14) ]
      remark #15305: vectorization support: vector length 16
      remark #15309: vectorization support: normalized vectorization overhead 6.000
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 5 
      remark #15477: vector cost: 0.180 
      remark #15478: estimated potential speedup: 7.170 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/readConfig.c(2304,4) inlined into src/milosMPI.c(436,43)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/readConfig.c(2304,4) inlined into src/milosMPI.c(436,43)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/readConfig.c(2302,2) inlined into src/milosMPI.c(441,48)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/readConfig.c(2304,4) inlined into src/milosMPI.c(441,48)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=15
   LOOP END

   LOOP BEGIN at src/readConfig.c(2304,4) inlined into src/milosMPI.c(441,48)
      remark #15388: vectorization support: reference ext[j] has aligned access   [ src/readConfig.c(2305,5) ]
      remark #15388: vectorization support: reference *(&configCrontrolFile+j+4) has aligned access   [ src/readConfig.c(2305,14) ]
      remark #15305: vectorization support: vector length 16
      remark #15309: vectorization support: normalized vectorization overhead 6.000
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 5 
      remark #15477: vector cost: 0.180 
      remark #15478: estimated potential speedup: 7.170 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/readConfig.c(2304,4) inlined into src/milosMPI.c(441,48)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/readConfig.c(2304,4) inlined into src/milosMPI.c(441,48)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/milosMPI.c(455,4)
   remark #15382: vectorization support: call to function sprintf(char *__restrict__, const char *__restrict__, ...) cannot be vectorized   [ src/milosMPI.c(458,6) ]
   remark #15382: vectorization support: call to function sprintf(char *__restrict__, const char *__restrict__, ...) cannot be vectorized   [ src/milosMPI.c(460,6) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(462,5) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(463,5) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(464,5) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(466,5) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(467,5) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(468,5) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(470,6) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(471,6) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(473,5) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(475,5) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(476,5) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(477,5) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(479,6) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(480,6) ]
   remark #15382: vectorization support: call to function strcat(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(482,5) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between call:sprintf(char *__restrict__, const char *__restrict__, ...) (458:6) and call:strcat(char *__restrict__, const char *__restrict__) (482:5)
   remark #15346: vector dependence: assumed OUTPUT dependence between call:strcat(char *__restrict__, const char *__restrict__) (482:5) and call:sprintf(char *__restrict__, const char *__restrict__, ...) (458:6)
LOOP END

LOOP BEGIN at src/milosMPI.c(515,2)
<Distributed chunk1>
   remark #25426: Loop Distributed (2 way) 
   remark #15388: vectorization support: reference sendcountsNameInputFiles[i] has aligned access   [ src/milosMPI.c(516,3) ]
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.000
   remark #15301: PARTIAL LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.750 
   remark #15478: estimated potential speedup: 2.630 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosMPI.c(515,2)
<Remainder loop for vectorization, Distributed chunk1>
LOOP END

LOOP BEGIN at src/milosMPI.c(515,2)
<Distributed chunk2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between sum (517:3) and sum (518:3)
   remark #15346: vector dependence: assumed FLOW dependence between sum (518:3) and sum (517:3)
   remark #15346: vector dependence: assumed FLOW dependence between sum (518:3) and sum (517:3)
   remark #15346: vector dependence: assumed ANTI dependence between sum (517:3) and sum (518:3)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at src/milosMPI.c(515,2)
<Remainder, Distributed chunk2>
LOOP END

LOOP BEGIN at src/milosMPI.c(529,3)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at src/milosMPI.c(538,3)
   remark #15382: vectorization support: call to function MPI_Group_incl(MPI_Group, int, const int *, MPI_Group *) cannot be vectorized   [ src/milosMPI.c(544,5) ]
   remark #15382: vectorization support: call to function MPI_Group_incl(MPI_Group, int, const int *, MPI_Group *) cannot be vectorized   [ src/milosMPI.c(550,5) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between ranks[0] (541:5) and ranks (550:5)
   remark #15346: vector dependence: assumed ANTI dependence between ranks (550:5) and ranks[0] (541:5)
LOOP END

LOOP BEGIN at src/milosMPI.c(556,2)
   remark #15382: vectorization support: call to function MPI_Comm_create(MPI_Comm, MPI_Group, MPI_Comm *) cannot be vectorized   [ src/milosMPI.c(557,3) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
LOOP END

LOOP BEGIN at src/milosMPI.c(581,4)
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(582,5) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(583,5) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(584,5) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between vInputFileSpectra->name[numFilesPerProcess*numProcs+i] (582:5) and vOutputNameSynthesisAdjustedDiv2Parallel->name[i] (584:5)
   remark #15346: vector dependence: assumed FLOW dependence between vOutputNameSynthesisAdjustedDiv2Parallel->name[i] (584:5) and vInputFileSpectra->name[numFilesPerProcess*numProcs+i] (582:5)
LOOP END

LOOP BEGIN at src/milosMPI.c(592,5)
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(593,6) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(594,6) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(595,6) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between vInputFileSpectra->name[numFilesPerProcess*numProcs+numFilesPer2 (593:6) and vOutputNameSynthesisAdjustedParallel->name[i] (595:6)
   remark #15346: vector dependence: assumed FLOW dependence between vOutputNameSynthesisAdjustedParallel->name[i] (595:6) and vInputFileSpectra->name[numFilesPerProcess*numProcs+numFilesPer2 (593:6)
LOOP END

LOOP BEGIN at src/milosMPI.c(603,4)
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(604,5) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(605,5) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(606,5) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between vInputFileSpectra->name[i] (604:5) and auxOutputSynthesisAdjusted->name[i] (606:5)
   remark #15346: vector dependence: assumed FLOW dependence between auxOutputSynthesisAdjusted->name[i] (606:5) and vInputFileSpectra->name[i] (604:5)
LOOP END

LOOP BEGIN at src/milosMPI.c(633,5)
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(634,6) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(635,6) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(636,6) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between vInputFileSpectra->name[i] (634:6) and vOutputNameSynthesisAdjustedDiv2Parallel->name[i] (636:6)
   remark #15346: vector dependence: assumed FLOW dependence between vOutputNameSynthesisAdjustedDiv2Parallel->name[i] (636:6) and vInputFileSpectra->name[i] (634:6)
LOOP END

LOOP BEGIN at src/milosMPI.c(644,4)
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(645,5) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(646,5) ]
   remark #15382: vectorization support: call to function strcpy(char *__restrict__, const char *__restrict__) cannot be vectorized   [ src/milosMPI.c(647,5) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between vInputFileSpectra->name[numFilesPer2ProcessParallel+i] (645:5) and vOutputNameSynthesisAdjustedParallel->name[i] (647:5)
   remark #15346: vector dependence: assumed FLOW dependence between vOutputNameSynthesisAdjustedParallel->name[i] (647:5) and vInputFileSpectra->name[numFilesPer2ProcessParallel+i] (645:5)
LOOP END

LOOP BEGIN at src/milosMPI.c(721,3)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at src/milosMPI.c(762,5)
      remark #25427: Loop Statements Reordered
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between resto (764:6) and resto (766:8)
      remark #15346: vector dependence: assumed FLOW dependence between resto (766:8) and resto (764:6)
      remark #15346: vector dependence: assumed FLOW dependence between resto (766:8) and resto (764:6)
      remark #15346: vector dependence: assumed ANTI dependence between resto (764:6) and resto (766:8)
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

LOOP BEGIN at src/milosMPI.c(823,3)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/milosMPI.c(826,5)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/milosMPI.c(871,7)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at src/milosMPI.c(871,7)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at src/milosMPI.c(871,7)
            remark #15388: vectorization support: reference vSpectraAdjustedSplit_L[indexInputFits][indexPixel*(nlambda*4)+kk] has aligned access   [ src/milosMPI.c(873,8) ]
            remark #15388: vectorization support: reference spectra[kk] has aligned access   [ src/milosMPI.c(873,87) ]
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 4.667
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 0.750 
            remark #15478: estimated potential speedup: 2.440 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at src/milosMPI.c(871,7)
         <Alternate Alignment Vectorized Loop>
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at src/milosMPI.c(871,7)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=24
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/milosMPI.c(893,23)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/milosMPI.c(915,7)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at src/milosMPI.c(919,7)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/milosMPI.c(922,8)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/milosMPI.c(922,8)
         remark #15388: vectorization support: reference (((*(fitsImages+indexInputFits*8))->pixels+indexPixel*24)->spectro)[kk] has aligned access   [ src/milosMPI.c(924,9) ]
         remark #15388: vectorization support: reference vSpectraAjustedTotal_L[indexInputFits][kk+indexPixel*(nlambda*4)] has aligned access   [ src/milosMPI.c(924,70) ]
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 5.333
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 5 
         remark #15477: vector cost: 0.750 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/milosMPI.c(922,8)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/milosMPI.c(922,8)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at src/milosMPI.c(932,7)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at src/utilsFits.c(1306,4) inlined into src/milosMPI.c(953,6)
      remark #15527: loop was not vectorized: function call to free(void *) cannot be vectorized   [ src/utilsFits.c(1308,6) ]
   LOOP END
LOOP END

LOOP BEGIN at src/milosMPI.c(1009,3)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/milosMPI.c(1040,6)
      remark #15527: loop was not vectorized: function call to calloc(size_t, size_t) cannot be vectorized   [ src/milosMPI.c(1041,46) ]
   LOOP END

   LOOP BEGIN at src/milosMPI.c(1061,5)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/milosMPI.c(1106,7)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at src/milosMPI.c(1106,7)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at src/milosMPI.c(1106,7)
            remark #15388: vectorization support: reference ((imageStokesAdjust->pixels+indexPixel*24)->spectro)[kk] has aligned access   [ src/milosMPI.c(1108,8) ]
            remark #15388: vectorization support: reference spectra[kk] has aligned access   [ src/milosMPI.c(1108,60) ]
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 5.333
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 0.750 
            remark #15478: estimated potential speedup: 2.350 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at src/milosMPI.c(1106,7)
         <Alternate Alignment Vectorized Loop>
            remark #25015: Estimate of max trip count of loop=6
         LOOP END

         LOOP BEGIN at src/milosMPI.c(1106,7)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=24
         LOOP END
      LOOP END
   LOOP END

   LOOP BEGIN at src/milosMPI.c(1143,6)
      remark #15527: loop was not vectorized: function call to free(void *) cannot be vectorized   [ src/milosMPI.c(1144,7) ]
   LOOP END

   LOOP BEGIN at src/utilsFits.c(1306,4) inlined into src/milosMPI.c(1160,4)
      remark #15527: loop was not vectorized: function call to free(void *) cannot be vectorized   [ src/utilsFits.c(1308,6) ]
   LOOP END

   LOOP BEGIN at src/milosMPI.c(1030,6)
      remark #15389: vectorization support: reference imageStokesAdjust[_2] has unaligned access
      remark #15389: vectorization support: reference fitsImage[_2] has unaligned access   [ src/milosMPI.c(1030,32) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15427: loop was completely unrolled
      remark #15309: vectorization support: normalized vectorization overhead 0.750
      remark #15301: MATERIALIZED LOOP WAS VECTORIZED
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 5 
      remark #15477: vector cost: 2.000 
      remark #15478: estimated potential speedup: 1.420 
      remark #15488: --- end vector cost summary ---
   LOOP END
LOOP END

LOOP BEGIN at src/milosMPI.c(1219,4)
<Distributed chunk1>
   remark #25426: Loop Distributed (4 way) 
   remark #15388: vectorization support: reference sendcountsDiv2Pixels[i] has aligned access   [ src/milosMPI.c(1220,5) ]
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.000
   remark #15301: PARTIAL LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 2 
   remark #15477: vector cost: 0.750 
   remark #15478: estimated potential speedup: 2.630 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosMPI.c(1219,4)
<Remainder loop for vectorization, Distributed chunk1>
LOOP END

LOOP BEGIN at src/milosMPI.c(1219,4)
<Distributed chunk2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between resto (1221:5) and resto (1223:7)
   remark #15346: vector dependence: assumed FLOW dependence between resto (1223:7) and resto (1221:5)
   remark #15346: vector dependence: assumed FLOW dependence between resto (1223:7) and resto (1221:5)
   remark #15346: vector dependence: assumed ANTI dependence between resto (1221:5) and resto (1223:7)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at src/milosMPI.c(1219,4)
<Remainder, Distributed chunk2>
LOOP END

LOOP BEGIN at src/milosMPI.c(1219,4)
<Distributed chunk3>
   remark #15388: vectorization support: reference sendcountsDiv2Spectro[i] has aligned access   [ src/milosMPI.c(1225,5) ]
   remark #15388: vectorization support: reference sendcountsDiv2Pixels[i] has aligned access   [ src/milosMPI.c(1225,32) ]
   remark #15388: vectorization support: reference sendcountsDiv2Lambda[i] has aligned access   [ src/milosMPI.c(1226,5) ]
   remark #15388: vectorization support: reference sendcountsDiv2Pixels[i] has aligned access   [ src/milosMPI.c(1226,31) ]
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.600
   remark #15301: PARTIAL LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 2 
   remark #15449: unmasked aligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 11 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 4.360 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosMPI.c(1219,4)
<Remainder loop for vectorization, Distributed chunk3>
LOOP END

LOOP BEGIN at src/milosMPI.c(1219,4)
<Distributed chunk4>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between sumSpectro (1228:5) and sumSpectro (1231:5)
   remark #15346: vector dependence: assumed FLOW dependence between sumSpectro (1231:5) and sumSpectro (1228:5)
   remark #15346: vector dependence: assumed FLOW dependence between sumSpectro (1231:5) and sumSpectro (1228:5)
   remark #15346: vector dependence: assumed ANTI dependence between sumSpectro (1228:5) and sumSpectro (1231:5)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at src/milosMPI.c(1219,4)
<Remainder, Distributed chunk4>
LOOP END

LOOP BEGIN at src/milosMPI.c(1256,4)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/milosMPI.c(1301,6)
      remark #25399: memcopy generated
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/milosMPI.c(1301,6)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/milosMPI.c(1301,6)
         remark #15388: vectorization support: reference vSpectraAdjustedSplit[indexPixel*(nlambda*4)+kk] has aligned access   [ src/milosMPI.c(1303,7) ]
         remark #15388: vectorization support: reference spectra[kk] has aligned access   [ src/milosMPI.c(1303,68) ]
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 4.667
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 5 
         remark #15477: vector cost: 0.750 
         remark #15478: estimated potential speedup: 2.440 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at src/milosMPI.c(1301,6)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at src/milosMPI.c(1301,6)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=24
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/milosMPI.c(1347,6)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at src/milosMPI.c(1351,6)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/milosMPI.c(1354,7)
      remark #25399: memcopy generated
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/milosMPI.c(1354,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/milosMPI.c(1354,7)
         remark #15388: vectorization support: reference ((fitsImage->pixels+indexPixel*24)->spectro)[kk] has aligned access   [ src/milosMPI.c(1356,8) ]
         remark #15388: vectorization support: reference vSpectraAjustedTotal[kk+indexPixel*(nlambda*4)] has aligned access   [ src/milosMPI.c(1356,52) ]
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 5.333
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 5 
         remark #15477: vector cost: 0.750 
         remark #15478: estimated potential speedup: 2.350 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at src/milosMPI.c(1354,7)
      <Alternate Alignment Vectorized Loop>
         remark #25015: Estimate of max trip count of loop=6
      LOOP END

      LOOP BEGIN at src/milosMPI.c(1354,7)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=24
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/milosMPI.c(1364,6)
   remark #15527: loop was not vectorized: function call to free(void *) cannot be vectorized   [ src/milosMPI.c(1365,7) ]
LOOP END

LOOP BEGIN at src/utilsFits.c(1306,4) inlined into src/milosMPI.c(1400,4)
   remark #15527: loop was not vectorized: function call to free(void *) cannot be vectorized   [ src/utilsFits.c(1308,6) ]
LOOP END

LOOP BEGIN at src/calculosCompartidos.c(249,2) inlined into src/milosMPI.c(1406,2)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at src/calculosCompartidos.c(254,2) inlined into src/milosMPI.c(1406,2)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at src/calculosCompartidos.c(259,2) inlined into src/milosMPI.c(1406,2)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

    Report from: Code generation optimizations [cg]

src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(402,36):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/milosMPI.c(402,36):remark #34048: consider using complex-limited-range option to boost run time performance.
src/milosMPI.c(110,32):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/milosMPI.c(111,35):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (16, 0)
src/utilsFits.c(1144,17):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/utilsFits.c(1184,22):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/milosMPI.c(871,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/milosMPI.c(871,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/milosMPI.c(871,7):remark #34026: call to memcpy implemented as a call to optimized library version
src/milosMPI.c(1106,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/milosMPI.c(1106,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/milosMPI.c(1106,7):remark #34026: call to memcpy implemented as a call to optimized library version
src/milosMPI.c(1301,6):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/milosMPI.c(1301,6):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/milosMPI.c(1301,6):remark #34026: call to memcpy implemented as a call to optimized library version
src/milosMPI.c(1354,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/milosMPI.c(1354,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/milosMPI.c(1354,7):remark #34026: call to memcpy implemented as a call to optimized library version
src/milosMPI.c(96,1):remark #34051: REGISTER ALLOCATION : [main] src/milosMPI.c:96

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   38[ rax rdx rcx rbx rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        
    Routine temporaries
        Total         :    3844
            Global    :    1012
            Local     :    2832
        Regenerable   :     629
        Spilled       :     234
        
    Routine stack
        Variables     :    1109 bytes*
            Reads     :     306 [1.00e+02 ~ 6.1%]
            Writes    :     201 [7.33e+01 ~ 4.5%]
        Spills        :    1808 bytes*
            Reads     :    1028 [1.46e+02 ~ 8.9%]
            Writes    :     436 [5.33e+01 ~ 3.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: lm_mils(Cuantic *, double *, double *, int, float *, int, Init_Model *, float *, float *, double *, double, int, float *, int *, float *, float, int *, int *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (lm_mils(Cuantic *, double *, double *, int, float *, int, Init_Model *, float *, float *, double *, double, int, float *, int *, float *, float, int *, int *)) [2/70=2.9%] src/milosUtils.c(579,1)
  -> INLINE: (598,10) CalculaNfree(int) (isz = 1) (sz = 8)
  -> (629,2) mil_sinrf(Cuantic *, Init_Model *, double *, double *, int, float *, double, double *, float *, int) (isz = 2136) (sz = 2161)
     [[ Inlining would exceed -inline-max-size value (2161>230) <2>]]
  -> (630,2) me_der(Cuantic *, Init_Model *, double *, double *, int, float *, float *, float *, double, double *, int) (isz = 3487) (sz = 3514)
     [[ Inlining would exceed -inline-max-size value (3514>230) <2>]]
  -> INLINE: (632,2) FijaACeroDerivadasNoNecesarias(float *, int *, int) (isz = 34) (sz = 43)
  -> (633,2) covarm(float *, float *, float *, int, float *, float *, float *, float *) (isz = 271) (sz = 292)
     [[ Inlining would exceed -inline-max-size value (292>230) <2>]]
  -> INLINE: (643,12) fchisqr(float *, int, float *, float *, float *, float) (isz = 39) (sz = 56)
  -> INLINE: (658,3) mil_svd(double *, double *, double *) (isz = 197) (sz = 208)
    -> EXTERN: (330,21) gsl_vector_alloc(const size_t)
    -> EXTERN: (331,23) gsl_matrix_alloc(const size_t, const size_t)
    -> EXTERN: (338,62) gsl_matrix_view_array(double *, const size_t, const size_t)
    -> EXTERN: (339,42) gsl_eigen_symmv_alloc(const size_t)
    -> EXTERN: (340,2) gsl_eigen_symmv(gsl_matrix *, gsl_vector *, gsl_matrix *, gsl_eigen_symmv_workspace *)
    -> EXTERN: (341,2) gsl_eigen_symmv_free(gsl_eigen_symmv_workspace *)
    -> EXTERN: (342,6) gsl_vector_ptr(gsl_vector *, const size_t)
    -> EXTERN: (343,6) gsl_matrix_ptr(gsl_matrix *, const size_t, const size_t)
    -> INLINE: (345,2) multmatrix(double *, int, int, double *, int, int, double *, int *, int *) (isz = 45) (sz = 68)
    -> INLINE: (352,2) multmatrix(double *, int, int, double *, int, int, double *, int *, int *) (isz = 45) (sz = 68)
    -> EXTERN: (354,2) gsl_vector_free(gsl_vector *)
    -> EXTERN: (355,2) gsl_matrix_free(gsl_matrix *)
  -> INLINE: (659,3) AplicaDelta(Init_Model *, double *, int *, Init_Model *) (isz = 142) (sz = 153)
  -> INLINE: (661,3) check(Init_Model *) (isz = 102) (sz = 109)
  -> (662,3) mil_sinrf(Cuantic *, Init_Model *, double *, double *, int, float *, double, double *, float *, int) (isz = 2136) (sz = 2161)
     [[ Inlining would exceed -inline-max-size value (2161>230) <2>]]
  -> INLINE: (664,12) fchisqr(float *, int, float *, float *, float *, float) (isz = 39) (sz = 56)
  -> (679,4) me_der(Cuantic *, Init_Model *, double *, double *, int, float *, float *, float *, double, double *, int) (isz = 3487) (sz = 3514)
     [[ Inlining would exceed -inline-max-size value (3514>230) <2>]]
  -> INLINE: (680,4) FijaACeroDerivadasNoNecesarias(float *, int *, int) (isz = 34) (sz = 43)
  -> (681,4) covarm(float *, float *, float *, int, float *, float *, float *, float *) (isz = 271) (sz = 292)
     [[ Inlining would exceed -inline-max-size value (292>230) <2>]]
  -> EXTERN: (702,20) log10f(float)
  -> EXTERN: (702,35) log10f(float)
  -> EXTERN: (709,3) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/milosUtils.c(611,3)
   remark #15389: vectorization support: reference fixed[i] has unaligned access   [ src/milosUtils.c(613,4) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 1.250 
   remark #15478: estimated potential speedup: 1.500 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/milosUtils.c(611,3)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 3  
LOOP END

LOOP BEGIN at src/milosUtils.c(301,2) inlined into src/milosUtils.c(632,2)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/milosUtils.c(303,4) inlined into src/milosUtils.c(632,2)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/milosUtils.c(304,5) inlined into src/milosUtils.c(632,2)
         remark #25408: memset generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at src/milosUtils.c(304,5) inlined into src/milosUtils.c(632,2)
            remark #15389: vectorization support: reference d_spectra[i+nlambda*In+(j*nlambda)*11] has unaligned access   [ src/milosUtils.c(305,6) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.250
            remark #15300: LOOP WAS VECTORIZED
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.460 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at src/milosUtils.c(304,5) inlined into src/milosUtils.c(632,2)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=24
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/milosUtils.c(635,2)
   remark #15388: vectorization support: reference betad[i] has aligned access   [ src/milosUtils.c(636,3) ]
   remark #15388: vectorization support: reference beta[i] has aligned access   [ src/milosUtils.c(636,14) ]
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(636,3) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 1.770 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/milosUtils.c(635,2)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 3  
LOOP END

LOOP BEGIN at src/milosUtils.c(638,2)
   remark #15388: vectorization support: reference covar[i] has aligned access   [ src/milosUtils.c(639,3) ]
   remark #15388: vectorization support: reference alpha[i] has aligned access   [ src/milosUtils.c(639,14) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(639,3) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 2.460 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at src/milosUtils.c(638,2)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

LOOP BEGIN at src/lib.c(69,2) inlined into src/milosUtils.c(643,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/lib.c(71,3) inlined into src/milosUtils.c(643,12)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/lib.c(71,3) inlined into src/milosUtils.c(643,12)
      remark #15388: vectorization support: reference spectra[i+nspectro*j] has aligned access   [ src/lib.c(72,8) ]
      remark #15388: vectorization support: reference spectro[i+nspectro*j] has aligned access   [ src/lib.c(72,30) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.958
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 3.660 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/lib.c(71,3) inlined into src/milosUtils.c(643,12)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/lib.c(71,3) inlined into src/milosUtils.c(643,12)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/milosUtils.c(652,3)
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <covar[ind]>, stride is 12   [ src/milosUtils.c(655,4) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <alpha[ind]>, stride is 12   [ src/milosUtils.c(655,17) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 5
   remark #15309: vectorization support: normalized vectorization overhead 0.036
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(655,4) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15452: unmasked strided loads: 1 
   remark #15453: unmasked strided stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 10 
   remark #15477: vector cost: 5.500 
   remark #15478: estimated potential speedup: 1.640 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/milosUtils.c(652,3)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

LOOP BEGIN at src/milosUtils.c(333,2) inlined into src/milosUtils.c(658,3)
   remark #25399: memcopy generated
   remark #15398: loop was not vectorized: loop was transformed to memset or memcpy
LOOP END

LOOP BEGIN at src/lib.c(180,7) inlined into src/milosUtils.c(658,3)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/lib.c(180,7) inlined into src/milosUtils.c(658,3)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
   remark #15388: vectorization support: reference v[k*11+j] has aligned access   [ src/lib.c(184,26) ]
   remark #15389: vectorization support: reference v[k*11+j] has unaligned access   [ src/lib.c(184,26) ]
   remark #15388: vectorization support: reference v[k*11+j] has aligned access   [ src/lib.c(184,26) ]
   remark #15389: vectorization support: reference v[k*11+j] has unaligned access   [ src/lib.c(184,26) ]
   remark #15388: vectorization support: reference v[k*11+j] has aligned access   [ src/lib.c(184,26) ]
   remark #15389: vectorization support: reference v[k*11+j] has unaligned access   [ src/lib.c(184,26) ]
   remark #15388: vectorization support: reference v[k*11+j] has aligned access   [ src/lib.c(184,26) ]
   remark #15389: vectorization support: reference v[k*11+j] has unaligned access   [ src/lib.c(184,26) ]
   remark #15388: vectorization support: reference v[k*11+j] has aligned access   [ src/lib.c(184,26) ]
   remark #15389: vectorization support: reference v[k*11+j] has unaligned access   [ src/lib.c(184,26) ]
   remark #15388: vectorization support: reference v[k*11+j] has aligned access   [ src/lib.c(184,26) ]
   remark #15389: vectorization support: reference aux2[j] has unaligned access   [ src/milosUtils.c(345,49) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.644
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 6 
   remark #15450: unmasked unaligned unit stride loads: 5 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 101 
   remark #15477: vector cost: 45.000 
   remark #15478: estimated potential speedup: 1.820 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=5

   LOOP BEGIN at src/lib.c(182,5) inlined into src/milosUtils.c(658,3)
      remark #25436: completely unrolled by 11   (pre-vector) 
   LOOP END
LOOP END

LOOP BEGIN at src/lib.c(180,7) inlined into src/milosUtils.c(658,3)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/milosUtils.c(347,2) inlined into src/milosUtils.c(658,3)
   remark #15389: vectorization support: reference w[i] has unaligned access   [ src/milosUtils.c(349,49) ]
   remark #15388: vectorization support: reference aux2[i] has aligned access   [ src/milosUtils.c(349,3) ]
   remark #15388: vectorization support: reference aux2[i] has aligned access   [ src/milosUtils.c(349,12) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 5
   remark #15309: vectorization support: normalized vectorization overhead 0.016
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 52 
   remark #15477: vector cost: 25.000 
   remark #15478: estimated potential speedup: 1.860 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/milosUtils.c(347,2) inlined into src/milosUtils.c(658,3)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

LOOP BEGIN at src/lib.c(179,3) inlined into src/milosUtils.c(658,3)
   remark #15388: vectorization support: reference delta[i] has aligned access   [ src/milosUtils.c(658,25) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <v[i*11+k]>, stride is 11   [ src/lib.c(184,13) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.429
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15452: unmasked strided loads: 11 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 101 
   remark #15477: vector cost: 52.500 
   remark #15478: estimated potential speedup: 1.650 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=5

   LOOP BEGIN at src/lib.c(182,5) inlined into src/milosUtils.c(658,3)
      remark #25436: completely unrolled by 11   (pre-vector) 
   LOOP END
LOOP END

LOOP BEGIN at src/lib.c(179,3) inlined into src/milosUtils.c(658,3)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

LOOP BEGIN at src/lib.c(69,2) inlined into src/milosUtils.c(664,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/lib.c(71,3) inlined into src/milosUtils.c(664,12)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/lib.c(71,3) inlined into src/milosUtils.c(664,12)
      remark #15388: vectorization support: reference spectra[i+nspectro*j] has aligned access   [ src/lib.c(72,8) ]
      remark #15388: vectorization support: reference spectro[i+nspectro*j] has aligned access   [ src/lib.c(72,30) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.958
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 3.660 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/lib.c(71,3) inlined into src/milosUtils.c(664,12)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/lib.c(71,3) inlined into src/milosUtils.c(664,12)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/milosUtils.c(301,2) inlined into src/milosUtils.c(680,4)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/milosUtils.c(303,4) inlined into src/milosUtils.c(680,4)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/milosUtils.c(304,5) inlined into src/milosUtils.c(680,4)
         remark #25408: memset generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at src/milosUtils.c(304,5) inlined into src/milosUtils.c(680,4)
            remark #15389: vectorization support: reference d_spectra[i+nlambda*In+(j*nlambda)*11] has unaligned access   [ src/milosUtils.c(305,6) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.250
            remark #15300: LOOP WAS VECTORIZED
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.460 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at src/milosUtils.c(304,5) inlined into src/milosUtils.c(680,4)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=24
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/milosUtils.c(683,4)
   remark #15388: vectorization support: reference betad[i] has aligned access   [ src/milosUtils.c(684,5) ]
   remark #15388: vectorization support: reference beta[i] has aligned access   [ src/milosUtils.c(684,16) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 5
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(684,5) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 2.190 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/milosUtils.c(683,4)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

LOOP BEGIN at src/milosUtils.c(686,4)
   remark #15388: vectorization support: reference covar[i] has aligned access   [ src/milosUtils.c(687,5) ]
   remark #15388: vectorization support: reference alpha[i] has aligned access   [ src/milosUtils.c(687,16) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(687,5) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 2.460 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=15
LOOP END

LOOP BEGIN at src/milosUtils.c(686,4)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END


Non-optimizable loops:


LOOP BEGIN at src/milosUtils.c(704,19)
   remark #15533: loop was not vectorized: loop exceeds complexity limits. Consider overriding limits (-override-limits) or using simd directive.
LOOP END

    Report from: Code generation optimizations [cg]

src/lib.c(184,13):remark #34069: adjacent sparse (strided) loads seem unprofitable to optimize. Details: stride { 88 }, types { F64-V128, F64-V128, F64-V128, F64-V128, F64-V128, F64-V128, F64-V128, F64-V128, F64-V128, F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x0000007FF }.
src/milosUtils.c(304,5):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/milosUtils.c(304,5):remark #34026: call to memset implemented as a call to optimized library version
src/milosUtils.c(333,2):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (32, 0), and destination (alignment, offset): (32, 0)
src/milosUtils.c(304,5):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/milosUtils.c(304,5):remark #34026: call to memset implemented as a call to optimized library version
src/milosUtils.c(579,1):remark #34051: REGISTER ALLOCATION : [lm_mils] src/milosUtils.c:579

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     724
            Global    :     207
            Local     :     517
        Regenerable   :      76
        Spilled       :      73
        
    Routine stack
        Variables     :     136 bytes*
            Reads     :      22 [1.66e+01 ~ 0.1%]
            Writes    :      25 [3.20e+01 ~ 0.2%]
        Spills        :     680 bytes*
            Reads     :     120 [9.84e+02 ~ 6.8%]
            Writes    :      82 [2.09e+02 ~ 1.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: me_der(Cuantic *, Init_Model *, double *, double *, int, float *, float *, float *, double, double *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (me_der(Cuantic *, Init_Model *, double *, double *, int, float *, float *, float *, double, double *, int)) [3/70=4.3%] src/me_der.c(67,1)
  -> (98,2) Resetear_Valores_Intermedios(int) (isz = 70) (sz = 75)
     [[ Callee not marked with inlining pragma  <1>]]
  -> (113,3) funcionComponentFor(int, double, int, float *, float *, float *, float *, double, double, int) (isz = 412) (sz = 437)
     [[ Inlining would exceed -inline-max-size value (437>230) <3>]]
  -> (116,3) funcionComponentFor(int, double, int, float *, float *, float *, float *, double, double, int) (isz = 412) (sz = 437)
     [[ Inlining would exceed -inline-max-size value (437>230) <3>]]
  -> (119,3) funcionComponentFor(int, double, int, float *, float *, float *, float *, double, double, int) (isz = 412) (sz = 437)
     [[ Inlining would exceed -inline-max-size value (437>230) <3>]]
  -> INLINE: (360,3) fgauss(double, double *, int, double, int) (isz = 128) (sz = 143)
    -> EXTERN: src/fgauss.c:(21,12) _vla_alloc(long)
    -> EXTERN: src/fgauss.c:(78,14) exp(double)
    -> EXTERN: src/fgauss.c:(105,2) _vla_free(void *, long)
  -> EXTERN: (371,5) fftw_execute(const fftw_plan)
  -> EXTERN: (372,5) fftw_execute(const fftw_plan)
  -> EXTERN: (377,5) fftw_execute(const fftw_plan)
  -> EXTERN: (378,5) fftw_execute(const fftw_plan)
  -> EXTERN: (394,4) fftw_execute(const fftw_plan)
  -> EXTERN: (395,4) fftw_execute(const fftw_plan)
  -> EXTERN: (402,5) fftw_execute(const fftw_plan)
  -> EXTERN: (406,5) fftw_execute(const fftw_plan)
  -> EXTERN: (409,46) creal(double __complex__)
  -> EXTERN: (412,46) creal(double __complex__)
  -> EXTERN: (424,7) fftw_execute(const fftw_plan)
  -> EXTERN: (428,7) fftw_execute(const fftw_plan)
  -> EXTERN: (432,50) creal(double __complex__)
  -> EXTERN: (435,50) creal(double __complex__)
  -> INLINE: (449,5) direct_convolution_double(double *, int, double *, int) (isz = 69) (sz = 80)
  -> INLINE: (450,5) direct_convolution_double(double *, int, double *, int) (isz = 69) (sz = 80)
  -> INLINE: (460,5) convCircular(float *, double *, int, float *) (isz = 65) (sz = 76)
  -> INLINE: (494,5) convCircular(float *, double *, int, float *) (isz = 65) (sz = 76)
  -> INLINE: (502,7) convCircular(float *, double *, int, float *) (isz = 65) (sz = 76)
  -> EXTERN: (547,7) fftw_execute(const fftw_plan)
  -> EXTERN: (551,7) fftw_execute(const fftw_plan)
  -> EXTERN: (554,56) creal(double __complex__)
  -> EXTERN: (557,55) creal(double __complex__)
  -> INLINE: (581,6) direct_convolution(float *, int, double *, int) (isz = 71) (sz = 82)
  -> INLINE: (593,7) direct_convolution(float *, int, double *, int) (isz = 71) (sz = 82)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/me_der.c(101,5)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/me_der.c(121,3)
      remark #25045: Fused Loops: ( 121 124 127 )

      remark #15389: vectorization support: reference d_ei[i] has unaligned access   [ src/me_der.c(122,4) ]
      remark #15389: vectorization support: reference d_ei[i] has unaligned access   [ src/me_der.c(122,12) ]
      remark #15389: vectorization support: reference etain[i] has unaligned access   [ src/me_der.c(122,20) ]
      remark #15389: vectorization support: reference d_eq[i] has unaligned access   [ src/me_der.c(125,4) ]
      remark #15389: vectorization support: reference d_eq[i] has unaligned access   [ src/me_der.c(125,12) ]
      remark #15389: vectorization support: reference etaqn[i] has unaligned access   [ src/me_der.c(125,20) ]
      remark #15389: vectorization support: reference d_eu[i] has unaligned access   [ src/me_der.c(128,4) ]
      remark #15389: vectorization support: reference d_eu[i] has unaligned access   [ src/me_der.c(128,12) ]
      remark #15389: vectorization support: reference etaun[i] has unaligned access   [ src/me_der.c(128,20) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.268
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(122,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(122,4) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(125,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(125,4) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(128,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(128,4) ]
      remark #15301: FUSED LOOP WAS VECTORIZED
      remark #15450: unmasked unaligned unit stride loads: 6 
      remark #15451: unmasked unaligned unit stride stores: 3 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 111 
      remark #15477: vector cost: 61.500 
      remark #15478: estimated potential speedup: 1.800 
      remark #15486: divides: 3 
      remark #15487: type converts: 9 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(124,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(127,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(121,3)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/me_der.c(130,3)
      remark #25045: Fused Loops: ( 130 133 136 )

      remark #15389: vectorization support: reference d_ev[i] has unaligned access   [ src/me_der.c(131,4) ]
      remark #15389: vectorization support: reference d_ev[i] has unaligned access   [ src/me_der.c(131,12) ]
      remark #15389: vectorization support: reference etavn[i] has unaligned access   [ src/me_der.c(131,20) ]
      remark #15389: vectorization support: reference d_rq[i] has unaligned access   [ src/me_der.c(134,4) ]
      remark #15389: vectorization support: reference d_rq[i] has unaligned access   [ src/me_der.c(134,12) ]
      remark #15389: vectorization support: reference rhoqn[i] has unaligned access   [ src/me_der.c(134,20) ]
      remark #15389: vectorization support: reference d_ru[i] has unaligned access   [ src/me_der.c(137,4) ]
      remark #15389: vectorization support: reference d_ru[i] has unaligned access   [ src/me_der.c(137,12) ]
      remark #15389: vectorization support: reference rhoun[i] has unaligned access   [ src/me_der.c(137,20) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.268
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(131,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(131,4) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(134,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(134,4) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(137,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(137,4) ]
      remark #15301: FUSED LOOP WAS VECTORIZED
      remark #15450: unmasked unaligned unit stride loads: 6 
      remark #15451: unmasked unaligned unit stride stores: 3 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 111 
      remark #15477: vector cost: 61.500 
      remark #15478: estimated potential speedup: 1.800 
      remark #15486: divides: 3 
      remark #15487: type converts: 9 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(133,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(136,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(130,3)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/me_der.c(139,3)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(139,3)
      remark #25045: Fused Loops: ( 139 160 )

      remark #15389: vectorization support: reference d_rv[i] has unaligned access   [ src/me_der.c(140,4) ]
      remark #15389: vectorization support: reference d_rv[i] has unaligned access   [ src/me_der.c(140,12) ]
      remark #15389: vectorization support: reference rhovn[i] has unaligned access   [ src/me_der.c(140,20) ]
      remark #15389: vectorization support: reference dfi[i+(j-1)*nlambda+nlambda*4] has unaligned access   [ src/me_der.c(162,13) ]
      remark #15389: vectorization support: reference dfi[i+(j-1)*nlambda+nlambda*8] has unaligned access   [ src/me_der.c(162,43) ]
      remark #15389: vectorization support: reference d_ei[j*nlambda+i] has unaligned access   [ src/me_der.c(164,5) ]
      remark #15389: vectorization support: reference d_ei[j*nlambda+i] has unaligned access   [ src/me_der.c(164,22) ]
      remark #15389: vectorization support: reference dfi[i+(j-1)*nlambda] has unaligned access   [ src/me_der.c(164,40) ]
      remark #15389: vectorization support: reference dfi[(j-1)*nlambda+i] has unaligned access   [ src/me_der.c(166,9) ]
      remark #15389: vectorization support: reference d_eq[j*nlambda+i] has unaligned access   [ src/me_der.c(167,5) ]
      remark #15389: vectorization support: reference d_eq[j*nlambda+i] has unaligned access   [ src/me_der.c(167,20) ]
      remark #15389: vectorization support: reference d_eu[j*nlambda+i] has unaligned access   [ src/me_der.c(168,5) ]
      remark #15389: vectorization support: reference d_eu[j*nlambda+i] has unaligned access   [ src/me_der.c(168,20) ]
      remark #15389: vectorization support: reference d_ev[j*nlambda+i] has unaligned access   [ src/me_der.c(171,5) ]
      remark #15389: vectorization support: reference d_ev[j*nlambda+i] has unaligned access   [ src/me_der.c(171,21) ]
      remark #15389: vectorization support: reference dfi[(j-1)*nlambda+i+nlambda*8] has unaligned access   [ src/me_der.c(171,38) ]
      remark #15389: vectorization support: reference dfi[(j-1)*nlambda+i+nlambda*4] has unaligned access   [ src/me_der.c(171,67) ]
      remark #15389: vectorization support: reference dfi[i+(j-1)*nlambda+nlambda*4] has unaligned access   [ src/me_der.c(162,13) ]
      remark #15389: vectorization support: reference dfi[i+(j-1)*nlambda+nlambda*8] has unaligned access   [ src/me_der.c(162,43) ]
      remark #15389: vectorization support: reference d_ei[j*nlambda+i] has unaligned access   [ src/me_der.c(164,5) ]
      remark #15389: vectorization support: reference d_ei[j*nlambda+i] has unaligned access   [ src/me_der.c(164,22) ]
      remark #15389: vectorization support: reference dfi[i+(j-1)*nlambda] has unaligned access   [ src/me_der.c(164,40) ]
      remark #15389: vectorization support: reference dfi[(j-1)*nlambda+i] has unaligned access   [ src/me_der.c(166,9) ]
      remark #15389: vectorization support: reference d_eq[j*nlambda+i] has unaligned access   [ src/me_der.c(167,5) ]
      remark #15389: vectorization support: reference d_eq[j*nlambda+i] has unaligned access   [ src/me_der.c(167,20) ]
      remark #15389: vectorization support: reference d_eu[j*nlambda+i] has unaligned access   [ src/me_der.c(168,5) ]
      remark #15389: vectorization support: reference d_eu[j*nlambda+i] has unaligned access   [ src/me_der.c(168,20) ]
      remark #15389: vectorization support: reference d_ev[j*nlambda+i] has unaligned access   [ src/me_der.c(171,5) ]
      remark #15389: vectorization support: reference d_ev[j*nlambda+i] has unaligned access   [ src/me_der.c(171,21) ]
      remark #15389: vectorization support: reference dfi[(j-1)*nlambda+i+nlambda*8] has unaligned access   [ src/me_der.c(171,38) ]
      remark #15389: vectorization support: reference dfi[(j-1)*nlambda+i+nlambda*4] has unaligned access   [ src/me_der.c(171,67) ]
      remark #15389: vectorization support: reference dfi[i+(j-1)*nlambda+nlambda*4] has unaligned access   [ src/me_der.c(162,13) ]
      remark #15389: vectorization support: reference dfi[i+(j-1)*nlambda+nlambda*8] has unaligned access   [ src/me_der.c(162,43) ]
      remark #15389: vectorization support: reference d_ei[j*nlambda+i] has unaligned access   [ src/me_der.c(164,5) ]
      remark #15389: vectorization support: reference d_ei[j*nlambda+i] has unaligned access   [ src/me_der.c(164,22) ]
      remark #15389: vectorization support: reference dfi[i+(j-1)*nlambda] has unaligned access   [ src/me_der.c(164,40) ]
      remark #15389: vectorization support: reference dfi[(j-1)*nlambda+i] has unaligned access   [ src/me_der.c(166,9) ]
      remark #15389: vectorization support: reference d_eq[j*nlambda+i] has unaligned access   [ src/me_der.c(167,5) ]
      remark #15389: vectorization support: reference d_eq[j*nlambda+i] has unaligned access   [ src/me_der.c(167,20) ]
      remark #15389: vectorization support: reference d_eu[j*nlambda+i] has unaligned access   [ src/me_der.c(168,5) ]
      remark #15389: vectorization support: reference d_eu[j*nlambda+i] has unaligned access   [ src/me_der.c(168,20) ]
      remark #15389: vectorization support: reference d_ev[j*nlambda+i] has unaligned access   [ src/me_der.c(171,5) ]
      remark #15389: vectorization support: reference d_ev[j*nlambda+i] has unaligned access   [ src/me_der.c(171,21) ]
      remark #15389: vectorization support: reference dfi[(j-1)*nlambda+i+nlambda*8] has unaligned access   [ src/me_der.c(171,38) ]
      remark #15389: vectorization support: reference dfi[(j-1)*nlambda+i+nlambda*4] has unaligned access   [ src/me_der.c(171,67) ]
      remark #15388: vectorization support: reference dfi[i+(j-1)*nlambda+nlambda*4] has aligned access   [ src/me_der.c(162,13) ]
      remark #15388: vectorization support: reference dfi[i+(j-1)*nlambda+nlambda*8] has aligned access   [ src/me_der.c(162,43) ]
      remark #15389: vectorization support: reference d_ei[j*nlambda+i] has unaligned access   [ src/me_der.c(164,5) ]
      remark #15389: vectorization support: reference d_ei[j*nlambda+i] has unaligned access   [ src/me_der.c(164,22) ]
      remark #15388: vectorization support: reference dfi[i+(j-1)*nlambda] has aligned access   [ src/me_der.c(164,40) ]
      remark #15388: vectorization support: reference dfi[(j-1)*nlambda+i] has aligned access   [ src/me_der.c(166,9) ]
      remark #15389: vectorization support: reference d_eq[j*nlambda+i] has unaligned access   [ src/me_der.c(167,5) ]
      remark #15389: vectorization support: reference d_eq[j*nlambda+i] has unaligned access   [ src/me_der.c(167,20) ]
      remark #15389: vectorization support: reference d_eu[j*nlambda+i] has unaligned access   [ src/me_der.c(168,5) ]
      remark #15389: vectorization support: reference d_eu[j*nlambda+i] has unaligned access   [ src/me_der.c(168,20) ]
      remark #15389: vectorization support: reference d_ev[j*nlambda+i] has unaligned access   [ src/me_der.c(171,5) ]
      remark #15389: vectorization support: reference d_ev[j*nlambda+i] has unaligned access   [ src/me_der.c(171,21) ]
      remark #15388: vectorization support: reference dfi[(j-1)*nlambda+i+nlambda*8] has aligned access   [ src/me_der.c(171,38) ]
      remark #15388: vectorization support: reference dfi[(j-1)*nlambda+i+nlambda*4] has aligned access   [ src/me_der.c(171,67) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.573
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(140,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(140,4) ]
      remark #15301: FUSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 5 
      remark #15450: unmasked unaligned unit stride loads: 33 
      remark #15451: unmasked unaligned unit stride stores: 17 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 262 
      remark #15477: vector cost: 104.750 
      remark #15478: estimated potential speedup: 2.430 
      remark #15486: divides: 1 
      remark #15487: type converts: 3 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(160,4)
      remark #25461: Imperfect Loop Unroll-Jammed by 4   (pre-vector) 
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(139,3)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/me_der.c(175,4)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(175,4)
      remark #25461: Imperfect Loop Unroll-Jammed by 4   (pre-vector) 
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i] has unaligned access   [ src/me_der.c(176,14) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*4] has unaligned access   [ src/me_der.c(176,34) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*8] has unaligned access   [ src/me_der.c(176,62) ]
      remark #15389: vectorization support: reference d_rq[j*nlambda+i] has unaligned access   [ src/me_der.c(177,5) ]
      remark #15389: vectorization support: reference d_rq[j*nlambda+i] has unaligned access   [ src/me_der.c(177,20) ]
      remark #15389: vectorization support: reference d_ru[j*nlambda+i] has unaligned access   [ src/me_der.c(178,5) ]
      remark #15389: vectorization support: reference d_ru[j*nlambda+i] has unaligned access   [ src/me_der.c(178,20) ]
      remark #15389: vectorization support: reference d_rv[j*nlambda+i] has unaligned access   [ src/me_der.c(181,5) ]
      remark #15389: vectorization support: reference d_rv[j*nlambda+i] has unaligned access   [ src/me_der.c(181,20) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*8] has unaligned access   [ src/me_der.c(181,37) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*4] has unaligned access   [ src/me_der.c(181,67) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i] has unaligned access   [ src/me_der.c(176,14) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*4] has unaligned access   [ src/me_der.c(176,34) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*8] has unaligned access   [ src/me_der.c(176,62) ]
      remark #15389: vectorization support: reference d_rq[j*nlambda+i] has unaligned access   [ src/me_der.c(177,5) ]
      remark #15389: vectorization support: reference d_rq[j*nlambda+i] has unaligned access   [ src/me_der.c(177,20) ]
      remark #15389: vectorization support: reference d_ru[j*nlambda+i] has unaligned access   [ src/me_der.c(178,5) ]
      remark #15389: vectorization support: reference d_ru[j*nlambda+i] has unaligned access   [ src/me_der.c(178,20) ]
      remark #15389: vectorization support: reference d_rv[j*nlambda+i] has unaligned access   [ src/me_der.c(181,5) ]
      remark #15389: vectorization support: reference d_rv[j*nlambda+i] has unaligned access   [ src/me_der.c(181,20) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*8] has unaligned access   [ src/me_der.c(181,37) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*4] has unaligned access   [ src/me_der.c(181,67) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i] has unaligned access   [ src/me_der.c(176,14) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*4] has unaligned access   [ src/me_der.c(176,34) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*8] has unaligned access   [ src/me_der.c(176,62) ]
      remark #15389: vectorization support: reference d_rq[j*nlambda+i] has unaligned access   [ src/me_der.c(177,5) ]
      remark #15389: vectorization support: reference d_rq[j*nlambda+i] has unaligned access   [ src/me_der.c(177,20) ]
      remark #15389: vectorization support: reference d_ru[j*nlambda+i] has unaligned access   [ src/me_der.c(178,5) ]
      remark #15389: vectorization support: reference d_ru[j*nlambda+i] has unaligned access   [ src/me_der.c(178,20) ]
      remark #15389: vectorization support: reference d_rv[j*nlambda+i] has unaligned access   [ src/me_der.c(181,5) ]
      remark #15389: vectorization support: reference d_rv[j*nlambda+i] has unaligned access   [ src/me_der.c(181,20) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*8] has unaligned access   [ src/me_der.c(181,37) ]
      remark #15389: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*4] has unaligned access   [ src/me_der.c(181,67) ]
      remark #15388: vectorization support: reference dshi[(j-1)*nlambda+i] has aligned access   [ src/me_der.c(176,14) ]
      remark #15388: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*4] has aligned access   [ src/me_der.c(176,34) ]
      remark #15388: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*8] has aligned access   [ src/me_der.c(176,62) ]
      remark #15389: vectorization support: reference d_rq[j*nlambda+i] has unaligned access   [ src/me_der.c(177,5) ]
      remark #15389: vectorization support: reference d_rq[j*nlambda+i] has unaligned access   [ src/me_der.c(177,20) ]
      remark #15389: vectorization support: reference d_ru[j*nlambda+i] has unaligned access   [ src/me_der.c(178,5) ]
      remark #15389: vectorization support: reference d_ru[j*nlambda+i] has unaligned access   [ src/me_der.c(178,20) ]
      remark #15389: vectorization support: reference d_rv[j*nlambda+i] has unaligned access   [ src/me_der.c(181,5) ]
      remark #15389: vectorization support: reference d_rv[j*nlambda+i] has unaligned access   [ src/me_der.c(181,20) ]
      remark #15388: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*8] has aligned access   [ src/me_der.c(181,37) ]
      remark #15388: vectorization support: reference dshi[(j-1)*nlambda+i+nlambda*4] has aligned access   [ src/me_der.c(181,67) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.653
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(176,93) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(176,93) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(176,93) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(176,93) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(176,93) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(176,93) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(176,93) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(176,93) ]
      remark #15301: FUSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 5 
      remark #15450: unmasked unaligned unit stride loads: 27 
      remark #15451: unmasked unaligned unit stride stores: 12 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 176 
      remark #15477: vector cost: 65.500 
      remark #15478: estimated potential speedup: 2.600 
      remark #15487: type converts: 12 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(175,4)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/me_der.c(189,3)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(189,3)
      remark #25045: Fused Loops: ( 189 191 193 195 )

      remark #15389: vectorization support: reference d_ei[nlambda*5+i] has unaligned access   [ src/me_der.c(190,4) ]
      remark #15389: vectorization support: reference d_ei[nlambda*5+i] has unaligned access   [ src/me_der.c(190,19) ]
      remark #15389: vectorization support: reference fi_p[i] has unaligned access   [ src/me_der.c(190,34) ]
      remark #15389: vectorization support: reference parcial1[i] has unaligned access   [ src/me_der.c(190,54) ]
      remark #15389: vectorization support: reference d_eq[nlambda*5+i] has unaligned access   [ src/me_der.c(192,4) ]
      remark #15389: vectorization support: reference d_eq[nlambda*5+i] has unaligned access   [ src/me_der.c(192,19) ]
      remark #15389: vectorization support: reference parcial2[i] has unaligned access   [ src/me_der.c(192,34) ]
      remark #15389: vectorization support: reference d_eu[nlambda*5+i] has unaligned access   [ src/me_der.c(194,4) ]
      remark #15389: vectorization support: reference d_eu[nlambda*5+i] has unaligned access   [ src/me_der.c(194,19) ]
      remark #15389: vectorization support: reference parcial2[i] has unaligned access   [ src/me_der.c(194,34) ]
      remark #15388: vectorization support: reference d_ev[nlambda*5+i] has aligned access   [ src/me_der.c(196,4) ]
      remark #15388: vectorization support: reference d_ev[nlambda*5+i] has aligned access   [ src/me_der.c(196,19) ]
      remark #15389: vectorization support: reference fi_r[i] has unaligned access   [ src/me_der.c(196,35) ]
      remark #15389: vectorization support: reference fi_b[i] has unaligned access   [ src/me_der.c(196,43) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.983
      remark #15301: FUSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 8 
      remark #15451: unmasked unaligned unit stride stores: 3 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 46 
      remark #15477: vector cost: 14.750 
      remark #15478: estimated potential speedup: 2.990 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(191,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(193,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(195,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(189,3)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/me_der.c(199,3)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(199,3)
      remark #25045: Fused Loops: ( 199 201 203 211 215 218 221 )

      remark #15389: vectorization support: reference d_rq[nlambda*5+i] has unaligned access   [ src/me_der.c(200,4) ]
      remark #15389: vectorization support: reference d_rq[nlambda*5+i] has unaligned access   [ src/me_der.c(200,19) ]
      remark #15388: vectorization support: reference parcial3[i] has aligned access   [ src/me_der.c(200,34) ]
      remark #15389: vectorization support: reference d_ru[nlambda*5+i] has unaligned access   [ src/me_der.c(202,4) ]
      remark #15389: vectorization support: reference d_ru[nlambda*5+i] has unaligned access   [ src/me_der.c(202,19) ]
      remark #15388: vectorization support: reference parcial3[i] has aligned access   [ src/me_der.c(202,34) ]
      remark #15389: vectorization support: reference d_rv[nlambda*5+i] has unaligned access   [ src/me_der.c(204,4) ]
      remark #15389: vectorization support: reference d_rv[nlambda*5+i] has unaligned access   [ src/me_der.c(204,19) ]
      remark #15389: vectorization support: reference shi_r[i] has unaligned access   [ src/me_der.c(204,35) ]
      remark #15389: vectorization support: reference shi_b[i] has unaligned access   [ src/me_der.c(204,44) ]
      remark #15389: vectorization support: reference d_eq[nlambda*6+i] has unaligned access   [ src/me_der.c(212,4) ]
      remark #15389: vectorization support: reference d_eq[nlambda*6+i] has unaligned access   [ src/me_der.c(212,19) ]
      remark #15389: vectorization support: reference parcial2[i] has unaligned access   [ src/me_der.c(212,34) ]
      remark #15389: vectorization support: reference d_eu[nlambda*6+i] has unaligned access   [ src/me_der.c(216,4) ]
      remark #15389: vectorization support: reference d_eu[nlambda*6+i] has unaligned access   [ src/me_der.c(216,19) ]
      remark #15389: vectorization support: reference parcial2[i] has unaligned access   [ src/me_der.c(216,34) ]
      remark #15389: vectorization support: reference d_rq[nlambda*6+i] has unaligned access   [ src/me_der.c(219,4) ]
      remark #15389: vectorization support: reference d_rq[nlambda*6+i] has unaligned access   [ src/me_der.c(219,19) ]
      remark #15388: vectorization support: reference parcial3[i] has aligned access   [ src/me_der.c(219,34) ]
      remark #15389: vectorization support: reference d_ru[nlambda*6+i] has unaligned access   [ src/me_der.c(222,4) ]
      remark #15389: vectorization support: reference d_ru[nlambda*6+i] has unaligned access   [ src/me_der.c(222,19) ]
      remark #15388: vectorization support: reference parcial3[i] has aligned access   [ src/me_der.c(222,34) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.891
      remark #15301: FUSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15450: unmasked unaligned unit stride loads: 10 
      remark #15451: unmasked unaligned unit stride stores: 7 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 70 
      remark #15477: vector cost: 23.000 
      remark #15478: estimated potential speedup: 2.920 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(201,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(203,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(211,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(215,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(218,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(221,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(199,3)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(235,4)
   remark #25045: Fused Loops: ( 235 238 )

   remark #15389: vectorization support: reference dtaux[i] has unaligned access   [ src/me_der.c(236,3) ]
   remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(236,18) ]
   remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(236,24) ]
   remark #15389: vectorization support: reference etai_gp3[i] has unaligned access   [ src/me_der.c(239,3) ]
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/me_der.c(239,15) ]
   remark #15389: vectorization support: reference gp3[i] has unaligned access   [ src/me_der.c(239,23) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.109
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(236,3) ]
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(236,3) ]
   remark #15301: FUSED LOOP WAS VECTORIZED
   remark #15450: unmasked unaligned unit stride loads: 4 
   remark #15451: unmasked unaligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 44 
   remark #15477: vector cost: 23.000 
   remark #15478: estimated potential speedup: 1.880 
   remark #15486: divides: 1 
   remark #15487: type converts: 2 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(238,4)
   remark #25046: Loop lost in Fusion 
LOOP END

LOOP BEGIN at src/me_der.c(235,4)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference dtaux[i] has unaligned access   [ src/me_der.c(236,3) ]
   remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(236,18) ]
   remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(236,24) ]
   remark #15389: vectorization support: reference etai_gp3[i] has unaligned access   [ src/me_der.c(239,3) ]
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/me_der.c(239,15) ]
   remark #15389: vectorization support: reference gp3[i] has unaligned access   [ src/me_der.c(239,23) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.652
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(236,3) ]
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(236,3) ]
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15450: unmasked unaligned unit stride loads: 7 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 67 
   remark #15477: vector cost: 18.750 
   remark #15478: estimated potential speedup: 3.420 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(235,4)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(242,4)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/me_der.c(242,4)
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/me_der.c(243,14) ]
   remark #15389: vectorization support: reference ext1[i] has unaligned access   [ src/me_der.c(244,3) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/me_der.c(244,15) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/me_der.c(244,23) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/me_der.c(244,31) ]
   remark #15388: vectorization support: reference etau[i] has aligned access   [ src/me_der.c(244,39) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/me_der.c(244,47) ]
   remark #15389: vectorization support: reference ext2[i] has unaligned access   [ src/me_der.c(245,3) ]
   remark #15388: vectorization support: reference etau[i] has aligned access   [ src/me_der.c(245,15) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/me_der.c(245,23) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/me_der.c(245,31) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/me_der.c(245,39) ]
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/me_der.c(245,47) ]
   remark #15389: vectorization support: reference ext3[i] has unaligned access   [ src/me_der.c(246,3) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/me_der.c(246,15) ]
   remark #15388: vectorization support: reference etau[i] has aligned access   [ src/me_der.c(246,23) ]
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/me_der.c(246,31) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/me_der.c(246,39) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/me_der.c(246,47) ]
   remark #15389: vectorization support: reference ext4[i] has unaligned access   [ src/me_der.c(247,3) ]
   remark #15389: vectorization support: reference gp1[i] has unaligned access   [ src/me_der.c(247,15) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.627
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15450: unmasked unaligned unit stride loads: 7 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 67 
   remark #15477: vector cost: 18.750 
   remark #15478: estimated potential speedup: 3.420 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(242,4)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(252,5)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/me_der.c(255,6)
   <Peeled loop for vectorization, Distributed chunk1>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(255,6)
   <Distributed chunk1>
      remark #25045: Fused Loops: ( 255 260 265 269 273 )

      remark #25426: Loop Distributed (2 way) 
      remark #15389: vectorization support: reference dgp3[i] has unaligned access   [ src/me_der.c(270,7) ]
      remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/me_der.c(270,20) ]
      remark #15389: vectorization support: reference d_ei[i+nlambda*il] has unaligned access   [ src/me_der.c(270,28) ]
      remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/me_der.c(270,44) ]
      remark #15389: vectorization support: reference d_rq[i+nlambda*il] has unaligned access   [ src/me_der.c(270,52) ]
      remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/me_der.c(270,68) ]
      remark #15389: vectorization support: reference d_ru[i+nlambda*il] has unaligned access   [ src/me_der.c(270,76) ]
      remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/me_der.c(270,92) ]
      remark #15388: vectorization support: reference d_rv[i+nlambda*il] has aligned access   [ src/me_der.c(270,100) ]
      remark #15389: vectorization support: reference dgp2[i] has unaligned access   [ src/me_der.c(261,7) ]
      remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/me_der.c(261,15) ]
      remark #15389: vectorization support: reference d_eq[i+nlambda*il] has unaligned access   [ src/me_der.c(261,23) ]
      remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/me_der.c(261,39) ]
      remark #15389: vectorization support: reference d_rq[i+nlambda*il] has unaligned access   [ src/me_der.c(261,47) ]
      remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/me_der.c(261,63) ]
      remark #15389: vectorization support: reference d_eu[i+nlambda*il] has unaligned access   [ src/me_der.c(261,71) ]
      remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/me_der.c(261,87) ]
      remark #15389: vectorization support: reference d_ru[i+nlambda*il] has unaligned access   [ src/me_der.c(261,95) ]
      remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/me_der.c(262,27) ]
      remark #15389: vectorization support: reference d_ev[i+nlambda*il] has unaligned access   [ src/me_der.c(262,35) ]
      remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/me_der.c(262,51) ]
      remark #15388: vectorization support: reference d_rv[i+nlambda*il] has aligned access   [ src/me_der.c(262,59) ]
      remark #15389: vectorization support: reference dgp1[i] has unaligned access   [ src/me_der.c(256,7) ]
      remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/me_der.c(256,20) ]
      remark #15389: vectorization support: reference d_ei[i+nlambda*il] has unaligned access   [ src/me_der.c(256,28) ]
      remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/me_der.c(256,44) ]
      remark #15389: vectorization support: reference d_eq[i+nlambda*il] has unaligned access   [ src/me_der.c(256,52) ]
      remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/me_der.c(256,68) ]
      remark #15389: vectorization support: reference d_eu[i+nlambda*il] has unaligned access   [ src/me_der.c(256,76) ]
      remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/me_der.c(256,92) ]
      remark #15389: vectorization support: reference d_ev[i+nlambda*il] has unaligned access   [ src/me_der.c(256,100) ]
      remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/me_der.c(257,7) ]
      remark #15389: vectorization support: reference d_rq[i+nlambda*il] has unaligned access   [ src/me_der.c(257,15) ]
      remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/me_der.c(257,31) ]
      remark #15389: vectorization support: reference d_ru[i+nlambda*il] has unaligned access   [ src/me_der.c(257,39) ]
      remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/me_der.c(257,55) ]
      remark #15388: vectorization support: reference d_rv[i+nlambda*il] has aligned access   [ src/me_der.c(257,63) ]
      remark #15389: vectorization support: reference d_dt[i] has unaligned access   [ src/me_der.c(266,7) ]
      remark #15389: vectorization support: reference ext4[i] has unaligned access   [ src/me_der.c(266,15) ]
      remark #15389: vectorization support: reference d_ei[i+nlambda*il] has unaligned access   [ src/me_der.c(266,23) ]
      remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/me_der.c(266,39) ]
      remark #15389: vectorization support: reference dgp1[i] has unaligned access   [ src/me_der.c(266,49) ]
      remark #15389: vectorization support: reference gp2[i] has unaligned access   [ src/me_der.c(266,59) ]
      remark #15389: vectorization support: reference dgp2[i] has unaligned access   [ src/me_der.c(266,66) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.551
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15450: unmasked unaligned unit stride loads: 18 
      remark #15451: unmasked unaligned unit stride stores: 4 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 132 
      remark #15477: vector cost: 34.500 
      remark #15478: estimated potential speedup: 3.660 
      remark #15488: --- end vector cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   LOOP END

   LOOP BEGIN at src/me_der.c(260,6)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(265,6)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(269,6)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(273,6)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(255,6)
   <Remainder loop for vectorization, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/me_der.c(255,6)
   <Peeled loop for vectorization, Distributed chunk2>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(255,6)
   <Distributed chunk2>
      remark #15388: vectorization support: reference d_spectra[i+nlambda*il] has aligned access   [ src/me_der.c(274,7) ]
      remark #15389: vectorization support: reference d_ei[i+nlambda*il] has unaligned access   [ src/me_der.c(274,32) ]
      remark #15389: vectorization support: reference gp3[i] has unaligned access   [ src/me_der.c(274,48) ]
      remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/me_der.c(274,55) ]
      remark #15389: vectorization support: reference dgp3[i] has unaligned access   [ src/me_der.c(274,63) ]
      remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(274,72) ]
      remark #15389: vectorization support: reference d_dt[i] has unaligned access   [ src/me_der.c(274,78) ]
      remark #15389: vectorization support: reference etai_gp3[i] has unaligned access   [ src/me_der.c(274,86) ]
      remark #15388: vectorization support: reference dtaux[i] has aligned access   [ src/me_der.c(274,100) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.547
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 7 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 27 
      remark #15477: vector cost: 8.000 
      remark #15478: estimated potential speedup: 3.220 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(255,6)
   <Alternate Alignment Vectorized Loop, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/me_der.c(255,6)
   <Remainder loop for vectorization, Distributed chunk2>
      remark #15388: vectorization support: reference d_spectra[i+nlambda*il] has aligned access   [ src/me_der.c(274,7) ]
      remark #15389: vectorization support: reference d_ei[i+nlambda*il] has unaligned access   [ src/me_der.c(274,32) ]
      remark #15389: vectorization support: reference gp3[i] has unaligned access   [ src/me_der.c(274,48) ]
      remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/me_der.c(274,55) ]
      remark #15389: vectorization support: reference dgp3[i] has unaligned access   [ src/me_der.c(274,63) ]
      remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(274,72) ]
      remark #15389: vectorization support: reference d_dt[i] has unaligned access   [ src/me_der.c(274,78) ]
      remark #15389: vectorization support: reference etai_gp3[i] has unaligned access   [ src/me_der.c(274,86) ]
      remark #15389: vectorization support: reference dtaux[i] has unaligned access   [ src/me_der.c(274,100) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 1.000
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 8 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 29 
      remark #15477: vector cost: 8.750 
      remark #15478: estimated potential speedup: 3.170 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(255,6)
   <Remainder loop for vectorization, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/me_der.c(277,6)
   <Peeled loop for vectorization, Distributed chunk1>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(277,6)
   <Distributed chunk1>
      remark #25045: Fused Loops: ( 277 282 )

      remark #25426: Loop Distributed (2 way) 
      remark #15388: vectorization support: reference dgp4[i] has aligned access   [ src/me_der.c(278,7) ]
      remark #15389: vectorization support: reference d_ei[i+nlambda*il] has unaligned access   [ src/me_der.c(278,15) ]
      remark #15389: vectorization support: reference ext1[i] has unaligned access   [ src/me_der.c(278,32) ]
      remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/me_der.c(278,42) ]
      remark #15389: vectorization support: reference d_eq[i+nlambda*il] has unaligned access   [ src/me_der.c(278,53) ]
      remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/me_der.c(279,7) ]
      remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/me_der.c(279,16) ]
      remark #15389: vectorization support: reference d_ev[i+nlambda*il] has unaligned access   [ src/me_der.c(279,24) ]
      remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/me_der.c(279,40) ]
      remark #15389: vectorization support: reference d_ru[i+nlambda*il] has unaligned access   [ src/me_der.c(279,48) ]
      remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/me_der.c(279,64) ]
      remark #15389: vectorization support: reference d_eu[i+nlambda*il] has unaligned access   [ src/me_der.c(279,72) ]
      remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/me_der.c(279,88) ]
      remark #15388: vectorization support: reference d_rv[i+nlambda*il] has aligned access   [ src/me_der.c(279,96) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.980
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 12 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 41 
      remark #15477: vector cost: 12.750 
      remark #15478: estimated potential speedup: 3.080 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(282,6)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(277,6)
   <Alternate Alignment Vectorized Loop, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/me_der.c(277,6)
   <Remainder loop for vectorization, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/me_der.c(277,6)
   <Peeled loop for vectorization, Distributed chunk2>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(277,6)
   <Distributed chunk2>
      remark #15388: vectorization support: reference d_spectra[i+nlambda*il+nlambda*11] has aligned access   [ src/me_der.c(283,7) ]
      remark #15389: vectorization support: reference dgp4[i] has unaligned access   [ src/me_der.c(283,42) ]
      remark #15389: vectorization support: reference d_rq[i+nlambda*il] has unaligned access   [ src/me_der.c(283,50) ]
      remark #15389: vectorization support: reference gp2[i] has unaligned access   [ src/me_der.c(283,66) ]
      remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/me_der.c(283,73) ]
      remark #15389: vectorization support: reference dgp2[i] has unaligned access   [ src/me_der.c(283,81) ]
      remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(283,90) ]
      remark #15389: vectorization support: reference d_dt[i] has unaligned access   [ src/me_der.c(284,9) ]
      remark #15389: vectorization support: reference gp4_gp2_rhoq[i] has unaligned access   [ src/me_der.c(284,18) ]
      remark #15388: vectorization support: reference dtaux[i] has aligned access   [ src/me_der.c(284,37) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.543
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 8 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 29 
      remark #15477: vector cost: 8.750 
      remark #15478: estimated potential speedup: 3.170 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(277,6)
   <Alternate Alignment Vectorized Loop, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/me_der.c(277,6)
   <Remainder loop for vectorization, Distributed chunk2>
      remark #15388: vectorization support: reference d_spectra[i+nlambda*il+nlambda*11] has aligned access   [ src/me_der.c(283,7) ]
      remark #15389: vectorization support: reference dgp4[i] has unaligned access   [ src/me_der.c(283,42) ]
      remark #15389: vectorization support: reference d_rq[i+nlambda*il] has unaligned access   [ src/me_der.c(283,50) ]
      remark #15389: vectorization support: reference gp2[i] has unaligned access   [ src/me_der.c(283,66) ]
      remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/me_der.c(283,73) ]
      remark #15389: vectorization support: reference dgp2[i] has unaligned access   [ src/me_der.c(283,81) ]
      remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(283,90) ]
      remark #15389: vectorization support: reference d_dt[i] has unaligned access   [ src/me_der.c(284,9) ]
      remark #15389: vectorization support: reference gp4_gp2_rhoq[i] has unaligned access   [ src/me_der.c(284,18) ]
      remark #15389: vectorization support: reference dtaux[i] has unaligned access   [ src/me_der.c(284,37) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 1.000
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 8 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 29 
      remark #15477: vector cost: 8.750 
      remark #15478: estimated potential speedup: 3.170 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(277,6)
   <Remainder loop for vectorization, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/me_der.c(287,6)
   <Peeled loop for vectorization, Distributed chunk1>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(287,6)
   <Distributed chunk1>
      remark #25045: Fused Loops: ( 287 292 )

      remark #25426: Loop Distributed (2 way) 
      remark #15388: vectorization support: reference dgp5[i] has aligned access   [ src/me_der.c(288,7) ]
      remark #15389: vectorization support: reference d_ei[i+nlambda*il] has unaligned access   [ src/me_der.c(288,15) ]
      remark #15389: vectorization support: reference ext2[i] has unaligned access   [ src/me_der.c(288,32) ]
      remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/me_der.c(288,42) ]
      remark #15389: vectorization support: reference d_eu[i+nlambda*il] has unaligned access   [ src/me_der.c(288,53) ]
      remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/me_der.c(289,7) ]
      remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/me_der.c(289,16) ]
      remark #15389: vectorization support: reference d_eq[i+nlambda*il] has unaligned access   [ src/me_der.c(289,24) ]
      remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/me_der.c(289,40) ]
      remark #15389: vectorization support: reference d_rv[i+nlambda*il] has unaligned access   [ src/me_der.c(289,48) ]
      remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/me_der.c(289,64) ]
      remark #15389: vectorization support: reference d_ev[i+nlambda*il] has unaligned access   [ src/me_der.c(289,72) ]
      remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/me_der.c(289,88) ]
      remark #15388: vectorization support: reference d_rq[i+nlambda*il] has aligned access   [ src/me_der.c(289,96) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.980
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 12 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 41 
      remark #15477: vector cost: 12.750 
      remark #15478: estimated potential speedup: 3.080 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(292,6)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(287,6)
   <Alternate Alignment Vectorized Loop, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/me_der.c(287,6)
   <Remainder loop for vectorization, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/me_der.c(287,6)
   <Peeled loop for vectorization, Distributed chunk2>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(287,6)
   <Distributed chunk2>
      remark #15388: vectorization support: reference d_spectra[i+nlambda*il+(nlambda*11)*2] has aligned access   [ src/me_der.c(293,7) ]
      remark #15389: vectorization support: reference dgp5[i] has unaligned access   [ src/me_der.c(293,46) ]
      remark #15389: vectorization support: reference d_ru[i+nlambda*il] has unaligned access   [ src/me_der.c(293,54) ]
      remark #15389: vectorization support: reference gp2[i] has unaligned access   [ src/me_der.c(293,70) ]
      remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/me_der.c(293,77) ]
      remark #15389: vectorization support: reference dgp2[i] has unaligned access   [ src/me_der.c(293,85) ]
      remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(293,94) ]
      remark #15389: vectorization support: reference d_dt[i] has unaligned access   [ src/me_der.c(294,9) ]
      remark #15389: vectorization support: reference gp5_gp2_rhou[i] has unaligned access   [ src/me_der.c(294,18) ]
      remark #15388: vectorization support: reference dtaux[i] has aligned access   [ src/me_der.c(294,37) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.543
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 8 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 29 
      remark #15477: vector cost: 8.750 
      remark #15478: estimated potential speedup: 3.170 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(287,6)
   <Alternate Alignment Vectorized Loop, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/me_der.c(287,6)
   <Remainder loop for vectorization, Distributed chunk2>
      remark #15388: vectorization support: reference d_spectra[i+nlambda*il+(nlambda*11)*2] has aligned access   [ src/me_der.c(293,7) ]
      remark #15389: vectorization support: reference dgp5[i] has unaligned access   [ src/me_der.c(293,46) ]
      remark #15389: vectorization support: reference d_ru[i+nlambda*il] has unaligned access   [ src/me_der.c(293,54) ]
      remark #15389: vectorization support: reference gp2[i] has unaligned access   [ src/me_der.c(293,70) ]
      remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/me_der.c(293,77) ]
      remark #15389: vectorization support: reference dgp2[i] has unaligned access   [ src/me_der.c(293,85) ]
      remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(293,94) ]
      remark #15389: vectorization support: reference d_dt[i] has unaligned access   [ src/me_der.c(294,9) ]
      remark #15389: vectorization support: reference gp5_gp2_rhou[i] has unaligned access   [ src/me_der.c(294,18) ]
      remark #15389: vectorization support: reference dtaux[i] has unaligned access   [ src/me_der.c(294,37) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 1.000
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 8 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 29 
      remark #15477: vector cost: 8.750 
      remark #15478: estimated potential speedup: 3.170 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(287,6)
   <Remainder loop for vectorization, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/me_der.c(297,6)
   <Peeled loop for vectorization, Distributed chunk1>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(297,6)
   <Distributed chunk1>
      remark #25045: Fused Loops: ( 297 302 )

      remark #25426: Loop Distributed (2 way) 
      remark #15388: vectorization support: reference dgp6[i] has aligned access   [ src/me_der.c(298,7) ]
      remark #15389: vectorization support: reference d_ei[i+nlambda*il] has unaligned access   [ src/me_der.c(298,15) ]
      remark #15389: vectorization support: reference ext3[i] has unaligned access   [ src/me_der.c(298,32) ]
      remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/me_der.c(298,42) ]
      remark #15389: vectorization support: reference d_ev[i+nlambda*il] has unaligned access   [ src/me_der.c(298,53) ]
      remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/me_der.c(299,7) ]
      remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/me_der.c(299,16) ]
      remark #15389: vectorization support: reference d_eu[i+nlambda*il] has unaligned access   [ src/me_der.c(299,24) ]
      remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/me_der.c(299,40) ]
      remark #15389: vectorization support: reference d_rq[i+nlambda*il] has unaligned access   [ src/me_der.c(299,48) ]
      remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/me_der.c(299,64) ]
      remark #15389: vectorization support: reference d_eq[i+nlambda*il] has unaligned access   [ src/me_der.c(299,72) ]
      remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/me_der.c(299,88) ]
      remark #15388: vectorization support: reference d_ru[i+nlambda*il] has aligned access   [ src/me_der.c(299,96) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.980
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 12 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 41 
      remark #15477: vector cost: 12.750 
      remark #15478: estimated potential speedup: 3.080 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(302,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(297,6)
   <Alternate Alignment Vectorized Loop, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/me_der.c(297,6)
   <Remainder loop for vectorization, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/me_der.c(297,6)
   <Peeled loop for vectorization, Distributed chunk2>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(297,6)
   <Distributed chunk2>
      remark #15388: vectorization support: reference d_spectra[i+nlambda*il+(nlambda*11)*3] has aligned access   [ src/me_der.c(303,7) ]
      remark #15389: vectorization support: reference dgp6[i] has unaligned access   [ src/me_der.c(303,46) ]
      remark #15389: vectorization support: reference d_rv[i+nlambda*il] has unaligned access   [ src/me_der.c(303,54) ]
      remark #15389: vectorization support: reference gp2[i] has unaligned access   [ src/me_der.c(303,70) ]
      remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/me_der.c(303,77) ]
      remark #15389: vectorization support: reference dgp2[i] has unaligned access   [ src/me_der.c(303,85) ]
      remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(303,94) ]
      remark #15389: vectorization support: reference d_dt[i] has unaligned access   [ src/me_der.c(304,9) ]
      remark #15389: vectorization support: reference gp6_gp2_rhov[i] has unaligned access   [ src/me_der.c(304,18) ]
      remark #15388: vectorization support: reference dtaux[i] has aligned access   [ src/me_der.c(304,37) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.543
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 8 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 29 
      remark #15477: vector cost: 8.750 
      remark #15478: estimated potential speedup: 3.170 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(297,6)
   <Alternate Alignment Vectorized Loop, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/me_der.c(297,6)
   <Remainder loop for vectorization, Distributed chunk2>
      remark #15388: vectorization support: reference d_spectra[i+nlambda*il+(nlambda*11)*3] has aligned access   [ src/me_der.c(303,7) ]
      remark #15389: vectorization support: reference dgp6[i] has unaligned access   [ src/me_der.c(303,46) ]
      remark #15389: vectorization support: reference d_rv[i+nlambda*il] has unaligned access   [ src/me_der.c(303,54) ]
      remark #15389: vectorization support: reference gp2[i] has unaligned access   [ src/me_der.c(303,70) ]
      remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/me_der.c(303,77) ]
      remark #15389: vectorization support: reference dgp2[i] has unaligned access   [ src/me_der.c(303,85) ]
      remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/me_der.c(303,94) ]
      remark #15389: vectorization support: reference d_dt[i] has unaligned access   [ src/me_der.c(304,9) ]
      remark #15389: vectorization support: reference gp6_gp2_rhov[i] has unaligned access   [ src/me_der.c(304,18) ]
      remark #15389: vectorization support: reference dtaux[i] has unaligned access   [ src/me_der.c(304,37) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 1.000
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 8 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 29 
      remark #15477: vector cost: 8.750 
      remark #15478: estimated potential speedup: 3.170 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(297,6)
   <Remainder loop for vectorization, Distributed chunk2>
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(312,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/me_der.c(312,5)
   remark #15388: vectorization support: reference dti[i] has aligned access   [ src/me_der.c(313,3) ]
   remark #15388: vectorization support: reference dti[i] has aligned access   [ src/me_der.c(313,12) ]
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.500
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(313,3) ]
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(313,3) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 3.060 
   remark #15487: type converts: 2 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(312,5)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference dti[i] has aligned access   [ src/me_der.c(313,3) ]
   remark #15388: vectorization support: reference dti[i] has aligned access   [ src/me_der.c(313,12) ]
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.000
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(313,3) ]
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(313,3) ]
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 7 
   remark #15477: vector cost: 1.500 
   remark #15478: estimated potential speedup: 4.320 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(312,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(315,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/me_der.c(315,5)
   remark #15388: vectorization support: reference d_spectra[i+nlambda*8] has aligned access   [ src/me_der.c(316,6) ]
   remark #15389: vectorization support: reference dti[i] has unaligned access   [ src/me_der.c(316,27) ]
   remark #15388: vectorization support: reference etai_gp3[i] has aligned access   [ src/me_der.c(316,34) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 1.062
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 9 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 4.180 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(315,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/me_der.c(315,5)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference d_spectra[i+nlambda*8] has aligned access   [ src/me_der.c(316,6) ]
   remark #15389: vectorization support: reference dti[i] has unaligned access   [ src/me_der.c(316,27) ]
   remark #15389: vectorization support: reference etai_gp3[i] has unaligned access   [ src/me_der.c(316,34) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.600
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 7 
   remark #15477: vector cost: 1.500 
   remark #15478: estimated potential speedup: 4.320 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(315,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(319,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/me_der.c(319,5)
   remark #15388: vectorization support: reference d_spectra[i+nlambda*8+nlambda*11] has aligned access   [ src/me_der.c(320,6) ]
   remark #15389: vectorization support: reference dti[i] has unaligned access   [ src/me_der.c(320,41) ]
   remark #15388: vectorization support: reference gp4_gp2_rhoq[i] has aligned access   [ src/me_der.c(320,49) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 1.214
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 1.750 
   remark #15478: estimated potential speedup: 4.230 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(319,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/me_der.c(319,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(323,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/me_der.c(323,5)
   remark #15388: vectorization support: reference d_spectra[i+nlambda*8+(nlambda*11)*2] has aligned access   [ src/me_der.c(324,6) ]
   remark #15389: vectorization support: reference dti[i] has unaligned access   [ src/me_der.c(324,43) ]
   remark #15388: vectorization support: reference gp5_gp2_rhou[i] has aligned access   [ src/me_der.c(324,51) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 1.214
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 1.750 
   remark #15478: estimated potential speedup: 4.230 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(323,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/me_der.c(323,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(327,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/me_der.c(327,5)
   remark #15388: vectorization support: reference d_spectra[i+nlambda*8+(nlambda*11)*3] has aligned access   [ src/me_der.c(328,6) ]
   remark #15389: vectorization support: reference dti[i] has unaligned access   [ src/me_der.c(328,43) ]
   remark #15388: vectorization support: reference gp6_gp2_rhov[i] has aligned access   [ src/me_der.c(328,51) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 1.214
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 1.750 
   remark #15478: estimated potential speedup: 4.230 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(327,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/me_der.c(327,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(332,4)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/me_der.c(332,4)
   remark #15389: vectorization support: reference d_spectra[i+nlambda*7] has unaligned access   [ src/me_der.c(333,6) ]
   remark #15389: vectorization support: reference d_spectra[i+nlambda*7+nlambda*11] has unaligned access   [ src/me_der.c(334,6) ]
   remark #15388: vectorization support: reference d_spectra[i+nlambda*7+(nlambda*11)*2] has aligned access   [ src/me_der.c(335,6) ]
   remark #15388: vectorization support: reference d_spectra[i+nlambda*7+(nlambda*11)*3] has aligned access   [ src/me_der.c(336,6) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.556
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 2 
   remark #15451: unmasked unaligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 14 
   remark #15477: vector cost: 4.500 
   remark #15478: estimated potential speedup: 2.980 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(332,4)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/me_der.c(332,4)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference d_spectra[i+nlambda*7] has unaligned access   [ src/me_der.c(333,6) ]
   remark #15389: vectorization support: reference d_spectra[i+nlambda*7+nlambda*11] has unaligned access   [ src/me_der.c(334,6) ]
   remark #15389: vectorization support: reference d_spectra[i+nlambda*7+(nlambda*11)*2] has unaligned access   [ src/me_der.c(335,6) ]
   remark #15388: vectorization support: reference d_spectra[i+nlambda*7+(nlambda*11)*3] has aligned access   [ src/me_der.c(336,6) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.905
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 7 
   remark #15477: vector cost: 1.500 
   remark #15478: estimated potential speedup: 4.320 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(332,4)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(340,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/me_der.c(340,5)
   remark #15388: vectorization support: reference d_spectra[i+nlambda*6] has aligned access   [ src/me_der.c(341,6) ]
   remark #15388: vectorization support: reference d_spectra[i+nlambda*6+(nlambda*11)*3] has aligned access   [ src/me_der.c(342,6) ]
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 1.167
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 7 
   remark #15477: vector cost: 1.500 
   remark #15478: estimated potential speedup: 4.320 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(340,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/me_der.c(340,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/fgauss.c(31,2) inlined into src/me_der.c(360,3)
   remark #25045: Fused Loops: ( 31 75 )

   remark #15389: vectorization support: reference lambda[i] has unaligned access   [ src/fgauss.c(33,21) ]
   remark #15388: vectorization support: reference term[i] has aligned access   [ src/fgauss.c(34,3) ]
   remark #15388: vectorization support: reference term[i] has aligned access   [ src/fgauss.c(78,19) ]
   remark #15389: vectorization support: reference GMAC[i] has unaligned access   [ src/fgauss.c(78,4) ]
   remark #15389: vectorization support: reference GMAC[i] has unaligned access   [ src/fgauss.c(80,4) ]
   remark #15389: vectorization support: reference GMAC[i] has unaligned access   [ src/fgauss.c(78,4) ]
   remark #15389: vectorization support: reference GMAC[i] has unaligned access   [ src/fgauss.c(80,4) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.130
   remark #15301: FUSED LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 2 
   remark #15451: unmasked unaligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 134 
   remark #15477: vector cost: 77.000 
   remark #15478: estimated potential speedup: 1.730 
   remark #15482: vectorized math library calls: 1 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(75,2) inlined into src/me_der.c(360,3)
   remark #25046: Loop lost in Fusion 
LOOP END

LOOP BEGIN at src/fgauss.c(31,2) inlined into src/me_der.c(360,3)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/fgauss.c(85,2) inlined into src/me_der.c(360,3)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/fgauss.c(85,2) inlined into src/me_der.c(360,3)
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/fgauss.c(87,10) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 1.450
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 6 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 2.260 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(85,2) inlined into src/me_der.c(360,3)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/fgauss.c(89,2) inlined into src/me_der.c(360,3)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/fgauss.c(89,2) inlined into src/me_der.c(360,3)
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/fgauss.c(91,3) ]
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/fgauss.c(91,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.086
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 31 
   remark #15477: vector cost: 17.500 
   remark #15478: estimated potential speedup: 1.740 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(89,2) inlined into src/me_der.c(360,3)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/fgauss.c(91,3) ]
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/fgauss.c(91,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.343
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 31 
   remark #15477: vector cost: 17.500 
   remark #15478: estimated potential speedup: 1.740 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(89,2) inlined into src/me_der.c(360,3)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(367,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/me_der.c(367,5)
   remark #15389: vectorization support: reference inPSF_MAC[i] has unaligned access   [ src/me_der.c(368,6) ]
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/me_der.c(368,22) ]
   remark #15389: vectorization support: reference inPSF_MAC_DERIV[i] has unaligned access   [ src/me_der.c(369,6) ]
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/me_der.c(369,28) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/me_der.c(369,47) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/me_der.c(369,78) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.224
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 2 
   remark #15451: unmasked unaligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 214 
   remark #15477: vector cost: 67.000 
   remark #15478: estimated potential speedup: 3.140 
   remark #15486: divides: 3 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(367,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/me_der.c(367,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(373,5)
   remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 148 
   remark #15477: vector cost: 31.000 
   remark #15478: estimated potential speedup: 4.760 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(379,5)
   remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 40 
   remark #15477: vector cost: 14.000 
   remark #15478: estimated potential speedup: 2.840 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(383,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between inFilterMAC[ishift] (384:6) and inFilterMAC_DERIV[ishift] (385:6)
   remark #15346: vector dependence: assumed OUTPUT dependence between inFilterMAC_DERIV[ishift] (385:6) and inFilterMAC[ishift] (384:6)
LOOP END

LOOP BEGIN at src/me_der.c(389,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/me_der.c(389,5)
   remark #15389: vectorization support: reference inFilterMAC[i] has unaligned access   [ src/me_der.c(390,6) ]
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/me_der.c(390,23) ]
   remark #15389: vectorization support: reference inFilterMAC_DERIV[i] has unaligned access   [ src/me_der.c(391,6) ]
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/me_der.c(391,30) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/me_der.c(391,49) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/me_der.c(391,80) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.224
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 2 
   remark #15451: unmasked unaligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 214 
   remark #15477: vector cost: 67.000 
   remark #15478: estimated potential speedup: 3.140 
   remark #15486: divides: 3 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(389,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/me_der.c(389,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(398,4)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/me_der.c(399,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(399,5)
      remark #15388: vectorization support: reference inSpectraFwMAC[i] has aligned access   [ src/me_der.c(400,6) ]
      remark #15388: vectorization support: reference spectra[nlambda*il+i] has aligned access   [ src/me_der.c(400,26) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.389
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 15 
      remark #15477: vector cost: 4.500 
      remark #15478: estimated potential speedup: 3.200 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(399,5)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/me_der.c(399,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference inSpectraFwMAC[i] has aligned access   [ src/me_der.c(400,6) ]
      remark #15389: vectorization support: reference spectra[nlambda*il+i] has unaligned access   [ src/me_der.c(400,26) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.083
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(399,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/me_der.c(403,5)
      remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 133 
      remark #15477: vector cost: 16.000 
      remark #15478: estimated potential speedup: 8.270 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(408,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(408,5)
      remark #15388: vectorization support: reference d_spectra[ishift+nlambda*9+(nlambda*11)*il] has aligned access   [ src/me_der.c(409,6) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.326
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(409,6) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(408,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference d_spectra[ishift+nlambda*9+(nlambda*11)*il] has aligned access   [ src/me_der.c(409,6) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.182
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(409,6) ]
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(408,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/me_der.c(411,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(411,5)
      remark #15388: vectorization support: reference d_spectra[ishift+nlambda*9+(nlambda*11)*il] has aligned access   [ src/me_der.c(412,6) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.326
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(412,6) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(411,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference d_spectra[ishift+nlambda*9+(nlambda*11)*il] has aligned access   [ src/me_der.c(412,6) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.182
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(412,6) ]
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(411,5)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(416,4)
   remark #25095: Loop Interchange not done due to: User Function Inside Loop Nest
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/me_der.c(419,5)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/me_der.c(421,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(421,7)
         remark #15388: vectorization support: reference inSpectraFwMAC[i] has aligned access   [ src/me_der.c(422,8) ]
         remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(422,28) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.389
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 15 
         remark #15477: vector cost: 4.500 
         remark #15478: estimated potential speedup: 3.200 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(421,7)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/me_der.c(421,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference inSpectraFwMAC[i] has aligned access   [ src/me_der.c(422,8) ]
         remark #15389: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has unaligned access   [ src/me_der.c(422,28) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.083
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(421,7)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at src/me_der.c(425,7)
         remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 133 
         remark #15477: vector cost: 16.000 
         remark #15478: estimated potential speedup: 8.270 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(431,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(431,7)
         remark #15388: vectorization support: reference d_spectra[ishift+il*nlambda+(nlambda*11)*par] has aligned access   [ src/me_der.c(432,8) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.326
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(432,8) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(431,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference d_spectra[ishift+il*nlambda+(nlambda*11)*par] has aligned access   [ src/me_der.c(432,8) ]
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.182
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(432,8) ]
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(431,7)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at src/me_der.c(434,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(434,7)
         remark #15388: vectorization support: reference d_spectra[ishift+il*nlambda+(nlambda*11)*par] has aligned access   [ src/me_der.c(435,8) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.326
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(435,8) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(434,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference d_spectra[ishift+il*nlambda+(nlambda*11)*par] has aligned access   [ src/me_der.c(435,8) ]
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.182
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(435,8) ]
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(434,7)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at src/me_der.c(419,5)
      remark #25425: Redundant predicate at line 420 removed
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/me_der.c(421,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(421,7)
         remark #15388: vectorization support: reference inSpectraFwMAC[i] has aligned access   [ src/me_der.c(422,8) ]
         remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(422,28) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.389
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 15 
         remark #15477: vector cost: 4.500 
         remark #15478: estimated potential speedup: 3.200 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(421,7)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/me_der.c(421,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference inSpectraFwMAC[i] has aligned access   [ src/me_der.c(422,8) ]
         remark #15389: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has unaligned access   [ src/me_der.c(422,28) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.083
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(421,7)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at src/me_der.c(425,7)
         remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 133 
         remark #15477: vector cost: 16.000 
         remark #15478: estimated potential speedup: 8.270 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(431,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(431,7)
         remark #15388: vectorization support: reference d_spectra[ishift+il*nlambda+(nlambda*11)*par] has aligned access   [ src/me_der.c(432,8) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.326
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(432,8) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(431,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference d_spectra[ishift+il*nlambda+(nlambda*11)*par] has aligned access   [ src/me_der.c(432,8) ]
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.182
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(432,8) ]
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(431,7)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at src/me_der.c(434,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(434,7)
         remark #15388: vectorization support: reference d_spectra[ishift+il*nlambda+(nlambda*11)*par] has aligned access   [ src/me_der.c(435,8) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.326
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(435,8) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(434,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference d_spectra[ishift+il*nlambda+(nlambda*11)*par] has aligned access   [ src/me_der.c(435,8) ]
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.182
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(435,8) ]
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(434,7)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(443,4)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/me_der.c(443,4)
   remark #15388: vectorization support: reference GMAC_DERIV[i] has aligned access   [ src/me_der.c(444,5) ]
   remark #15389: vectorization support: reference GMAC[i] has unaligned access   [ src/me_der.c(444,22) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/me_der.c(444,41) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/me_der.c(444,72) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.061
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 98 
   remark #15477: vector cost: 55.500 
   remark #15478: estimated potential speedup: 1.740 
   remark #15486: divides: 3 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(443,4)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/me_der.c(443,4)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference GMAC_DERIV[i] has unaligned access   [ src/me_der.c(444,5) ]
   remark #15389: vectorization support: reference GMAC[i] has unaligned access   [ src/me_der.c(444,22) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/me_der.c(444,41) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/me_der.c(444,72) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.228
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 98 
   remark #15477: vector cost: 55.500 
   remark #15478: estimated potential speedup: 1.740 
   remark #15486: divides: 3 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(443,4)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/convolution.c(44,2) inlined into src/me_der.c(449,5)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(44,2) inlined into src/me_der.c(449,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(44,2) inlined into src/me_der.c(449,5)
      remark #15388: vectorization support: reference dirConvPar[k] has aligned access   [ src/convolution.c(46,3) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 1.260 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/convolution.c(44,2) inlined into src/me_der.c(449,5)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(49,2) inlined into src/me_der.c(449,5)
   remark #25399: memcopy generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/me_der.c(449,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/me_der.c(449,5)
      remark #15388: vectorization support: reference dirConvPar[k+mitad_nh] has aligned access   [ src/convolution.c(51,3) ]
      remark #15388: vectorization support: reference GMAC_DERIV[k] has aligned access   [ src/convolution.c(51,30) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 4.667
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 5 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 1.530 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/me_der.c(449,5)
   <Alternate Alignment Vectorized Loop>
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/me_der.c(449,5)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(449,5)
<Distributed chunk1>
   remark #25087: Preprocess Loopnests: Sinking 1 Stmts Into Inner LOOP to Create Perfect Nest 
   remark #25426: Loop Distributed (2 way) 
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(449,5)
   <Peeled loop for vectorization, Distributed chunk1>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(449,5)
   <Distributed chunk1>
      remark #15388: vectorization support: reference GMAC_DERIV[k] has aligned access   [ src/convolution.c(64,3) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: PARTIAL LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 1.260 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(449,5)
   <Remainder loop for vectorization, Distributed chunk1>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(449,5)
<Distributed chunk2>
   remark #25440: unrolled and jammed by 2   (pre-vector) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(449,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(449,5)
      remark #25085: Preprocess Loopnests: Moving Out Load and Store    [ src/convolution.c(62,4) ]
      remark #25085: Preprocess Loopnests: Moving Out Load and Store    [ src/convolution.c(62,4) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(62,18) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(62,18) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.867
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 18 
      remark #15477: vector cost: 7.500 
      remark #15478: estimated potential speedup: 2.300 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(449,5)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(449,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(62,18) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(62,18) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 3.000
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 3.500 
      remark #15478: estimated potential speedup: 2.440 
      remark #15488: --- end vector cost summary ---
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(449,5)
<Remainder, Distributed chunk2>
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(449,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(449,5)
      remark #25085: Preprocess Loopnests: Moving Out Load and Store    [ src/convolution.c(62,4) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(62,18) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 1.179
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 3.500 
      remark #15478: estimated potential speedup: 2.440 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(449,5)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(449,5)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(44,2) inlined into src/me_der.c(450,5)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(44,2) inlined into src/me_der.c(450,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(44,2) inlined into src/me_der.c(450,5)
      remark #15388: vectorization support: reference dirConvPar[k] has aligned access   [ src/convolution.c(46,3) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 1.260 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/convolution.c(44,2) inlined into src/me_der.c(450,5)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(49,2) inlined into src/me_der.c(450,5)
   remark #25399: memcopy generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/me_der.c(450,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/me_der.c(450,5)
      remark #15388: vectorization support: reference dirConvPar[k+mitad_nh] has aligned access   [ src/convolution.c(51,3) ]
      remark #15388: vectorization support: reference GMAC[k] has aligned access   [ src/convolution.c(51,30) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 4.667
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 5 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 1.530 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/me_der.c(450,5)
   <Alternate Alignment Vectorized Loop>
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/me_der.c(450,5)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(450,5)
<Distributed chunk1>
   remark #25087: Preprocess Loopnests: Sinking 1 Stmts Into Inner LOOP to Create Perfect Nest 
   remark #25426: Loop Distributed (2 way) 
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(450,5)
   <Peeled loop for vectorization, Distributed chunk1>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(450,5)
   <Distributed chunk1>
      remark #15388: vectorization support: reference GMAC[k] has aligned access   [ src/convolution.c(64,3) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: PARTIAL LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 1.260 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(450,5)
   <Remainder loop for vectorization, Distributed chunk1>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(450,5)
<Distributed chunk2>
   remark #25440: unrolled and jammed by 2   (pre-vector) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(450,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(450,5)
      remark #25085: Preprocess Loopnests: Moving Out Load and Store    [ src/convolution.c(62,4) ]
      remark #25085: Preprocess Loopnests: Moving Out Load and Store    [ src/convolution.c(62,4) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(62,18) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(62,18) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.867
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 18 
      remark #15477: vector cost: 7.500 
      remark #15478: estimated potential speedup: 2.300 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(450,5)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(450,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(62,18) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(62,18) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 3.000
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 3.500 
      remark #15478: estimated potential speedup: 2.440 
      remark #15488: --- end vector cost summary ---
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(56,2) inlined into src/me_der.c(450,5)
<Remainder, Distributed chunk2>
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(450,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(450,5)
      remark #25085: Preprocess Loopnests: Moving Out Load and Store    [ src/convolution.c(62,4) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(62,18) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 1.179
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 3.500 
      remark #15478: estimated potential speedup: 2.440 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(450,5)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/me_der.c(450,5)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(459,4)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 1 3 2 ) 
   remark #25084: Preprocess Loopnests: Moving Out Store    [ src/me_der.c(460,5) ]
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(210,2) inlined into src/me_der.c(460,5)
      remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
      remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(212,6) inlined into src/me_der.c(460,5)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/convolution.c(212,6) inlined into src/me_der.c(460,5)
         remark #15388: vectorization support: reference GMAC_DERIV[j] has aligned access   [ src/convolution.c(216,11) ]
         remark #15328: vectorization support: irregularly indexed load was emulated for the variable <x[mod]>, part of index is nonlinearly computed   [ src/convolution.c(216,18) ]
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.744
         remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/convolution.c(211,3) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15462: unmasked indexed (or gather) loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 29 
         remark #15477: vector cost: 10.750 
         remark #15478: estimated potential speedup: 2.610 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/convolution.c(212,6) inlined into src/me_der.c(460,5)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(493,4)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 1 3 2 ) 
   remark #25084: Preprocess Loopnests: Moving Out Store    [ src/me_der.c(494,5) ]
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(210,2) inlined into src/me_der.c(494,5)
      remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
      remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(212,6) inlined into src/me_der.c(494,5)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/convolution.c(212,6) inlined into src/me_der.c(494,5)
         remark #15388: vectorization support: reference GMAC_DERIV[j] has aligned access   [ src/convolution.c(216,11) ]
         remark #15328: vectorization support: irregularly indexed load was emulated for the variable <x[mod]>, part of index is nonlinearly computed   [ src/convolution.c(216,18) ]
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.744
         remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/convolution.c(211,3) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15462: unmasked indexed (or gather) loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 29 
         remark #15477: vector cost: 10.750 
         remark #15478: estimated potential speedup: 2.610 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/convolution.c(212,6) inlined into src/me_der.c(494,5)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(497,4)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/me_der.c(499,5)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(210,2) inlined into src/me_der.c(502,7)
         remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
         remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at src/convolution.c(212,6) inlined into src/me_der.c(502,7)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at src/convolution.c(212,6) inlined into src/me_der.c(502,7)
            remark #15388: vectorization support: reference GMAC[j] has aligned access   [ src/convolution.c(216,11) ]
            remark #15328: vectorization support: irregularly indexed load was emulated for the variable <x[mod]>, part of index is nonlinearly computed   [ src/convolution.c(216,18) ]
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 0.744
            remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/convolution.c(211,3) ]
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15462: unmasked indexed (or gather) loads: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 29 
            remark #15477: vector cost: 10.750 
            remark #15478: estimated potential speedup: 2.610 
            remark #15487: type converts: 1 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at src/convolution.c(212,6) inlined into src/me_der.c(502,7)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(516,5)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/me_der.c(517,7)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/me_der.c(518,5)
      <Peeled loop for vectorization, Multiversioned v1>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(518,5)
      <Multiversioned v1>
         remark #25228: Loop multiversioned for Data Dependence
         remark #25259: Invariant Condition eliminated(Loop at level 2 peeled last iter) at line 521
         remark #25260: Invariant Condition eliminated(Proven False) at line 521
         remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,6) ]
         remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,43) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.583
         remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(519,6) ]
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(519,6) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 3.000 
         remark #15478: estimated potential speedup: 2.870 
         remark #15487: type converts: 2 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(518,5)
      <Remainder loop for vectorization, Multiversioned v1>
         remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,6) ]
         remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,43) ]
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 2.250
         remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(519,6) ]
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(519,6) ]
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 2 
         remark #15449: unmasked aligned unit stride stores: 2 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 19 
         remark #15477: vector cost: 6.500 
         remark #15478: estimated potential speedup: 2.820 
         remark #15487: type converts: 4 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(518,5)
      <Remainder loop for vectorization, Multiversioned v1>
      LOOP END

      LOOP BEGIN at src/me_der.c(518,5)
      <Peeled loop for vectorization, Multiversioned v2>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(518,5)
      <Multiversioned v2>
         remark #25260: Invariant Condition eliminated(Proven False) at line 521
         remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,6) ]
         remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,43) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.583
         remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(519,6) ]
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(519,6) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 3.000 
         remark #15478: estimated potential speedup: 2.870 
         remark #15487: type converts: 2 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(518,5)
      <Remainder loop for vectorization, Multiversioned v2>
      LOOP END
   LOOP END

   LOOP BEGIN at src/me_der.c(518,5)
   <Peeled loop for vectorization, Multiversioned v1>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(518,5)
   <Multiversioned v1>
      remark #25261: Invariant Condition eliminated(Proven True) at line 521
      remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,6) ]
      remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,43) ]
      remark #15388: vectorization support: reference d_spectra[nlambda*10+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(522,7) ]
      remark #15389: vectorization support: reference spectra_slight[nlambda*par+i] has unaligned access   [ src/me_der.c(522,44) ]
      remark #15388: vectorization support: reference slight[nlambda*par+i] has aligned access   [ src/me_der.c(522,71) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.404
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(519,6) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(519,6) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(522,7) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(522,7) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 2 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 19 
      remark #15477: vector cost: 6.500 
      remark #15478: estimated potential speedup: 2.820 
      remark #15487: type converts: 4 
      remark #15488: --- end vector cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   LOOP END

   LOOP BEGIN at src/me_der.c(518,5)
   <Alternate Alignment Vectorized Loop, Multiversioned v1>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   LOOP END

   LOOP BEGIN at src/me_der.c(518,5)
   <Remainder loop for vectorization, Multiversioned v1>
      remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,6) ]
      remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,43) ]
      remark #15388: vectorization support: reference d_spectra[nlambda*10+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(522,7) ]
      remark #15389: vectorization support: reference spectra_slight[nlambda*par+i] has unaligned access   [ src/me_der.c(522,44) ]
      remark #15389: vectorization support: reference slight[nlambda*par+i] has unaligned access   [ src/me_der.c(522,71) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.500
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(519,6) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(519,6) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(522,7) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(522,7) ]
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 2 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 19 
      remark #15477: vector cost: 6.500 
      remark #15478: estimated potential speedup: 2.820 
      remark #15487: type converts: 4 
      remark #15488: --- end vector cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at src/me_der.c(518,5)
   <Remainder loop for vectorization, Multiversioned v1>
   LOOP END

   LOOP BEGIN at src/me_der.c(518,5)
   <Peeled loop for vectorization, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(518,5)
   <Multiversioned v2>
      remark #25261: Invariant Condition eliminated(Proven True) at line 521
      remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,6) ]
      remark #15388: vectorization support: reference d_spectra[nlambda*il+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(519,43) ]
      remark #15388: vectorization support: reference d_spectra[nlambda*10+(nlambda*11)*par+i] has aligned access   [ src/me_der.c(522,7) ]
      remark #15389: vectorization support: reference spectra_slight[nlambda*par+i] has unaligned access   [ src/me_der.c(522,44) ]
      remark #15388: vectorization support: reference slight[nlambda*par+i] has aligned access   [ src/me_der.c(522,71) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.404
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(519,6) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(519,6) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(522,7) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(522,7) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 2 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 19 
      remark #15477: vector cost: 6.500 
      remark #15478: estimated potential speedup: 2.820 
      remark #15487: type converts: 4 
      remark #15488: --- end vector cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   LOOP END

   LOOP BEGIN at src/me_der.c(518,5)
   <Alternate Alignment Vectorized Loop, Multiversioned v2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   LOOP END

   LOOP BEGIN at src/me_der.c(518,5)
   <Remainder loop for vectorization, Multiversioned v2>
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(538,4)
   remark #25095: Loop Interchange not done due to: User Function Inside Loop Nest
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/me_der.c(540,5)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/me_der.c(544,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(544,7)
         remark #15388: vectorization support: reference inSpectraFwPSF[k] has aligned access   [ src/me_der.c(545,8) ]
         remark #15388: vectorization support: reference d_spectra[nlambda*i+(nlambda*11)*j+k] has aligned access   [ src/me_der.c(545,28) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.389
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 15 
         remark #15477: vector cost: 4.500 
         remark #15478: estimated potential speedup: 3.200 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(544,7)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/me_der.c(544,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference inSpectraFwPSF[k] has aligned access   [ src/me_der.c(545,8) ]
         remark #15389: vectorization support: reference d_spectra[nlambda*i+(nlambda*11)*j+k] has unaligned access   [ src/me_der.c(545,28) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.083
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(544,7)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at src/me_der.c(548,7)
         remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 74 
         remark #15477: vector cost: 14.000 
         remark #15478: estimated potential speedup: 5.260 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(553,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(553,7)
         remark #15388: vectorization support: reference d_spectra[ishift+nlambda*i+(nlambda*11)*j] has aligned access   [ src/me_der.c(554,8) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.326
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(554,8) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(553,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference d_spectra[ishift+nlambda*i+(nlambda*11)*j] has aligned access   [ src/me_der.c(554,8) ]
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.182
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(554,8) ]
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(553,7)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at src/me_der.c(556,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(556,7)
         remark #15388: vectorization support: reference d_spectra[ishift+nlambda*i+(nlambda*11)*j] has aligned access   [ src/me_der.c(557,8) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.326
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(557,8) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(556,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference d_spectra[ishift+nlambda*i+(nlambda*11)*j] has aligned access   [ src/me_der.c(557,8) ]
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.182
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(557,8) ]
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(556,7)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at src/me_der.c(540,5)
      remark #25425: Redundant predicate at line 542 removed
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/me_der.c(544,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(544,7)
         remark #15388: vectorization support: reference inSpectraFwPSF[k] has aligned access   [ src/me_der.c(545,8) ]
         remark #15388: vectorization support: reference d_spectra[nlambda*i+(nlambda*11)*j+k] has aligned access   [ src/me_der.c(545,28) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.389
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 15 
         remark #15477: vector cost: 4.500 
         remark #15478: estimated potential speedup: 3.200 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(544,7)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/me_der.c(544,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference inSpectraFwPSF[k] has aligned access   [ src/me_der.c(545,8) ]
         remark #15389: vectorization support: reference d_spectra[nlambda*i+(nlambda*11)*j+k] has unaligned access   [ src/me_der.c(545,28) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.083
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(544,7)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at src/me_der.c(548,7)
         remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 74 
         remark #15477: vector cost: 14.000 
         remark #15478: estimated potential speedup: 5.260 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(553,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(553,7)
         remark #15388: vectorization support: reference d_spectra[ishift+nlambda*i+(nlambda*11)*j] has aligned access   [ src/me_der.c(554,8) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.326
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(554,8) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(553,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference d_spectra[ishift+nlambda*i+(nlambda*11)*j] has aligned access   [ src/me_der.c(554,8) ]
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.182
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(554,8) ]
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(553,7)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at src/me_der.c(556,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/me_der.c(556,7)
         remark #15388: vectorization support: reference d_spectra[ishift+nlambda*i+(nlambda*11)*j] has aligned access   [ src/me_der.c(557,8) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.326
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(557,8) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(556,7)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference d_spectra[ishift+nlambda*i+(nlambda*11)*j] has aligned access   [ src/me_der.c(557,8) ]
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 1.182
         remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(557,8) ]
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15452: unmasked strided loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.030 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/me_der.c(556,7)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(570,4)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/me_der.c(578,6)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(578,6)
      remark #15388: vectorization support: reference d_spectra[nlambda*i+h] has aligned access   [ src/me_der.c(579,7) ]
      remark #15388: vectorization support: reference d_spectra[nlambda*i+h] has aligned access   [ src/me_der.c(579,43) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.300
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 7 
      remark #15477: vector cost: 1.250 
      remark #15478: estimated potential speedup: 5.100 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(578,6)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/convolution.c(79,2) inlined into src/me_der.c(581,6)
      remark #25408: memset generated
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(79,2) inlined into src/me_der.c(581,6)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at src/convolution.c(79,2) inlined into src/me_der.c(581,6)
         remark #15388: vectorization support: reference dirConvPar[k] has aligned access   [ src/convolution.c(81,3) ]
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 1.667
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 1.260 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/convolution.c(79,2) inlined into src/me_der.c(581,6)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END

   LOOP BEGIN at src/convolution.c(84,2) inlined into src/me_der.c(581,6)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/convolution.c(84,2) inlined into src/me_der.c(581,6)
      remark #15388: vectorization support: reference dirConvPar[k+mitad_nh] has aligned access   [ src/convolution.c(86,3) ]
      remark #15388: vectorization support: reference x[k] has aligned access   [ src/convolution.c(86,30) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.875
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/convolution.c(86,3) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 6 
      remark #15477: vector cost: 2.000 
      remark #15478: estimated potential speedup: 2.850 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/convolution.c(84,2) inlined into src/me_der.c(581,6)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/convolution.c(84,2) inlined into src/me_der.c(581,6)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/convolution.c(91,2) inlined into src/me_der.c(581,6)
      remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
      remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
      remark #25461: Imperfect Loop Unroll-Jammed by 2   (pre-vector) 
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(581,6)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(581,6)
         remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
         remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(97,18) ]
         remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
         remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.867
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 2 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 18 
         remark #15477: vector cost: 7.500 
         remark #15478: estimated potential speedup: 2.300 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(581,6)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(581,6)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
         remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
         remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
         remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 3.000
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 3.500 
         remark #15478: estimated potential speedup: 2.440 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END

   LOOP BEGIN at src/convolution.c(91,2) inlined into src/me_der.c(581,6)
   <Remainder>
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(581,6)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(581,6)
         remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
         remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(97,18) ]
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 1.179
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 3.500 
         remark #15478: estimated potential speedup: 2.440 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(581,6)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(581,6)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at src/me_der.c(582,6)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/me_der.c(582,6)
      remark #15388: vectorization support: reference d_spectra[nlambda*i+h] has aligned access   [ src/me_der.c(583,7) ]
      remark #15388: vectorization support: reference d_spectra[nlambda*i+h] has aligned access   [ src/me_der.c(583,42) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.300
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 7 
      remark #15477: vector cost: 1.250 
      remark #15478: estimated potential speedup: 5.100 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/me_der.c(582,6)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/me_der.c(588,4)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/me_der.c(590,5)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(79,2) inlined into src/me_der.c(593,7)
         remark #25408: memset generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at src/convolution.c(79,2) inlined into src/me_der.c(593,7)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at src/convolution.c(79,2) inlined into src/me_der.c(593,7)
            remark #15388: vectorization support: reference dirConvPar[k] has aligned access   [ src/convolution.c(81,3) ]
            remark #15305: vectorization support: vector length 2
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 1.667
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 1.260 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at src/convolution.c(79,2) inlined into src/me_der.c(593,7)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at src/convolution.c(84,2) inlined into src/me_der.c(593,7)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/convolution.c(84,2) inlined into src/me_der.c(593,7)
         remark #15388: vectorization support: reference dirConvPar[k+mitad_nh] has aligned access   [ src/convolution.c(86,3) ]
         remark #15388: vectorization support: reference x[k] has aligned access   [ src/convolution.c(86,30) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.875
         remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/convolution.c(86,3) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 2.850 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/convolution.c(84,2) inlined into src/me_der.c(593,7)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/convolution.c(84,2) inlined into src/me_der.c(593,7)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at src/convolution.c(91,2) inlined into src/me_der.c(593,7)
         remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
         remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
         remark #25461: Imperfect Loop Unroll-Jammed by 2   (pre-vector) 
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(593,7)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(593,7)
            remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
            remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(97,18) ]
            remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
            remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 2
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.867
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 2 
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 18 
            remark #15477: vector cost: 7.500 
            remark #15478: estimated potential speedup: 2.300 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(593,7)
         <Alternate Alignment Vectorized Loop>
         LOOP END

         LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(593,7)
         <Remainder loop for vectorization>
            remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
            remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
            remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
            remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 3.000
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 2 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 9 
            remark #15477: vector cost: 3.500 
            remark #15478: estimated potential speedup: 2.440 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END

      LOOP BEGIN at src/convolution.c(91,2) inlined into src/me_der.c(593,7)
      <Remainder>
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(593,7)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(593,7)
            remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
            remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(97,18) ]
            remark #15305: vectorization support: vector length 2
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 1.179
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 2 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 9 
            remark #15477: vector cost: 3.500 
            remark #15478: estimated potential speedup: 2.440 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(593,7)
         <Alternate Alignment Vectorized Loop>
         LOOP END

         LOOP BEGIN at src/convolution.c(95,3) inlined into src/me_der.c(593,7)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

src/convolution.c(44,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(44,2):remark #34026: call to memset implemented as a call to optimized library version
src/convolution.c(49,2):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(49,2):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(49,2):remark #34026: call to memcpy implemented as a call to optimized library version
src/convolution.c(56,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(56,2):remark #34026: call to memset implemented as a call to optimized library version
src/convolution.c(44,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(44,2):remark #34026: call to memset implemented as a call to optimized library version
src/convolution.c(49,2):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(49,2):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(49,2):remark #34026: call to memcpy implemented as a call to optimized library version
src/convolution.c(56,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(56,2):remark #34026: call to memset implemented as a call to optimized library version
src/convolution.c(79,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(79,2):remark #34026: call to memset implemented as a call to optimized library version
src/convolution.c(79,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(79,2):remark #34026: call to memset implemented as a call to optimized library version
src/me_der.c(67,1):remark #34051: REGISTER ALLOCATION : [me_der] src/me_der.c:67

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    5629
            Global    :    1392
            Local     :    4237
        Regenerable   :      85
        Spilled       :     339
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :    2680 bytes*
            Reads     :    1527 [1.36e+04 ~ 7.5%]
            Writes    :     625 [1.71e+03 ~ 1.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: funcionComponentFor(int, double, int, float *, float *, float *, float *, double, double, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (funcionComponentFor(int, double, int, float *, float *, float *, float *, double, double, int)) [4/70=5.7%] src/me_der.c(620,1)
  -> EXTERN: (623,7) _vla_alloc(long)
  -> EXTERN: (623,18) _vla_alloc(long)
  -> EXTERN: (623,29) _vla_alloc(long)
  -> EXTERN: (701,2) _vla_free(void *, long)
  -> EXTERN: (701,2) _vla_free(void *, long)
  -> EXTERN: (701,2) _vla_free(void *, long)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/me_der.c(627,2)
   remark #15388: vectorization support: reference auxCte[j] has aligned access   [ src/me_der.c(628,3) ]
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.500
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 35 
   remark #15477: vector cost: 0.750 
   remark #15478: estimated potential speedup: 28.760 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(627,2)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference auxCte[j] has aligned access   [ src/me_der.c(628,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 4.000
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 35 
   remark #15477: vector cost: 0.750 
   remark #15478: estimated potential speedup: 28.760 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/me_der.c(627,2)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/me_der.c(633,2)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/me_der.c(639,3)
   <Distributed chunk1>
      remark #25045: Fused Loops: ( 639 643 647 656 661 666 671 677 682 687 692 )

      remark #25426: Loop Distributed (2 way) 
      remark #15388: vectorization support: reference dF_u[j] has aligned access   [ src/me_der.c(644,4) ]
      remark #15389: vectorization support: reference H[j] has unaligned access   [ src/me_der.c(644,18) ]
      remark #15389: vectorization support: reference uu[j] has unaligned access   [ src/me_der.c(644,25) ]
      remark #15389: vectorization support: reference F[j] has unaligned access   [ src/me_der.c(644,31) ]
      remark #15388: vectorization support: reference dH_u[j] has aligned access   [ src/me_der.c(640,4) ]
      remark #15389: vectorization support: reference F[j] has unaligned access   [ src/me_der.c(640,18) ]
      remark #15389: vectorization support: reference uu[j] has unaligned access   [ src/me_der.c(640,27) ]
      remark #15389: vectorization support: reference H[j] has unaligned access   [ src/me_der.c(640,33) ]
      remark #15389: vectorization support: reference dshi[j+(numl*4)*desp] has unaligned access   [ src/me_der.c(679,4) ]
      remark #15389: vectorization support: reference dshi[j+(numl*4)*desp] has unaligned access   [ src/me_der.c(679,26) ]
      remark #15388: vectorization support: reference dF_u[j] has aligned access   [ src/me_der.c(679,49) ]
      remark #15389: vectorization support: reference dfi[j+(numl*4)*desp] has unaligned access   [ src/me_der.c(658,4) ]
      remark #15389: vectorization support: reference dfi[j+(numl*4)*desp] has unaligned access   [ src/me_der.c(658,25) ]
      remark #15388: vectorization support: reference dH_u[j] has aligned access   [ src/me_der.c(658,46) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.500
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(644,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(644,4) ]
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/me_der.c(640,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(640,4) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 2 
      remark #15450: unmasked unaligned unit stride loads: 5 
      remark #15451: unmasked unaligned unit stride stores: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 66 
      remark #15477: vector cost: 21.500 
      remark #15478: estimated potential speedup: 3.040 
      remark #15487: type converts: 6 
      remark #15488: --- end vector cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   LOOP END

   LOOP BEGIN at src/me_der.c(643,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(647,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(656,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(661,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(666,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(671,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(677,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(682,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(687,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(692,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/me_der.c(639,3)
   <Remainder loop for vectorization, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/me_der.c(639,3)
   <Distributed chunk2>
      remark #15389: vectorization support: reference dfi[numl*3+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(673,4) ]
      remark #15389: vectorization support: reference dfi[numl*3+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(673,32) ]
      remark #15388: vectorization support: reference dF_u[j] has aligned access   [ src/me_der.c(673,64) ]
      remark #15389: vectorization support: reference dshi[numl+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(684,4) ]
      remark #15389: vectorization support: reference dshi[numl+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(684,31) ]
      remark #15388: vectorization support: reference dF_u[j] has aligned access   [ src/me_der.c(684,58) ]
      remark #15388: vectorization support: reference auxCte[j] has aligned access   [ src/me_der.c(684,66) ]
      remark #15389: vectorization support: reference uu[j] has unaligned access   [ src/me_der.c(648,4) ]
      remark #15389: vectorization support: reference uu[j] has unaligned access   [ src/me_der.c(648,11) ]
      remark #15389: vectorization support: reference dfi[numl+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(663,4) ]
      remark #15389: vectorization support: reference dfi[numl+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(663,30) ]
      remark #15388: vectorization support: reference dH_u[j] has aligned access   [ src/me_der.c(663,56) ]
      remark #15388: vectorization support: reference auxCte[j] has aligned access   [ src/me_der.c(663,64) ]
      remark #15389: vectorization support: reference dshi[numl*3+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(694,4) ]
      remark #15389: vectorization support: reference dshi[numl*3+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(694,33) ]
      remark #15388: vectorization support: reference dH_u[j] has aligned access   [ src/me_der.c(694,63) ]
      remark #15389: vectorization support: reference dshi[numl*2+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(689,4) ]
      remark #15389: vectorization support: reference dshi[numl*2+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(689,33) ]
      remark #15388: vectorization support: reference dF_u[j] has aligned access   [ src/me_der.c(689,63) ]
      remark #15389: vectorization support: reference uu[j] has unaligned access   [ src/me_der.c(689,71) ]
      remark #15389: vectorization support: reference dfi[numl*2+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(668,4) ]
      remark #15389: vectorization support: reference dfi[numl*2+j+(numl*4)*desp] has unaligned access   [ src/me_der.c(668,32) ]
      remark #15388: vectorization support: reference dH_u[j] has aligned access   [ src/me_der.c(668,61) ]
      remark #15389: vectorization support: reference uu[j] has unaligned access   [ src/me_der.c(668,69) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.242
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/me_der.c(648,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/me_der.c(648,4) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 6 
      remark #15450: unmasked unaligned unit stride loads: 7 
      remark #15451: unmasked unaligned unit stride stores: 7 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 92 
      remark #15477: vector cost: 47.500 
      remark #15478: estimated potential speedup: 1.930 
      remark #15486: divides: 1 
      remark #15487: type converts: 2 
      remark #15488: --- end vector cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
   LOOP END

   LOOP BEGIN at src/me_der.c(639,3)
   <Remainder loop for vectorization, Distributed chunk2>
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

src/me_der.c(620,1):remark #34051: REGISTER ALLOCATION : [funcionComponentFor] src/me_der.c:620

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     263
            Global    :      77
            Local     :     186
        Regenerable   :      14
        Spilled       :      36
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     264 bytes*
            Reads     :      76 [2.42e+02 ~ 5.4%]
            Writes    :      39 [8.54e+01 ~ 1.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: Resetear_Valores_Intermedios(int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (Resetear_Valores_Intermedios(int)) [5/70=7.1%] src/me_der.c(707,47)
  -> EXTERN: (709,2) memset(void *, int, size_t)
  -> EXTERN: (710,2) memset(void *, int, size_t)
  -> EXTERN: (711,2) memset(void *, int, size_t)
  -> EXTERN: (712,2) memset(void *, int, size_t)
  -> EXTERN: (713,2) memset(void *, int, size_t)
  -> EXTERN: (714,2) memset(void *, int, size_t)
  -> EXTERN: (715,2) memset(void *, int, size_t)
  -> EXTERN: (716,2) memset(void *, int, size_t)
  -> EXTERN: (717,2) memset(void *, int, size_t)


    Report from: Code generation optimizations [cg]

src/me_der.c(709,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/me_der.c(709,2):remark #34026: call to memset implemented as a call to optimized library version
src/me_der.c(710,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/me_der.c(710,2):remark #34026: call to memset implemented as a call to optimized library version
src/me_der.c(711,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/me_der.c(711,2):remark #34026: call to memset implemented as a call to optimized library version
src/me_der.c(712,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/me_der.c(712,2):remark #34026: call to memset implemented as a call to optimized library version
src/me_der.c(713,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/me_der.c(713,2):remark #34026: call to memset implemented as a call to optimized library version
src/me_der.c(714,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/me_der.c(714,2):remark #34026: call to memset implemented as a call to optimized library version
src/me_der.c(715,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/me_der.c(715,2):remark #34026: call to memset implemented as a call to optimized library version
src/me_der.c(716,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/me_der.c(716,2):remark #34026: call to memset implemented as a call to optimized library version
src/me_der.c(717,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/me_der.c(717,2):remark #34026: call to memset implemented as a call to optimized library version
src/me_der.c(707,47):remark #34051: REGISTER ALLOCATION : [Resetear_Valores_Intermedios] src/me_der.c:707

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rdx rbx rsi rdi r15]
        
    Routine temporaries
        Total         :      52
            Global    :       9
            Local     :      43
        Regenerable   :       9
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: mil_sinrf(Cuantic *, Init_Model *, double *, double *, int, float *, double, double *, float *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (mil_sinrf(Cuantic *, Init_Model *, double *, double *, int, float *, double, double *, float *, int)) [6/70=8.6%] src/mil_sinrf.c(62,1)
  -> EXTERN: (74,7) _vla_alloc(long)
  -> EXTERN: (116,9) sinf(float)
  -> EXTERN: (117,7) cosf(float)
  -> EXTERN: (122,7) sinf(float)
  -> EXTERN: (123,7) cosf(float)
  -> (206,3) funcionComponentFor_sinrf(float *, int, int, float *, float *, float *, float *, double, double) (isz = 297) (sz = 320)
     [[ Inlining would exceed -inline-max-size value (320>230) <3>]]
  -> (209,3) funcionComponentFor_sinrf(float *, int, int, float *, float *, float *, float *, double, double) (isz = 297) (sz = 320)
     [[ Inlining would exceed -inline-max-size value (320>230) <3>]]
  -> (212,3) funcionComponentFor_sinrf(float *, int, int, float *, float *, float *, float *, double, double) (isz = 297) (sz = 320)
     [[ Inlining would exceed -inline-max-size value (320>230) <3>]]
  -> EXTERN: (291,7) _vla_alloc(long)
  -> INLINE: (327,6) fgauss(double, double *, int, double, int) (isz = 128) (sz = 143)
    -> EXTERN: src/fgauss.c:(21,12) _vla_alloc(long)
    -> EXTERN: src/fgauss.c:(78,14) exp(double)
    -> EXTERN: src/fgauss.c:(105,2) _vla_free(void *, long)
  -> EXTERN: (337,5) fftw_execute(const fftw_plan)
  -> EXTERN: (341,5) fftw_execute(const fftw_plan)
  -> EXTERN: (355,4) fftw_execute(const fftw_plan)
  -> EXTERN: (362,5) fftw_execute(const fftw_plan)
  -> EXTERN: (366,5) fftw_execute(const fftw_plan)
  -> EXTERN: (369,30) creal(double __complex__)
  -> EXTERN: (372,30) creal(double __complex__)
  -> INLINE: (380,5) direct_convolution_double(double *, int, double *, int) (isz = 69) (sz = 80)
  -> INLINE: (399,5) convCircular(float *, double *, int, float *) (isz = 65) (sz = 76)
  -> EXTERN: (422,5) fftw_execute(const fftw_plan)
  -> EXTERN: (427,5) fftw_execute(const fftw_plan)
  -> EXTERN: (430,31) creal(double __complex__)
  -> EXTERN: (433,31) creal(double __complex__)
  -> INLINE: (448,4) direct_convolution(float *, int, double *, int) (isz = 71) (sz = 82)
  -> INLINE: (455,5) direct_convolution(float *, int, double *, int) (isz = 71) (sz = 82)
  -> EXTERN: (466,2) _vla_free(void *, long)
  -> EXTERN: (466,2) _vla_free(void *, long)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/mil_sinrf.c(100,2)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(100,2)
   remark #15389: vectorization support: reference etai[j] has unaligned access   [ src/mil_sinrf.c(101,3) ]
   remark #15389: vectorization support: reference etaq[j] has unaligned access   [ src/mil_sinrf.c(102,3) ]
   remark #15389: vectorization support: reference etau[j] has unaligned access   [ src/mil_sinrf.c(103,3) ]
   remark #15389: vectorization support: reference etav[j] has unaligned access   [ src/mil_sinrf.c(104,3) ]
   remark #15389: vectorization support: reference rhoq[j] has unaligned access   [ src/mil_sinrf.c(105,3) ]
   remark #15388: vectorization support: reference rhou[j] has aligned access   [ src/mil_sinrf.c(106,3) ]
   remark #15388: vectorization support: reference rhov[j] has aligned access   [ src/mil_sinrf.c(107,3) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.403
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 2 
   remark #15451: unmasked unaligned unit stride stores: 5 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 25 
   remark #15477: vector cost: 9.000 
   remark #15478: estimated potential speedup: 2.680 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(100,2)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(100,2)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference etai[j] has unaligned access   [ src/mil_sinrf.c(101,3) ]
   remark #15389: vectorization support: reference etaq[j] has unaligned access   [ src/mil_sinrf.c(102,3) ]
   remark #15389: vectorization support: reference etau[j] has unaligned access   [ src/mil_sinrf.c(103,3) ]
   remark #15389: vectorization support: reference etav[j] has unaligned access   [ src/mil_sinrf.c(104,3) ]
   remark #15389: vectorization support: reference rhoq[j] has unaligned access   [ src/mil_sinrf.c(105,3) ]
   remark #15389: vectorization support: reference rhou[j] has unaligned access   [ src/mil_sinrf.c(106,3) ]
   remark #15388: vectorization support: reference rhov[j] has aligned access   [ src/mil_sinrf.c(107,3) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.718
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 2 
   remark #15451: unmasked unaligned unit stride stores: 5 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 25 
   remark #15477: vector cost: 9.000 
   remark #15478: estimated potential speedup: 2.680 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(100,2)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(136,5)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/mil_sinrf.c(156,6)
   <Peeled loop for vectorization, Distributed chunk1>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(156,6)
   <Distributed chunk1>
      remark #25045: Fused Loops: ( 156 167 172 )

      remark #25426: Loop Distributed (2 way) 
      remark #15389: vectorization support: reference u[i] has unaligned access   [ src/mil_sinrf.c(157,7) ]
      remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/mil_sinrf.c(157,14) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.113
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(157,7) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 37 
      remark #15477: vector cost: 21.000 
      remark #15478: estimated potential speedup: 1.730 
      remark #15486: divides: 1 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(167,6)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(172,6)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(156,6)
   <Remainder loop for vectorization, Distributed chunk1>
      remark #15389: vectorization support: reference u[i] has unaligned access   [ src/mil_sinrf.c(157,7) ]
      remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/mil_sinrf.c(157,14) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.452
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(157,7) ]
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.250 
      remark #15478: estimated potential speedup: 5.760 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(156,6)
   <Remainder loop for vectorization, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(156,6)
   <Peeled loop for vectorization, Distributed chunk2>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(156,6)
   <Distributed chunk2>
      remark #15389: vectorization support: reference fi_p[i] has unaligned access   [ src/mil_sinrf.c(168,4) ]
      remark #15389: vectorization support: reference fi_b[i] has unaligned access   [ src/mil_sinrf.c(169,4) ]
      remark #15389: vectorization support: reference fi_r[i] has unaligned access   [ src/mil_sinrf.c(170,4) ]
      remark #15389: vectorization support: reference shi_p[i] has unaligned access   [ src/mil_sinrf.c(173,4) ]
      remark #15388: vectorization support: reference shi_b[i] has aligned access   [ src/mil_sinrf.c(174,4) ]
      remark #15388: vectorization support: reference shi_r[i] has aligned access   [ src/mil_sinrf.c(175,4) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.433
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 2 
      remark #15451: unmasked unaligned unit stride stores: 4 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 21 
      remark #15477: vector cost: 7.500 
      remark #15478: estimated potential speedup: 2.700 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(156,6)
   <Alternate Alignment Vectorized Loop, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(156,6)
   <Remainder loop for vectorization, Distributed chunk2>
      remark #15389: vectorization support: reference fi_p[i] has unaligned access   [ src/mil_sinrf.c(168,4) ]
      remark #15389: vectorization support: reference fi_b[i] has unaligned access   [ src/mil_sinrf.c(169,4) ]
      remark #15389: vectorization support: reference fi_r[i] has unaligned access   [ src/mil_sinrf.c(170,4) ]
      remark #15389: vectorization support: reference shi_p[i] has unaligned access   [ src/mil_sinrf.c(173,4) ]
      remark #15389: vectorization support: reference shi_b[i] has unaligned access   [ src/mil_sinrf.c(174,4) ]
      remark #15388: vectorization support: reference shi_r[i] has aligned access   [ src/mil_sinrf.c(175,4) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.758
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.250 
      remark #15478: estimated potential speedup: 5.760 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(156,6)
   <Remainder loop for vectorization, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(189,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(193,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(197,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(224,3)
   <Peeled loop for vectorization, Distributed chunk1>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 12
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(224,3)
   <Distributed chunk1>
      remark #25045: Fused Loops: ( 224 232 238 244 250 )

      remark #25426: Loop Distributed (2 way) 
      remark #15389: vectorization support: reference rhovn[i] has unaligned access   [ src/mil_sinrf.c(241,4) ]
      remark #15389: vectorization support: reference shi_r[i] has unaligned access   [ src/mil_sinrf.c(241,14) ]
      remark #15389: vectorization support: reference shi_b[i] has unaligned access   [ src/mil_sinrf.c(241,23) ]
      remark #15389: vectorization support: reference etavn[i] has unaligned access   [ src/mil_sinrf.c(236,4) ]
      remark #15389: vectorization support: reference fi_r[i] has unaligned access   [ src/mil_sinrf.c(236,14) ]
      remark #15389: vectorization support: reference fi_b[i] has unaligned access   [ src/mil_sinrf.c(236,22) ]
      remark #15389: vectorization support: reference parcial3[i] has unaligned access   [ src/mil_sinrf.c(227,4) ]
      remark #15389: vectorization support: reference shi_p[i] has unaligned access   [ src/mil_sinrf.c(227,24) ]
      remark #15389: vectorization support: reference shi_b[i] has unaligned access   [ src/mil_sinrf.c(227,34) ]
      remark #15389: vectorization support: reference shi_r[i] has unaligned access   [ src/mil_sinrf.c(227,43) ]
      remark #15389: vectorization support: reference parcial1[i] has unaligned access   [ src/mil_sinrf.c(225,4) ]
      remark #15389: vectorization support: reference fi_b[i] has unaligned access   [ src/mil_sinrf.c(225,16) ]
      remark #15389: vectorization support: reference fi_r[i] has unaligned access   [ src/mil_sinrf.c(225,24) ]
      remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(253,4) ]
      remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(253,12) ]
      remark #15389: vectorization support: reference rhovn[i] has unaligned access   [ src/mil_sinrf.c(253,20) ]
      remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/mil_sinrf.c(248,4) ]
      remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/mil_sinrf.c(248,12) ]
      remark #15389: vectorization support: reference etavn[i] has unaligned access   [ src/mil_sinrf.c(248,20) ]
      remark #15389: vectorization support: reference rhoqn[i] has unaligned access   [ src/mil_sinrf.c(239,4) ]
      remark #15389: vectorization support: reference parcial3[i] has unaligned access   [ src/mil_sinrf.c(239,14) ]
      remark #15389: vectorization support: reference rhoun[i] has unaligned access   [ src/mil_sinrf.c(240,4) ]
      remark #15389: vectorization support: reference parcial3[i] has unaligned access   [ src/mil_sinrf.c(240,14) ]
      remark #15388: vectorization support: reference parcial2[i] has aligned access   [ src/mil_sinrf.c(226,4) ]
      remark #15389: vectorization support: reference fi_p[i] has unaligned access   [ src/mil_sinrf.c(226,24) ]
      remark #15389: vectorization support: reference parcial1[i] has unaligned access   [ src/mil_sinrf.c(226,33) ]
      remark #15389: vectorization support: reference etain[i] has unaligned access   [ src/mil_sinrf.c(233,4) ]
      remark #15389: vectorization support: reference fi_p[i] has unaligned access   [ src/mil_sinrf.c(233,22) ]
      remark #15389: vectorization support: reference parcial1[i] has unaligned access   [ src/mil_sinrf.c(233,37) ]
      remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(251,4) ]
      remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(251,12) ]
      remark #15389: vectorization support: reference rhoqn[i] has unaligned access   [ src/mil_sinrf.c(251,20) ]
      remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(252,4) ]
      remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(252,12) ]
      remark #15389: vectorization support: reference rhoun[i] has unaligned access   [ src/mil_sinrf.c(252,20) ]
      remark #15389: vectorization support: reference etaqn[i] has unaligned access   [ src/mil_sinrf.c(234,4) ]
      remark #15388: vectorization support: reference parcial2[i] has aligned access   [ src/mil_sinrf.c(234,14) ]
      remark #15389: vectorization support: reference etaun[i] has unaligned access   [ src/mil_sinrf.c(235,4) ]
      remark #15388: vectorization support: reference parcial2[i] has aligned access   [ src/mil_sinrf.c(235,14) ]
      remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/mil_sinrf.c(245,4) ]
      remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/mil_sinrf.c(245,12) ]
      remark #15389: vectorization support: reference etain[i] has unaligned access   [ src/mil_sinrf.c(245,20) ]
      remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(246,4) ]
      remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(246,12) ]
      remark #15389: vectorization support: reference etaqn[i] has unaligned access   [ src/mil_sinrf.c(246,20) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.800
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 20 
      remark #15451: unmasked unaligned unit stride stores: 15 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 137 
      remark #15477: vector cost: 46.250 
      remark #15478: estimated potential speedup: 2.850 
      remark #15488: --- end vector cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 12
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(232,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(238,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(244,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(250,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(224,3)
   <Remainder loop for vectorization, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(224,3)
   <Peeled loop for vectorization, Distributed chunk2>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(224,3)
   <Distributed chunk2>
      remark #15388: vectorization support: reference etau[i] has aligned access   [ src/mil_sinrf.c(247,4) ]
      remark #15388: vectorization support: reference etau[i] has aligned access   [ src/mil_sinrf.c(247,12) ]
      remark #15388: vectorization support: reference etaun[i] has aligned access   [ src/mil_sinrf.c(247,20) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.400
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.250 
      remark #15478: estimated potential speedup: 5.760 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(224,3)
   <Alternate Alignment Vectorized Loop, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(224,3)
   <Remainder loop for vectorization, Distributed chunk2>
      remark #15388: vectorization support: reference etau[i] has aligned access   [ src/mil_sinrf.c(247,4) ]
      remark #15388: vectorization support: reference etau[i] has aligned access   [ src/mil_sinrf.c(247,12) ]
      remark #15389: vectorization support: reference etaun[i] has unaligned access   [ src/mil_sinrf.c(247,20) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.857
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 8 
      remark #15477: vector cost: 1.250 
      remark #15478: estimated potential speedup: 5.760 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(224,3)
   <Remainder loop for vectorization, Distributed chunk2>
   LOOP END
LOOP END

LOOP BEGIN at src/mil_sinrf.c(260,2)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(260,2)
   remark #15388: vectorization support: reference etai_2[i] has aligned access   [ src/mil_sinrf.c(261,3) ]
   remark #15388: vectorization support: reference etai[i] has aligned access   [ src/mil_sinrf.c(261,13) ]
   remark #15388: vectorization support: reference etai[i] has aligned access   [ src/mil_sinrf.c(261,21) ]
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 1.400
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 8 
   remark #15477: vector cost: 1.250 
   remark #15478: estimated potential speedup: 5.760 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(260,2)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(260,2)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(261,3) ]
   remark #15388: vectorization support: reference etai[i] has aligned access   [ src/mil_sinrf.c(261,13) ]
   remark #15388: vectorization support: reference etai[i] has aligned access   [ src/mil_sinrf.c(261,21) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.625
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 45 
   remark #15477: vector cost: 16.750 
   remark #15478: estimated potential speedup: 2.660 
   remark #15487: type converts: 4 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(260,2)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(264,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(264,5)
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(266,8) ]
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(266,16) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(267,8) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(267,16) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(268,8) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(268,16) ]
   remark #15389: vectorization support: reference gp1[i] has unaligned access   [ src/mil_sinrf.c(269,6) ]
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(269,13) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(269,23) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(269,31) ]
   remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/mil_sinrf.c(269,39) ]
   remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/mil_sinrf.c(269,47) ]
   remark #15388: vectorization support: reference etav[i] has aligned access   [ src/mil_sinrf.c(269,55) ]
   remark #15388: vectorization support: reference etav[i] has aligned access   [ src/mil_sinrf.c(269,63) ]
   remark #15389: vectorization support: reference gp3[i] has unaligned access   [ src/mil_sinrf.c(270,6) ]
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(270,13) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.635
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15451: unmasked unaligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 57 
   remark #15477: vector cost: 15.750 
   remark #15478: estimated potential speedup: 3.460 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(264,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(272,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(272,5)
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(273,9) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(273,16) ]
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(273,24) ]
   remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/mil_sinrf.c(273,32) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(273,40) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/mil_sinrf.c(273,48) ]
   remark #15388: vectorization support: reference rhov[i] has aligned access   [ src/mil_sinrf.c(273,56) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.630
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 5 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 20 
   remark #15477: vector cost: 5.750 
   remark #15478: estimated potential speedup: 3.310 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(272,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(272,5)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(273,9) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(273,16) ]
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(273,24) ]
   remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/mil_sinrf.c(273,32) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(273,40) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/mil_sinrf.c(273,48) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(273,56) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.120
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 45 
   remark #15477: vector cost: 16.750 
   remark #15478: estimated potential speedup: 2.660 
   remark #15487: type converts: 4 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(272,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(275,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(275,5)
   remark #15388: vectorization support: reference dt[i] has aligned access   [ src/mil_sinrf.c(276,9) ]
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(276,15) ]
   remark #15389: vectorization support: reference gp1[i] has unaligned access   [ src/mil_sinrf.c(276,25) ]
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(276,32) ]
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(276,39) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.769
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 14 
   remark #15477: vector cost: 3.250 
   remark #15478: estimated potential speedup: 4.040 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(275,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(275,5)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/mil_sinrf.c(276,9) ]
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(276,15) ]
   remark #15389: vectorization support: reference gp1[i] has unaligned access   [ src/mil_sinrf.c(276,25) ]
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(276,32) ]
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(276,39) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.188
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 45 
   remark #15477: vector cost: 16.750 
   remark #15478: estimated potential speedup: 2.660 
   remark #15487: type converts: 4 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(275,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(278,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(278,5)
   remark #25045: Fused Loops: ( 278 281 )

   remark #15388: vectorization support: reference dti[i] has aligned access   [ src/mil_sinrf.c(279,6) ]
   remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/mil_sinrf.c(279,17) ]
   remark #15388: vectorization support: reference gp4[i] has aligned access   [ src/mil_sinrf.c(282,6) ]
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(282,13) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(282,23) ]
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/mil_sinrf.c(282,31) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/mil_sinrf.c(282,40) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(282,48) ]
   remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/mil_sinrf.c(282,56) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(282,64) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.288
   remark #15301: FUSED LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15449: unmasked aligned unit stride stores: 2 
   remark #15450: unmasked unaligned unit stride loads: 8 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 53 
   remark #15477: vector cost: 16.500 
   remark #15478: estimated potential speedup: 3.090 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(281,5)
   remark #25046: Loop lost in Fusion 
LOOP END

LOOP BEGIN at src/mil_sinrf.c(278,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(278,5)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference dti[i] has unaligned access   [ src/mil_sinrf.c(279,6) ]
   remark #15389: vectorization support: reference dt[i] has unaligned access   [ src/mil_sinrf.c(279,17) ]
   remark #15388: vectorization support: reference gp4[i] has aligned access   [ src/mil_sinrf.c(282,6) ]
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(282,13) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(282,23) ]
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/mil_sinrf.c(282,31) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/mil_sinrf.c(282,40) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(282,48) ]
   remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/mil_sinrf.c(282,56) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(282,64) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.536
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 45 
   remark #15477: vector cost: 16.750 
   remark #15478: estimated potential speedup: 2.660 
   remark #15487: type converts: 4 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(278,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(284,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(284,5)
   remark #15388: vectorization support: reference gp5[i] has aligned access   [ src/mil_sinrf.c(285,6) ]
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(285,13) ]
   remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/mil_sinrf.c(285,23) ]
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/mil_sinrf.c(285,31) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(285,40) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(285,48) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/mil_sinrf.c(285,56) ]
   remark #15388: vectorization support: reference rhoq[i] has aligned access   [ src/mil_sinrf.c(285,64) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.593
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 23 
   remark #15477: vector cost: 6.750 
   remark #15478: estimated potential speedup: 3.250 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(284,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(284,5)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference gp5[i] has aligned access   [ src/mil_sinrf.c(285,6) ]
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(285,13) ]
   remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/mil_sinrf.c(285,23) ]
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/mil_sinrf.c(285,31) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(285,40) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(285,48) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/mil_sinrf.c(285,56) ]
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(285,64) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.069
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 45 
   remark #15477: vector cost: 16.750 
   remark #15478: estimated potential speedup: 2.660 
   remark #15487: type converts: 4 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(284,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(287,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(287,5)
   remark #15388: vectorization support: reference gp6[i] has aligned access   [ src/mil_sinrf.c(288,6) ]
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(288,14) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/mil_sinrf.c(288,25) ]
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/mil_sinrf.c(288,33) ]
   remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/mil_sinrf.c(288,42) ]
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(288,50) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(288,58) ]
   remark #15388: vectorization support: reference rhou[i] has aligned access   [ src/mil_sinrf.c(288,66) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.593
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 23 
   remark #15477: vector cost: 6.750 
   remark #15478: estimated potential speedup: 3.250 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(287,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(287,5)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference gp6[i] has aligned access   [ src/mil_sinrf.c(288,6) ]
   remark #15389: vectorization support: reference etai_2[i] has unaligned access   [ src/mil_sinrf.c(288,14) ]
   remark #15389: vectorization support: reference etav[i] has unaligned access   [ src/mil_sinrf.c(288,25) ]
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/mil_sinrf.c(288,33) ]
   remark #15389: vectorization support: reference etau[i] has unaligned access   [ src/mil_sinrf.c(288,42) ]
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(288,50) ]
   remark #15389: vectorization support: reference etaq[i] has unaligned access   [ src/mil_sinrf.c(288,58) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(288,66) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.069
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 45 
   remark #15477: vector cost: 16.750 
   remark #15478: estimated potential speedup: 2.660 
   remark #15487: type converts: 4 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(287,5)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(293,4)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(293,4)
   remark #15389: vectorization support: reference gp4_gp2_rhoq[i] has unaligned access   [ src/mil_sinrf.c(294,3) ]
   remark #15389: vectorization support: reference gp4[i] has unaligned access   [ src/mil_sinrf.c(294,21) ]
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(294,28) ]
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(294,36) ]
   remark #15389: vectorization support: reference gp5_gp2_rhou[i] has unaligned access   [ src/mil_sinrf.c(295,3) ]
   remark #15389: vectorization support: reference gp5[i] has unaligned access   [ src/mil_sinrf.c(295,21) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(295,28) ]
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(295,36) ]
   remark #15388: vectorization support: reference gp6_gp2_rhov[i] has aligned access   [ src/mil_sinrf.c(296,3) ]
   remark #15389: vectorization support: reference gp6[i] has unaligned access   [ src/mil_sinrf.c(296,21) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(296,28) ]
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(296,36) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.487
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15451: unmasked unaligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 32 
   remark #15477: vector cost: 9.750 
   remark #15478: estimated potential speedup: 3.140 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(293,4)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(293,4)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference gp4_gp2_rhoq[i] has unaligned access   [ src/mil_sinrf.c(294,3) ]
   remark #15389: vectorization support: reference gp4[i] has unaligned access   [ src/mil_sinrf.c(294,21) ]
   remark #15389: vectorization support: reference rhoq[i] has unaligned access   [ src/mil_sinrf.c(294,28) ]
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(294,36) ]
   remark #15389: vectorization support: reference gp5_gp2_rhou[i] has unaligned access   [ src/mil_sinrf.c(295,3) ]
   remark #15389: vectorization support: reference gp5[i] has unaligned access   [ src/mil_sinrf.c(295,21) ]
   remark #15389: vectorization support: reference rhou[i] has unaligned access   [ src/mil_sinrf.c(295,28) ]
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(295,36) ]
   remark #15389: vectorization support: reference gp6_gp2_rhov[i] has unaligned access   [ src/mil_sinrf.c(296,3) ]
   remark #15389: vectorization support: reference gp6[i] has unaligned access   [ src/mil_sinrf.c(296,21) ]
   remark #15389: vectorization support: reference rhov[i] has unaligned access   [ src/mil_sinrf.c(296,28) ]
   remark #15388: vectorization support: reference gp2[i] has aligned access   [ src/mil_sinrf.c(296,36) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.881
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 45 
   remark #15477: vector cost: 16.750 
   remark #15478: estimated potential speedup: 2.660 
   remark #15487: type converts: 4 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(293,4)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(299,5)
<Predicate Optimized v1>
   remark #25045: Fused Loops: ( 299 302 )

   remark #25422: Invariant Condition at line 310 hoisted out of this loop
   remark #15388: vectorization support: reference dtiaux[i] has aligned access   [ src/mil_sinrf.c(300,3) ]
   remark #15389: vectorization support: reference dti[i] has unaligned access   [ src/mil_sinrf.c(300,15) ]
   remark #15389: vectorization support: reference spectra[i] has unaligned access   [ src/mil_sinrf.c(303,6) ]
   remark #15388: vectorization support: reference dtiaux[i] has aligned access   [ src/mil_sinrf.c(303,22) ]
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/mil_sinrf.c(303,32) ]
   remark #15389: vectorization support: reference gp3[i] has unaligned access   [ src/mil_sinrf.c(303,40) ]
   remark #15389: vectorization support: reference spectra[i+nlambda] has unaligned access   [ src/mil_sinrf.c(305,9) ]
   remark #15388: vectorization support: reference dtiaux[i] has aligned access   [ src/mil_sinrf.c(305,28) ]
   remark #15389: vectorization support: reference gp4_gp2_rhoq[i] has unaligned access   [ src/mil_sinrf.c(305,39) ]
   remark #15389: vectorization support: reference spectra[i+nlambda*2] has unaligned access   [ src/mil_sinrf.c(307,9) ]
   remark #15388: vectorization support: reference dtiaux[i] has aligned access   [ src/mil_sinrf.c(307,30) ]
   remark #15389: vectorization support: reference gp5_gp2_rhou[i] has unaligned access   [ src/mil_sinrf.c(307,41) ]
   remark #15389: vectorization support: reference spectra[i+nlambda*3] has unaligned access   [ src/mil_sinrf.c(309,9) ]
   remark #15388: vectorization support: reference dtiaux[i] has aligned access   [ src/mil_sinrf.c(309,30) ]
   remark #15389: vectorization support: reference gp6_gp2_rhov[i] has unaligned access   [ src/mil_sinrf.c(309,41) ]
   remark #15389: vectorization support: reference spectra_mc[i] has unaligned access   [ src/mil_sinrf.c(311,4) ]
   remark #15389: vectorization support: reference spectra[i] has unaligned access   [ src/mil_sinrf.c(311,20) ]
   remark #15389: vectorization support: reference spectra_mc[i+nlambda] has unaligned access   [ src/mil_sinrf.c(312,4) ]
   remark #15389: vectorization support: reference spectra[i+nlambda] has unaligned access   [ src/mil_sinrf.c(312,27) ]
   remark #15389: vectorization support: reference spectra_mc[i+nlambda*2] has unaligned access   [ src/mil_sinrf.c(313,4) ]
   remark #15389: vectorization support: reference spectra[i+nlambda*2] has unaligned access   [ src/mil_sinrf.c(313,25) ]
   remark #15389: vectorization support: reference spectra_mc[i+nlambda*3] has unaligned access   [ src/mil_sinrf.c(314,4) ]
   remark #15389: vectorization support: reference spectra[i+nlambda*3] has unaligned access   [ src/mil_sinrf.c(314,27) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.626
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/mil_sinrf.c(300,3) ]
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(300,3) ]
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/mil_sinrf.c(303,6) ]
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(303,6) ]
   remark #15301: FUSED LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 10 
   remark #15451: unmasked unaligned unit stride stores: 8 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 63 
   remark #15477: vector cost: 24.750 
   remark #15478: estimated potential speedup: 2.520 
   remark #15487: type converts: 4 
   remark #15488: --- end vector cost summary ---
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
LOOP END

LOOP BEGIN at src/mil_sinrf.c(302,5)
   remark #25046: Loop lost in Fusion 
LOOP END

LOOP BEGIN at src/mil_sinrf.c(299,5)
<Remainder loop for vectorization, Predicate Optimized v1>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(299,5)
<Predicate Optimized v2>
   remark #15388: vectorization support: reference dtiaux[i] has aligned access   [ src/mil_sinrf.c(300,3) ]
   remark #15389: vectorization support: reference dti[i] has unaligned access   [ src/mil_sinrf.c(300,15) ]
   remark #15389: vectorization support: reference spectra[i] has unaligned access   [ src/mil_sinrf.c(303,6) ]
   remark #15388: vectorization support: reference dtiaux[i] has aligned access   [ src/mil_sinrf.c(303,22) ]
   remark #15389: vectorization support: reference etai[i] has unaligned access   [ src/mil_sinrf.c(303,32) ]
   remark #15389: vectorization support: reference gp3[i] has unaligned access   [ src/mil_sinrf.c(303,40) ]
   remark #15389: vectorization support: reference spectra[i+nlambda] has unaligned access   [ src/mil_sinrf.c(305,9) ]
   remark #15388: vectorization support: reference dtiaux[i] has aligned access   [ src/mil_sinrf.c(305,28) ]
   remark #15389: vectorization support: reference gp4_gp2_rhoq[i] has unaligned access   [ src/mil_sinrf.c(305,39) ]
   remark #15389: vectorization support: reference spectra[i+nlambda*2] has unaligned access   [ src/mil_sinrf.c(307,9) ]
   remark #15388: vectorization support: reference dtiaux[i] has aligned access   [ src/mil_sinrf.c(307,30) ]
   remark #15389: vectorization support: reference gp5_gp2_rhou[i] has unaligned access   [ src/mil_sinrf.c(307,41) ]
   remark #15389: vectorization support: reference spectra[i+nlambda*3] has unaligned access   [ src/mil_sinrf.c(309,9) ]
   remark #15388: vectorization support: reference dtiaux[i] has aligned access   [ src/mil_sinrf.c(309,30) ]
   remark #15389: vectorization support: reference gp6_gp2_rhov[i] has unaligned access   [ src/mil_sinrf.c(309,41) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.567
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/mil_sinrf.c(300,3) ]
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(300,3) ]
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/mil_sinrf.c(303,6) ]
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(303,6) ]
   remark #15301: FUSED LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 6 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 45 
   remark #15477: vector cost: 16.750 
   remark #15478: estimated potential speedup: 2.660 
   remark #15487: type converts: 4 
   remark #15488: --- end vector cost summary ---
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
LOOP END

LOOP BEGIN at src/mil_sinrf.c(299,5)
<Remainder loop for vectorization, Predicate Optimized v2>
LOOP END

LOOP BEGIN at src/fgauss.c(31,2) inlined into src/mil_sinrf.c(327,6)
   remark #25045: Fused Loops: ( 31 75 )

   remark #15389: vectorization support: reference lambda[i] has unaligned access   [ src/fgauss.c(33,21) ]
   remark #15388: vectorization support: reference term[i] has aligned access   [ src/fgauss.c(34,3) ]
   remark #15388: vectorization support: reference term[i] has aligned access   [ src/fgauss.c(78,19) ]
   remark #15389: vectorization support: reference GMAC[i] has unaligned access   [ src/fgauss.c(78,4) ]
   remark #15389: vectorization support: reference GMAC[i] has unaligned access   [ src/fgauss.c(80,4) ]
   remark #15389: vectorization support: reference GMAC[i] has unaligned access   [ src/fgauss.c(78,4) ]
   remark #15389: vectorization support: reference GMAC[i] has unaligned access   [ src/fgauss.c(80,4) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.130
   remark #15301: FUSED LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 2 
   remark #15451: unmasked unaligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 134 
   remark #15477: vector cost: 77.000 
   remark #15478: estimated potential speedup: 1.730 
   remark #15482: vectorized math library calls: 1 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(75,2) inlined into src/mil_sinrf.c(327,6)
   remark #25046: Loop lost in Fusion 
LOOP END

LOOP BEGIN at src/fgauss.c(31,2) inlined into src/mil_sinrf.c(327,6)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/fgauss.c(85,2) inlined into src/mil_sinrf.c(327,6)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/fgauss.c(85,2) inlined into src/mil_sinrf.c(327,6)
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/fgauss.c(87,10) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 1.450
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 6 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 2.260 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(85,2) inlined into src/mil_sinrf.c(327,6)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/fgauss.c(89,2) inlined into src/mil_sinrf.c(327,6)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/fgauss.c(89,2) inlined into src/mil_sinrf.c(327,6)
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/fgauss.c(91,3) ]
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/fgauss.c(91,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.086
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 31 
   remark #15477: vector cost: 17.500 
   remark #15478: estimated potential speedup: 1.740 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(89,2) inlined into src/mil_sinrf.c(327,6)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/fgauss.c(91,3) ]
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/fgauss.c(91,3) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.343
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 31 
   remark #15477: vector cost: 17.500 
   remark #15478: estimated potential speedup: 1.740 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/fgauss.c(89,2) inlined into src/mil_sinrf.c(327,6)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(334,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/mil_sinrf.c(334,5)
   remark #15388: vectorization support: reference inPSF_MAC[i] has aligned access   [ src/mil_sinrf.c(335,6) ]
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/mil_sinrf.c(335,22) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.438
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 14 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 3.340 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(334,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(334,5)
<Remainder loop for vectorization>
   remark #15516: remainder loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 74 
   remark #15477: vector cost: 14.000 
   remark #15478: estimated potential speedup: 5.260 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(338,5)
   remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 74 
   remark #15477: vector cost: 14.000 
   remark #15478: estimated potential speedup: 5.260 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 8  
LOOP END

LOOP BEGIN at src/mil_sinrf.c(338,5)
<Remainder>
   remark #25436: completely unrolled by 7  
LOOP END

LOOP BEGIN at src/mil_sinrf.c(342,5)
   remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 20 
   remark #15477: vector cost: 5.000 
   remark #15478: estimated potential speedup: 3.960 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 8  
LOOP END

LOOP BEGIN at src/mil_sinrf.c(342,5)
<Remainder>
   remark #25436: completely unrolled by 7  
LOOP END

LOOP BEGIN at src/mil_sinrf.c(345,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between inFilterMAC[ishift] (346:6) and outConvFilters[i] (346:6)
   remark #15346: vector dependence: assumed ANTI dependence between outConvFilters[i] (346:6) and inFilterMAC[ishift] (346:6)
LOOP END

LOOP BEGIN at src/mil_sinrf.c(351,5)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/mil_sinrf.c(351,5)
   remark #15388: vectorization support: reference inFilterMAC[i] has aligned access   [ src/mil_sinrf.c(352,6) ]
   remark #15388: vectorization support: reference GMAC[i] has aligned access   [ src/mil_sinrf.c(352,23) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.438
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 14 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 3.340 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(351,5)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(351,5)
<Remainder loop for vectorization>
   remark #15516: remainder loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 14 
   remark #15477: vector cost: 4.000 
   remark #15478: estimated potential speedup: 3.340 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(358,4)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/mil_sinrf.c(359,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(359,5)
      remark #15388: vectorization support: reference inSpectraFwMAC[i] has aligned access   [ src/mil_sinrf.c(360,6) ]
      remark #15388: vectorization support: reference spectra[nlambda*il+i] has aligned access   [ src/mil_sinrf.c(360,26) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.389
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 15 
      remark #15477: vector cost: 4.500 
      remark #15478: estimated potential speedup: 3.200 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(359,5)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(359,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference inSpectraFwMAC[i] has aligned access   [ src/mil_sinrf.c(360,6) ]
      remark #15389: vectorization support: reference spectra[nlambda*il+i] has unaligned access   [ src/mil_sinrf.c(360,26) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.083
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(359,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(363,5)
      remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 133 
      remark #15477: vector cost: 16.000 
      remark #15478: estimated potential speedup: 8.270 
      remark #15488: --- end vector cost summary ---
      remark #25439: unrolled with remainder by 8  
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(368,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(368,5)
      remark #15388: vectorization support: reference spectra[ishift+il*nlambda] has aligned access   [ src/mil_sinrf.c(369,6) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.326
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(369,6) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(368,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference spectra[ishift+il*nlambda] has aligned access   [ src/mil_sinrf.c(369,6) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.182
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(369,6) ]
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(368,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(371,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(371,5)
      remark #15388: vectorization support: reference spectra[ishift+il*nlambda] has aligned access   [ src/mil_sinrf.c(372,6) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.326
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(372,6) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(371,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference spectra[ishift+il*nlambda] has aligned access   [ src/mil_sinrf.c(372,6) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.182
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(372,6) ]
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(371,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(363,5)
   <Remainder>
      remark #25436: completely unrolled by 7  
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(44,2) inlined into src/mil_sinrf.c(380,5)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(44,2) inlined into src/mil_sinrf.c(380,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(44,2) inlined into src/mil_sinrf.c(380,5)
      remark #15388: vectorization support: reference dirConvPar[k] has aligned access   [ src/convolution.c(46,3) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 1.260 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/convolution.c(44,2) inlined into src/mil_sinrf.c(380,5)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(49,2) inlined into src/mil_sinrf.c(380,5)
   remark #25399: memcopy generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/mil_sinrf.c(380,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/mil_sinrf.c(380,5)
      remark #15388: vectorization support: reference dirConvPar[k+mitad_nh] has aligned access   [ src/convolution.c(51,3) ]
      remark #15388: vectorization support: reference GMAC[k] has aligned access   [ src/convolution.c(51,30) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 4.667
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 5 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 1.530 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/mil_sinrf.c(380,5)
   <Alternate Alignment Vectorized Loop>
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at src/convolution.c(49,2) inlined into src/mil_sinrf.c(380,5)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(56,2) inlined into src/mil_sinrf.c(380,5)
<Distributed chunk1>
   remark #25087: Preprocess Loopnests: Sinking 1 Stmts Into Inner LOOP to Create Perfect Nest 
   remark #25426: Loop Distributed (2 way) 
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(56,2) inlined into src/mil_sinrf.c(380,5)
   <Peeled loop for vectorization, Distributed chunk1>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(56,2) inlined into src/mil_sinrf.c(380,5)
   <Distributed chunk1>
      remark #15388: vectorization support: reference GMAC[k] has aligned access   [ src/convolution.c(64,3) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15301: PARTIAL LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 1.260 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/convolution.c(56,2) inlined into src/mil_sinrf.c(380,5)
   <Remainder loop for vectorization, Distributed chunk1>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(56,2) inlined into src/mil_sinrf.c(380,5)
<Distributed chunk2>
   remark #25440: unrolled and jammed by 2   (pre-vector) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/mil_sinrf.c(380,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/mil_sinrf.c(380,5)
      remark #25085: Preprocess Loopnests: Moving Out Load and Store    [ src/convolution.c(62,4) ]
      remark #25085: Preprocess Loopnests: Moving Out Load and Store    [ src/convolution.c(62,4) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(62,18) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(62,18) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.867
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 18 
      remark #15477: vector cost: 7.500 
      remark #15478: estimated potential speedup: 2.300 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/mil_sinrf.c(380,5)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/mil_sinrf.c(380,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(62,18) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(62,18) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 3.000
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 3.500 
      remark #15478: estimated potential speedup: 2.440 
      remark #15488: --- end vector cost summary ---
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(56,2) inlined into src/mil_sinrf.c(380,5)
<Remainder, Distributed chunk2>
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/mil_sinrf.c(380,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/mil_sinrf.c(380,5)
      remark #25085: Preprocess Loopnests: Moving Out Load and Store    [ src/convolution.c(62,4) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(62,11) ]
      remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(62,18) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 1.179
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 3.500 
      remark #15478: estimated potential speedup: 2.440 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/mil_sinrf.c(380,5)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/convolution.c(60,3) inlined into src/mil_sinrf.c(380,5)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/mil_sinrf.c(398,4)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 1 3 2 ) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(210,2) inlined into src/mil_sinrf.c(399,5)
      remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
      remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(212,6) inlined into src/mil_sinrf.c(399,5)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/convolution.c(212,6) inlined into src/mil_sinrf.c(399,5)
         remark #15388: vectorization support: reference GMAC[j] has aligned access   [ src/convolution.c(216,11) ]
         remark #15328: vectorization support: irregularly indexed load was emulated for the variable <x[mod]>, part of index is nonlinearly computed   [ src/convolution.c(216,18) ]
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.744
         remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/convolution.c(211,3) ]
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15462: unmasked indexed (or gather) loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 29 
         remark #15477: vector cost: 10.750 
         remark #15478: estimated potential speedup: 2.610 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/convolution.c(212,6) inlined into src/mil_sinrf.c(399,5)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/mil_sinrf.c(405,3)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/mil_sinrf.c(405,3)
   remark #15389: vectorization support: reference spectra[i] has unaligned access   [ src/mil_sinrf.c(406,4) ]
   remark #15389: vectorization support: reference spectra[i] has unaligned access   [ src/mil_sinrf.c(406,17) ]
   remark #15388: vectorization support: reference slight[i] has aligned access   [ src/mil_sinrf.c(406,32) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.417
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/mil_sinrf.c(406,4) ]
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(406,4) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 17 
   remark #15477: vector cost: 6.000 
   remark #15478: estimated potential speedup: 2.730 
   remark #15487: type converts: 2 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(405,3)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference spectra[i] has unaligned access   [ src/mil_sinrf.c(406,4) ]
   remark #15389: vectorization support: reference spectra[i] has unaligned access   [ src/mil_sinrf.c(406,17) ]
   remark #15388: vectorization support: reference slight[i] has aligned access   [ src/mil_sinrf.c(406,32) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 1.667
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/mil_sinrf.c(406,4) ]
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(406,4) ]
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 17 
   remark #15477: vector cost: 6.000 
   remark #15478: estimated potential speedup: 2.730 
   remark #15487: type converts: 2 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(405,3)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(418,4)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/mil_sinrf.c(419,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(419,5)
      remark #15388: vectorization support: reference inSpectraFwPSF[j] has aligned access   [ src/mil_sinrf.c(420,6) ]
      remark #15388: vectorization support: reference spectra[nlambda*i+j] has aligned access   [ src/mil_sinrf.c(420,26) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.389
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 15 
      remark #15477: vector cost: 4.500 
      remark #15478: estimated potential speedup: 3.200 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(419,5)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(419,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference inSpectraFwPSF[j] has aligned access   [ src/mil_sinrf.c(420,6) ]
      remark #15389: vectorization support: reference spectra[nlambda*i+j] has unaligned access   [ src/mil_sinrf.c(420,26) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.083
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(419,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(424,5)
      remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 74 
      remark #15477: vector cost: 14.000 
      remark #15478: estimated potential speedup: 5.260 
      remark #15488: --- end vector cost summary ---
      remark #25439: unrolled with remainder by 8  
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(429,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(429,5)
      remark #15388: vectorization support: reference spectra[ishift+i*nlambda] has aligned access   [ src/mil_sinrf.c(430,6) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.326
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(430,6) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(429,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference spectra[ishift+i*nlambda] has aligned access   [ src/mil_sinrf.c(430,6) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.182
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(430,6) ]
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(429,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(432,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(432,5)
      remark #15388: vectorization support: reference spectra[ishift+i*nlambda] has aligned access   [ src/mil_sinrf.c(433,6) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.326
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(433,6) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(432,5)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference spectra[ishift+i*nlambda] has aligned access   [ src/mil_sinrf.c(433,6) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.182
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(433,6) ]
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 12 
      remark #15477: vector cost: 5.750 
      remark #15478: estimated potential speedup: 2.030 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(432,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(424,5)
   <Remainder>
      remark #25436: completely unrolled by 7  
   LOOP END
LOOP END

LOOP BEGIN at src/mil_sinrf.c(445,4)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(445,4)
   remark #15388: vectorization support: reference spectra[i] has aligned access   [ src/mil_sinrf.c(446,5) ]
   remark #15388: vectorization support: reference spectra[i] has aligned access   [ src/mil_sinrf.c(446,23) ]
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 1.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 7 
   remark #15477: vector cost: 1.250 
   remark #15478: estimated potential speedup: 5.100 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(445,4)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/convolution.c(79,2) inlined into src/mil_sinrf.c(448,4)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(79,2) inlined into src/mil_sinrf.c(448,4)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(79,2) inlined into src/mil_sinrf.c(448,4)
      remark #15388: vectorization support: reference dirConvPar[k] has aligned access   [ src/convolution.c(81,3) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.667
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 1.260 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/convolution.c(79,2) inlined into src/mil_sinrf.c(448,4)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(84,2) inlined into src/mil_sinrf.c(448,4)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/convolution.c(84,2) inlined into src/mil_sinrf.c(448,4)
   remark #15388: vectorization support: reference dirConvPar[k+mitad_nh] has aligned access   [ src/convolution.c(86,3) ]
   remark #15388: vectorization support: reference spectra[k] has aligned access   [ src/convolution.c(86,30) ]
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.875
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/convolution.c(86,3) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 6 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 2.850 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/convolution.c(84,2) inlined into src/mil_sinrf.c(448,4)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at src/convolution.c(84,2) inlined into src/mil_sinrf.c(448,4)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/convolution.c(91,2) inlined into src/mil_sinrf.c(448,4)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
   remark #25461: Imperfect Loop Unroll-Jammed by 2   (pre-vector) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(448,4)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(448,4)
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
      remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(97,18) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 0.867
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 18 
      remark #15477: vector cost: 7.500 
      remark #15478: estimated potential speedup: 2.300 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(448,4)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(448,4)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
      remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 3.000
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 7 
      remark #15477: vector cost: 1.250 
      remark #15478: estimated potential speedup: 5.100 
      remark #15488: --- end vector cost summary ---
   LOOP END
LOOP END

LOOP BEGIN at src/convolution.c(91,2) inlined into src/mil_sinrf.c(448,4)
<Remainder>
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(448,4)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(448,4)
      remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
      remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(97,18) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 1.179
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 3.500 
      remark #15478: estimated potential speedup: 2.440 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(448,4)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(448,4)
   <Remainder loop for vectorization>
   LOOP END
LOOP END

LOOP BEGIN at src/mil_sinrf.c(450,4)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/mil_sinrf.c(450,4)
   remark #15388: vectorization support: reference spectra[i] has aligned access   [ src/mil_sinrf.c(451,5) ]
   remark #15388: vectorization support: reference spectra[i] has aligned access   [ src/mil_sinrf.c(451,23) ]
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 1.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 7 
   remark #15477: vector cost: 1.250 
   remark #15478: estimated potential speedup: 5.100 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/mil_sinrf.c(450,4)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/mil_sinrf.c(454,4)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/convolution.c(79,2) inlined into src/mil_sinrf.c(455,5)
      remark #25408: memset generated
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(79,2) inlined into src/mil_sinrf.c(455,5)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at src/convolution.c(79,2) inlined into src/mil_sinrf.c(455,5)
         remark #15388: vectorization support: reference dirConvPar[k] has aligned access   [ src/convolution.c(81,3) ]
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 1.667
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 4 
         remark #15477: vector cost: 1.500 
         remark #15478: estimated potential speedup: 1.260 
         remark #15488: --- end vector cost summary ---
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/convolution.c(79,2) inlined into src/mil_sinrf.c(455,5)
      <Remainder loop for vectorization>
         remark #25015: Estimate of max trip count of loop=12
      LOOP END
   LOOP END

   LOOP BEGIN at src/convolution.c(84,2) inlined into src/mil_sinrf.c(455,5)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/convolution.c(84,2) inlined into src/mil_sinrf.c(455,5)
      remark #15388: vectorization support: reference dirConvPar[k+mitad_nh] has aligned access   [ src/convolution.c(86,3) ]
      remark #15388: vectorization support: reference x[k] has aligned access   [ src/convolution.c(86,30) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.875
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/convolution.c(86,3) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 6 
      remark #15477: vector cost: 2.000 
      remark #15478: estimated potential speedup: 2.850 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/convolution.c(84,2) inlined into src/mil_sinrf.c(455,5)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/convolution.c(84,2) inlined into src/mil_sinrf.c(455,5)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/convolution.c(91,2) inlined into src/mil_sinrf.c(455,5)
      remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
      remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
      remark #25461: Imperfect Loop Unroll-Jammed by 2   (pre-vector) 
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(455,5)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(455,5)
         remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
         remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(97,18) ]
         remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
         remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.867
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 2 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 18 
         remark #15477: vector cost: 7.500 
         remark #15478: estimated potential speedup: 2.300 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(455,5)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(455,5)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
         remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
         remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
         remark #15389: vectorization support: reference dirConvPar[j+k] has unaligned access   [ src/convolution.c(97,18) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 3.000
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 3.500 
         remark #15478: estimated potential speedup: 2.440 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END

   LOOP BEGIN at src/convolution.c(91,2) inlined into src/mil_sinrf.c(455,5)
   <Remainder>
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(455,5)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=1
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(455,5)
         remark #15388: vectorization support: reference G[j] has aligned access   [ src/convolution.c(97,11) ]
         remark #15388: vectorization support: reference dirConvPar[j+k] has aligned access   [ src/convolution.c(97,18) ]
         remark #15305: vectorization support: vector length 2
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 1.179
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 3.500 
         remark #15478: estimated potential speedup: 2.440 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(455,5)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/convolution.c(95,3) inlined into src/mil_sinrf.c(455,5)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

src/convolution.c(44,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(44,2):remark #34026: call to memset implemented as a call to optimized library version
src/convolution.c(49,2):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(49,2):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(49,2):remark #34026: call to memcpy implemented as a call to optimized library version
src/convolution.c(56,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(56,2):remark #34026: call to memset implemented as a call to optimized library version
src/convolution.c(79,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(79,2):remark #34026: call to memset implemented as a call to optimized library version
src/convolution.c(79,2):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
src/convolution.c(79,2):remark #34026: call to memset implemented as a call to optimized library version
src/mil_sinrf.c(62,1):remark #34051: REGISTER ALLOCATION : [mil_sinrf] src/mil_sinrf.c:62

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    3588
            Global    :     893
            Local     :    2695
        Regenerable   :      59
        Spilled       :     194
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :    1520 bytes*
            Reads     :     713 [1.98e+03 ~ 8.2%]
            Writes    :     328 [4.28e+02 ~ 1.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: funcionComponentFor_sinrf(float *, int, int, float *, float *, float *, float *, double, double)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (funcionComponentFor_sinrf(float *, int, int, float *, float *, float *, float *, double, double)) [7/70=10.0%] src/mil_sinrf.c(472,1)
  -> INLINE: (489,3) fvoigt(double, float *, int, float *, float *) (isz = 193) (sz = 208)
    -> EXTERN: src/fvoigt.c:(62,10) creal(double __complex__)
    -> EXTERN: src/fvoigt.c:(67,34) cimag(double __complex__)
    -> EXTERN: src/fvoigt.c:(67,65) cimag(double __complex__)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/mil_sinrf.c(479,2)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Distributed chunk1>
      remark #25045: Fused Loops: ( 485 21 27 34 41 48 54 60 65 491 495 )

      remark #25426: Loop Distributed (6 way) 
      remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 13 
      remark #15477: vector cost: 3.000 
      remark #15478: estimated potential speedup: 4.280 
      remark #15488: --- end vector cost summary ---
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at src/fvoigt.c(21,2) inlined into src/mil_sinrf.c(489,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/fvoigt.c(27,2) inlined into src/mil_sinrf.c(489,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/fvoigt.c(34,3) inlined into src/mil_sinrf.c(489,3)
      remark #25461: Imperfect Loop Unroll-Jammed by 6   (pre-vector) 
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/fvoigt.c(41,2) inlined into src/mil_sinrf.c(489,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/fvoigt.c(48,3) inlined into src/mil_sinrf.c(489,3)
      remark #25461: Imperfect Loop Unroll-Jammed by 6   (pre-vector) 
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/fvoigt.c(54,2) inlined into src/mil_sinrf.c(489,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/fvoigt.c(60,2) inlined into src/mil_sinrf.c(489,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/fvoigt.c(65,2) inlined into src/mil_sinrf.c(489,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(491,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(495,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Remainder, Distributed chunk1>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Peeled loop for vectorization, Distributed chunk2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Distributed chunk2>
      remark #15388: vectorization support: reference uu[j] has aligned access   [ src/mil_sinrf.c(486,4) ]
      remark #15389: vectorization support: reference u[j] has unaligned access   [ src/mil_sinrf.c(486,10) ]
      remark #15388: vectorization support: reference z[i] has aligned access   [ src/fvoigt.c(23,3) ]
      remark #15388: vectorization support: reference uu[i] has aligned access   [ src/fvoigt.c(23,17) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.659
      remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/mil_sinrf.c(486,4) ]
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/mil_sinrf.c(486,4) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 2 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 45 
      remark #15477: vector cost: 10.250 
      remark #15478: estimated potential speedup: 4.160 
      remark #15487: type converts: 3 
      remark #15488: --- end vector cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Alternate Alignment Vectorized Loop, Distributed chunk2>
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Remainder loop for vectorization, Distributed chunk2>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Distributed chunk3>
      remark #15516: loop was not vectorized: cost model has chosen vectorlength of 1 -- maybe possible to override via pragma/directive with vectorlength clause
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 382 
      remark #15477: vector cost: 209.000 
      remark #15478: estimated potential speedup: 1.820 
      remark #15488: --- end vector cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 23
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Peeled loop for vectorization, Distributed chunk4>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Distributed chunk4>
      remark #15388: vectorization support: reference H[i] has aligned access   [ src/fvoigt.c(62,3) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.289
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/fvoigt.c(62,3) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 9 
      remark #15477: vector cost: 4.750 
      remark #15478: estimated potential speedup: 1.850 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Remainder loop for vectorization, Distributed chunk4>
      remark #15388: vectorization support: reference H[i] has aligned access   [ src/fvoigt.c(62,3) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/fvoigt.c(62,3) ]
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 2 
      remark #15450: unmasked unaligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 21 
      remark #15477: vector cost: 4.500 
      remark #15478: estimated potential speedup: 4.360 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Remainder loop for vectorization, Distributed chunk4>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Peeled loop for vectorization, Distributed chunk5>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Distributed chunk5>
      remark #15388: vectorization support: reference F[i] has aligned access   [ src/fvoigt.c(67,3) ]
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.250
      remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ src/fvoigt.c(67,3) ]
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 37 
      remark #15477: vector cost: 17.000 
      remark #15478: estimated potential speedup: 2.130 
      remark #15487: type converts: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Alternate Alignment Vectorized Loop, Distributed chunk5>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Remainder loop for vectorization, Distributed chunk5>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Peeled loop for vectorization, Distributed chunk6>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Distributed chunk6>
      remark #15388: vectorization support: reference fi_x[j] has aligned access   [ src/mil_sinrf.c(492,4) ]
      remark #15388: vectorization support: reference fi_x[j] has aligned access   [ src/mil_sinrf.c(492,12) ]
      remark #15389: vectorization support: reference H[j] has unaligned access   [ src/mil_sinrf.c(492,27) ]
      remark #15388: vectorization support: reference shi_x[j] has aligned access   [ src/mil_sinrf.c(496,4) ]
      remark #15388: vectorization support: reference shi_x[j] has aligned access   [ src/mil_sinrf.c(496,14) ]
      remark #15389: vectorization support: reference F[j] has unaligned access   [ src/mil_sinrf.c(496,31) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.722
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 2 
      remark #15450: unmasked unaligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 21 
      remark #15477: vector cost: 4.500 
      remark #15478: estimated potential speedup: 4.360 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Alternate Alignment Vectorized Loop, Distributed chunk6>
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Remainder loop for vectorization, Distributed chunk6>
      remark #15389: vectorization support: reference fi_x[j] has unaligned access   [ src/mil_sinrf.c(492,4) ]
      remark #15389: vectorization support: reference fi_x[j] has unaligned access   [ src/mil_sinrf.c(492,12) ]
      remark #15389: vectorization support: reference H[j] has unaligned access   [ src/mil_sinrf.c(492,27) ]
      remark #15388: vectorization support: reference shi_x[j] has aligned access   [ src/mil_sinrf.c(496,4) ]
      remark #15388: vectorization support: reference shi_x[j] has aligned access   [ src/mil_sinrf.c(496,14) ]
      remark #15389: vectorization support: reference F[j] has unaligned access   [ src/mil_sinrf.c(496,31) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 1.217
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 2 
      remark #15450: unmasked unaligned unit stride loads: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 21 
      remark #15477: vector cost: 4.500 
      remark #15478: estimated potential speedup: 4.360 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/mil_sinrf.c(485,3)
   <Remainder loop for vectorization, Distributed chunk6>
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

src/fvoigt.c(56,20):remark #34046: complex divide implemented using x87 instructions to maintain precision.
src/fvoigt.c(56,20):remark #34048: consider using complex-limited-range option to boost run time performance.
src/mil_sinrf.c(472,1):remark #34051: REGISTER ALLOCATION : [funcionComponentFor_sinrf] src/mil_sinrf.c:472

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   38[ rax rdx rcx rbx rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        
    Routine temporaries
        Total         :     475
            Global    :     131
            Local     :     344
        Regenerable   :      26
        Spilled       :      31
        
    Routine stack
        Variables     :       8 bytes*
            Reads     :       6 [1.50e+02 ~ 1.2%]
            Writes    :       6 [1.50e+02 ~ 1.2%]
        Spills        :     216 bytes*
            Reads     :      42 [1.52e+02 ~ 1.2%]
            Writes    :      29 [6.22e+01 ~ 0.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: covarm(float *, float *, float *, int, float *, float *, float *, float *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (covarm(float *, float *, float *, int, float *, float *, float *, float *)) [8/70=11.4%] src/lib.c(33,112)
  -> INLINE: (50,3) multmatrixIDLValue(float *, int, int, float *, int, int, float *, int *, int *, float) (isz = 51) (sz = 77)
    -> EXTERN: (121,3) printf(const char *__restrict__, ...)
  -> INLINE: (51,3) multmatrix_transpose(float *, int, int, float *, int, int, float *, int *, int *, float) (isz = 52) (sz = 78)
    -> EXTERN: (222,3) printf(const char *__restrict__, ...)
  -> INLINE: (54,2) totalParcialf(float *, int, int, float *) (isz = 27) (sz = 38)
  -> INLINE: (55,2) totalParcialMatrixf(float *, int, int, int, float *) (isz = 41) (sz = 54)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/lib.c(42,2)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ src/lib.c(50,3) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ src/lib.c(51,3) ]
   remark #25084: Preprocess Loopnests: Moving Out Store    [ src/lib.c(51,3) ]
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/lib.c(43,3)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/lib.c(43,3)
      remark #15388: vectorization support: reference opa[i] has aligned access   [ src/lib.c(44,4) ]
      remark #15389: vectorization support: reference spectra[i+nspectro*j] has unaligned access   [ src/lib.c(44,17) ]
      remark #15388: vectorization support: reference spectro[i+nspectro*j] has aligned access   [ src/lib.c(44,39) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 1.111
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 10 
      remark #15477: vector cost: 2.250 
      remark #15478: estimated potential speedup: 4.130 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/lib.c(43,3)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/lib.c(43,3)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference opa[i] has aligned access   [ src/lib.c(44,4) ]
      remark #15389: vectorization support: reference spectra[i+nspectro*j] has unaligned access   [ src/lib.c(44,17) ]
      remark #15389: vectorization support: reference spectro[i+nspectro*j] has unaligned access   [ src/lib.c(44,39) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 1.727
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15450: unmasked unaligned unit stride loads: 4 
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 24 
      remark #15477: vector cost: 8.000 
      remark #15478: estimated potential speedup: 1.650 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/lib.c(43,3)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/lib.c(107,3) inlined into src/lib.c(50,3)
      remark #25461: Imperfect Loop Unroll-Jammed by 2   (pre-vector) 
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/lib.c(110,5) inlined into src/lib.c(50,3)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/lib.c(110,5) inlined into src/lib.c(50,3)
         remark #15388: vectorization support: reference opa[k] has aligned access   [ src/lib.c(112,13) ]
         remark #15389: vectorization support: reference b[i*nspectro+k] has unaligned access   [ src/lib.c(112,26) ]
         remark #15388: vectorization support: reference opa[k] has aligned access   [ src/lib.c(112,13) ]
         remark #15388: vectorization support: reference b[i*nspectro+k] has aligned access   [ src/lib.c(112,26) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 2.469
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 2 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 16 
         remark #15477: vector cost: 4.000 
         remark #15478: estimated potential speedup: 3.610 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/lib.c(110,5) inlined into src/lib.c(50,3)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/lib.c(110,5) inlined into src/lib.c(50,3)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at src/lib.c(107,3) inlined into src/lib.c(50,3)
   <Remainder>
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/lib.c(110,5) inlined into src/lib.c(50,3)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at src/lib.c(110,5) inlined into src/lib.c(50,3)
         remark #15388: vectorization support: reference opa[k] has aligned access   [ src/lib.c(112,13) ]
         remark #15388: vectorization support: reference b[i*nspectro+k] has aligned access   [ src/lib.c(112,26) ]
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 3.214
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 8 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.030 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at src/lib.c(110,5) inlined into src/lib.c(50,3)
      <Alternate Alignment Vectorized Loop>
      LOOP END

      LOOP BEGIN at src/lib.c(110,5) inlined into src/lib.c(50,3)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at src/lib.c(209,3) inlined into src/lib.c(51,3)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at src/lib.c(210,7) inlined into src/lib.c(51,3)
         remark #25461: Imperfect Loop Unroll-Jammed by 2   (pre-vector) 
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at src/lib.c(212,5) inlined into src/lib.c(51,3)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at src/lib.c(212,5) inlined into src/lib.c(51,3)
            remark #15388: vectorization support: reference a[i*nspectro+k] has aligned access   [ src/lib.c(213,13) ]
            remark #15389: vectorization support: reference b[j*nspectro+k] has unaligned access   [ src/lib.c(213,26) ]
            remark #15388: vectorization support: reference a[i*nspectro+k] has aligned access   [ src/lib.c(213,13) ]
            remark #15388: vectorization support: reference b[j*nspectro+k] has aligned access   [ src/lib.c(213,26) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 2.469
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 2 
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 16 
            remark #15477: vector cost: 4.000 
            remark #15478: estimated potential speedup: 3.610 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at src/lib.c(212,5) inlined into src/lib.c(51,3)
         <Alternate Alignment Vectorized Loop>
         LOOP END

         LOOP BEGIN at src/lib.c(212,5) inlined into src/lib.c(51,3)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END

      LOOP BEGIN at src/lib.c(210,7) inlined into src/lib.c(51,3)
      <Remainder>
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at src/lib.c(212,5) inlined into src/lib.c(51,3)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at src/lib.c(212,5) inlined into src/lib.c(51,3)
            remark #15388: vectorization support: reference a[i*nspectro+k] has aligned access   [ src/lib.c(213,13) ]
            remark #15388: vectorization support: reference b[j*nspectro+k] has aligned access   [ src/lib.c(213,26) ]
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 3.214
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 2 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 8 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 4.030 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at src/lib.c(212,5) inlined into src/lib.c(51,3)
         <Alternate Alignment Vectorized Loop>
         LOOP END

         LOOP BEGIN at src/lib.c(212,5) inlined into src/lib.c(51,3)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/lib.c(130,2) inlined into src/lib.c(54,2)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
   remark #15388: vectorization support: reference BT[j*11+i] has aligned access   [ src/lib.c(54,16) ]
   remark #15389: vectorization support: reference BT[j*11+i] has unaligned access   [ src/lib.c(54,16) ]
   remark #15389: vectorization support: reference BT[j*11+i] has unaligned access   [ src/lib.c(54,16) ]
   remark #15389: vectorization support: reference BT[j*11+i] has unaligned access   [ src/lib.c(54,16) ]
   remark #15389: vectorization support: reference beta[i] has unaligned access   [ src/lib.c(135,3) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.387
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15450: unmasked unaligned unit stride loads: 3 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 24 
   remark #15477: vector cost: 7.750 
   remark #15478: estimated potential speedup: 1.800 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=2

   LOOP BEGIN at src/lib.c(132,3) inlined into src/lib.c(54,2)
      remark #25436: completely unrolled by 4   (pre-vector) 
   LOOP END
LOOP END

LOOP BEGIN at src/lib.c(130,2) inlined into src/lib.c(54,2)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 3  
LOOP END

LOOP BEGIN at src/lib.c(144,2) inlined into src/lib.c(55,2)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/lib.c(145,3) inlined into src/lib.c(55,2)
      remark #15389: vectorization support: reference AP[i*11+j+121*k] has unaligned access   [ src/lib.c(55,22) ]
      remark #15389: vectorization support: reference AP[i*11+j+121*k] has unaligned access   [ src/lib.c(55,22) ]
      remark #15389: vectorization support: reference AP[i*11+j+121*k] has unaligned access   [ src/lib.c(55,22) ]
      remark #15389: vectorization support: reference AP[i*11+j+121*k] has unaligned access   [ src/lib.c(55,22) ]
      remark #15389: vectorization support: reference alpha[i*11+j] has unaligned access   [ src/lib.c(149,4) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.750
      remark #15300: LOOP WAS VECTORIZED
      remark #15450: unmasked unaligned unit stride loads: 4 
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 24 
      remark #15477: vector cost: 8.000 
      remark #15478: estimated potential speedup: 1.650 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=2

      LOOP BEGIN at src/lib.c(147,4) inlined into src/lib.c(55,2)
         remark #25436: completely unrolled by 4   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at src/lib.c(145,3) inlined into src/lib.c(55,2)
   <Remainder loop for vectorization>
      remark #25436: completely unrolled by 3  
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

src/lib.c(33,112):remark #34051: REGISTER ALLOCATION : [covarm] src/lib.c:33

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   25[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm10]
        
    Routine temporaries
        Total         :     399
            Global    :     121
            Local     :     278
        Regenerable   :      11
        Spilled       :      47
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     328 bytes*
            Reads     :      94 [2.68e+03 ~ 2.3%]
            Writes    :      62 [7.88e+02 ~ 0.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: estimacionesClasicas(double, double *, int, float *, Init_Model *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (estimacionesClasicas(double, double *, int, float *, Init_Model *, int)) [9/70=12.9%] src/milosUtils.c(406,1)
  -> EXTERN: (501,14) atan(double)
  -> EXTERN: (529,9) atan(double)
  -> EXTERN: (542,22) cos(double)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/milosUtils.c(436,2)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/milosUtils.c(436,2)
   remark #25427: Loop Statements Reordered
   remark #15389: vectorization support: reference spectro[i] has unaligned access   [ src/milosUtils.c(439,20) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/milosUtils.c(441,26) ]
   remark #15389: vectorization support: reference spectro[i] has unaligned access   [ src/milosUtils.c(438,16) ]
   remark #15389: vectorization support: reference spectroV[i] has unaligned access   [ src/milosUtils.c(438,30) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/milosUtils.c(440,16) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 2.548
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(439,3) ]
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(438,3) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15450: unmasked unaligned unit stride loads: 3 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 51 
   remark #15477: vector cost: 21.000 
   remark #15478: estimated potential speedup: 2.360 
   remark #15487: type converts: 2 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosUtils.c(436,2)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/milosUtils.c(454,2)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at src/milosUtils.c(454,2)
   remark #15389: vectorization support: reference spectro[i] has unaligned access   [ src/milosUtils.c(456,16) ]
   remark #15389: vectorization support: reference spectroV[i] has unaligned access   [ src/milosUtils.c(456,30) ]
   remark #15388: vectorization support: reference lambda[i] has aligned access   [ src/milosUtils.c(457,16) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 2.727
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(438,3) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15450: unmasked unaligned unit stride loads: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 27 
   remark #15477: vector cost: 11.000 
   remark #15478: estimated potential speedup: 2.380 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosUtils.c(454,2)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/milosUtils.c(487,2)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/milosUtils.c(487,2)
   remark #15388: vectorization support: reference spectroV[i] has aligned access   [ src/milosUtils.c(492,11) ]
   remark #15389: vectorization support: reference lambda[i] has unaligned access   [ src/milosUtils.c(490,18) ]
   remark #15389: vectorization support: reference spectroQ[i] has unaligned access   [ src/milosUtils.c(489,7) ]
   remark #15389: vectorization support: reference spectroQ[i] has unaligned access   [ src/milosUtils.c(489,7) ]
   remark #15389: vectorization support: reference spectroU[i] has unaligned access   [ src/milosUtils.c(489,7) ]
   remark #15389: vectorization support: reference spectroU[i] has unaligned access   [ src/milosUtils.c(489,7) ]
   remark #15388: vectorization support: reference spectroV[i] has aligned access   [ src/milosUtils.c(493,11) ]
   remark #15388: vectorization support: reference spectroV[i] has aligned access   [ src/milosUtils.c(493,31) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.705
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 2   [ src/milosUtils.c(432,2) ]
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(433,2) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15450: unmasked unaligned unit stride loads: 3 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 98 
   remark #15477: vector cost: 23.750 
   remark #15478: estimated potential speedup: 3.920 
   remark #15487: type converts: 3 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosUtils.c(487,2)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/milosUtils.c(522,2)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/milosUtils.c(522,2)
   remark #15388: vectorization support: reference spectroU[i] has aligned access   [ src/milosUtils.c(524,13) ]
   remark #15389: vectorization support: reference spectroQ[i] has unaligned access   [ src/milosUtils.c(525,13) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.245
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(523,24) ]
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(523,52) ]
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(521,15) ]
   remark #15417: vectorization support: number of FP up converts: single precision to double precision 1   [ src/milosUtils.c(521,27) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15456: masked unaligned unit stride loads: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 66 
   remark #15477: vector cost: 55.000 
   remark #15478: estimated potential speedup: 1.190 
   remark #15487: type converts: 5 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/milosUtils.c(522,2)
<Remainder loop for vectorization>
LOOP END

    Report from: Code generation optimizations [cg]

src/milosUtils.c(406,1):remark #34051: REGISTER ALLOCATION : [estimacionesClasicas] src/milosUtils.c:406

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   29[ rax rdx rcx rbx rsi rdi r8-r13 r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     443
            Global    :     129
            Local     :     314
        Regenerable   :      35
        Spilled       :      15
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      88 bytes*
            Reads     :      32 [2.89e+01 ~ 1.4%]
            Writes    :      27 [1.95e+01 ~ 0.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: readFitsSpectroImage..1(const char *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (readFitsSpectroImage..1(const char *, int)) [10/70=14.3%] src/utilsFits.c(267,82)
  CLONED FROM: readFitsSpectroImage(const char *, int)(X,0)
  -> EXTERN: (269,25) malloc(size_t)
  -> EXTERN: (273,19) ?1memcpy
  -> EXTERN: (278,9) ffopentest(int, fitsfile **, const char *, int, int *)
  -> EXTERN: (281,7) ffghdt(fitsfile *, int *, int *)
  -> EXTERN: (286,7) ffgky(fitsfile *, int, const char *, void *, char *, int *)
  -> EXTERN: (287,7) ffgky(fitsfile *, int, const char *, void *, char *, int *)
  -> EXTERN: (288,7) ffgky(fitsfile *, int, const char *, void *, char *, int *)
  -> EXTERN: (289,7) ffgky(fitsfile *, int, const char *, void *, char *, int *)
  -> EXTERN: (300,7) strcmp(const char *, const char *)
  -> EXTERN: (301,7) strcmp(const char *, const char *)
  -> EXTERN: (302,7) strcmp(const char *, const char *)
  -> EXTERN: (303,7) strcmp(const char *, const char *)
  -> EXTERN: (306,7) strcmp(const char *, const char *)
  -> EXTERN: (307,7) strcmp(const char *, const char *)
  -> EXTERN: (308,7) strcmp(const char *, const char *)
  -> EXTERN: (309,7) strcmp(const char *, const char *)
  -> EXTERN: (312,7) strcmp(const char *, const char *)
  -> EXTERN: (313,7) strcmp(const char *, const char *)
  -> EXTERN: (314,7) strcmp(const char *, const char *)
  -> EXTERN: (315,7) strcmp(const char *, const char *)
  -> EXTERN: (318,7) strcmp(const char *, const char *)
  -> EXTERN: (319,7) strcmp(const char *, const char *)
  -> EXTERN: (320,7) strcmp(const char *, const char *)
  -> EXTERN: (321,7) strcmp(const char *, const char *)
  -> EXTERN: (335,9) ffgipr(fitsfile *, int, int *, int *, long *, int *)
  -> EXTERN: (338,6) printf(const char *__restrict__, ...)
  -> EXTERN: (339,6) printf(const char *__restrict__, ...)
  -> EXTERN: (340,6) ffclos(fitsfile *, int *)
  -> EXTERN: (341,6) exit(int)
  -> EXTERN: (358,25) calloc(size_t, size_t)
  -> EXTERN: (360,6) printf(const char *__restrict__, ...)
  -> EXTERN: (365,21) ?1memcpy
  -> EXTERN: (366,5) ffgpxv(fitsfile *, int, long *, LONGLONG, void *, void *, int *, int *)
  -> EXTERN: (368,6) ffrprt(FILE *, int)
  -> EXTERN: (378,29) calloc(size_t, size_t)
  -> EXTERN: (381,22) calloc(size_t, size_t)
  -> EXTERN: (383,34) calloc(size_t, size_t)
  -> EXTERN: (526,5) free(void *)
  -> EXTERN: (527,5) ffclos(fitsfile *, int *)
  -> EXTERN: (529,6) ffrprt(FILE *, int)
  -> EXTERN: (539,19) ffrprt(FILE *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/utilsFits.c(382,6)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at src/utilsFits.c(408,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12) and ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12)
   remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12) and ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12)

   LOOP BEGIN at src/utilsFits.c(409,8)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12) and ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12)
      remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12) and ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12)

      LOOP BEGIN at src/utilsFits.c(410,9)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12) and ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12)
         remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12) and ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12)

         LOOP BEGIN at src/utilsFits.c(411,10)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization
            remark #15346: vector dependence: assumed FLOW dependence between ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12) and imageTemp[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (416:12)
            remark #15346: vector dependence: assumed ANTI dependence between imageTemp[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (416:12) and ((image->pixels+(i*naxes[2]+j)*24)->spectro)[h+image->nLambdas*k (416:12)
            remark #25439: unrolled with remainder by 2  
         LOOP END

         LOOP BEGIN at src/utilsFits.c(411,10)
         <Remainder>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/utilsFits.c(425,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12) and ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12)
   remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12) and ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12)

   LOOP BEGIN at src/utilsFits.c(426,8)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12) and ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12)
      remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12) and ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12)

      LOOP BEGIN at src/utilsFits.c(427,9)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12) and ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12)
         remark #15346: vector dependence: assumed OUTPUT dependence between ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12) and ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12)

         LOOP BEGIN at src/utilsFits.c(428,10)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization
            remark #15346: vector dependence: assumed FLOW dependence between ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12) and imageTemp[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (515:12)
            remark #15346: vector dependence: assumed ANTI dependence between imageTemp[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (515:12) and ((image->pixels+(currentCol*naxes[pos_row]+currentRow)*24)->spec (515:12)
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

src/utilsFits.c(273,19):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/utilsFits.c(365,21):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/utilsFits.c(267,82):remark #34051: REGISTER ALLOCATION : [readFitsSpectroImage..1] src/utilsFits.c:267

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :     356
            Global    :     140
            Local     :     216
        Regenerable   :      98
        Spilled       :      57
        
    Routine stack
        Variables     :     181 bytes*
            Reads     :      28 [1.43e+00 ~ 2.6%]
            Writes    :       6 [4.01e+00 ~ 7.2%]
        Spills        :     416 bytes*
            Reads     :      83 [1.24e+00 ~ 2.2%]
            Writes    :      64 [3.31e-01 ~ 0.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: readFitsSpectroImage..0(const char *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (readFitsSpectroImage..0(const char *, int)) [11/70=15.7%] src/utilsFits.c(267,82)
  CLONED FROM: readFitsSpectroImage(const char *, int)(X,1)
  -> EXTERN: (269,25) malloc(size_t)
  -> EXTERN: (273,19) ?1memcpy
  -> EXTERN: (278,9) ffopentest(int, fitsfile **, const char *, int, int *)
  -> EXTERN: (281,7) ffghdt(fitsfile *, int *, int *)
  -> EXTERN: (286,7) ffgky(fitsfile *, int, const char *, void *, char *, int *)
  -> EXTERN: (287,7) ffgky(fitsfile *, int, const char *, void *, char *, int *)
  -> EXTERN: (288,7) ffgky(fitsfile *, int, const char *, void *, char *, int *)
  -> EXTERN: (289,7) ffgky(fitsfile *, int, const char *, void *, char *, int *)
  -> EXTERN: (300,7) strcmp(const char *, const char *)
  -> EXTERN: (301,7) strcmp(const char *, const char *)
  -> EXTERN: (302,7) strcmp(const char *, const char *)
  -> EXTERN: (303,7) strcmp(const char *, const char *)
  -> EXTERN: (306,7) strcmp(const char *, const char *)
  -> EXTERN: (307,7) strcmp(const char *, const char *)
  -> EXTERN: (308,7) strcmp(const char *, const char *)
  -> EXTERN: (309,7) strcmp(const char *, const char *)
  -> EXTERN: (312,7) strcmp(const char *, const char *)
  -> EXTERN: (313,7) strcmp(const char *, const char *)
  -> EXTERN: (314,7) strcmp(const char *, const char *)
  -> EXTERN: (315,7) strcmp(const char *, const char *)
  -> EXTERN: (318,7) strcmp(const char *, const char *)
  -> EXTERN: (319,7) strcmp(const char *, const char *)
  -> EXTERN: (320,7) strcmp(const char *, const char *)
  -> EXTERN: (321,7) strcmp(const char *, const char *)
  -> EXTERN: (335,9) ffgipr(fitsfile *, int, int *, int *, long *, int *)
  -> EXTERN: (338,6) printf(const char *__restrict__, ...)
  -> EXTERN: (339,6) printf(const char *__restrict__, ...)
  -> EXTERN: (340,6) ffclos(fitsfile *, int *)
  -> EXTERN: (341,6) exit(int)
  -> EXTERN: (358,25) calloc(size_t, size_t)
  -> EXTERN: (360,6) printf(const char *__restrict__, ...)
  -> EXTERN: (365,21) ?1memcpy
  -> EXTERN: (366,5) ffgpxv(fitsfile *, int, long *, LONGLONG, void *, void *, int *, int *)
  -> EXTERN: (368,6) ffrprt(FILE *, int)
  -> EXTERN: (378,29) calloc(size_t, size_t)
  -> EXTERN: (381,22) calloc(size_t, size_t)
  -> EXTERN: (383,34) calloc(size_t, size_t)
  -> EXTERN: (526,5) free(void *)
  -> EXTERN: (527,5) ffclos(fitsfile *, int *)
  -> EXTERN: (529,6) ffrprt(FILE *, int)
  -> EXTERN: (539,19) ffrprt(FILE *, int)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/utilsFits.c(408,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between image (413:12) and image (413:12)
   remark #15346: vector dependence: assumed OUTPUT dependence between image (413:12) and image (413:12)

   LOOP BEGIN at src/utilsFits.c(409,8)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between image (413:12) and image (413:12)
      remark #15346: vector dependence: assumed OUTPUT dependence between image (413:12) and image (413:12)

      LOOP BEGIN at src/utilsFits.c(410,9)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between image (413:12) and image (413:12)
         remark #15346: vector dependence: assumed OUTPUT dependence between image (413:12) and image (413:12)

         LOOP BEGIN at src/utilsFits.c(411,10)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization
            remark #15346: vector dependence: assumed FLOW dependence between image (413:12) and imageTemp[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (413:12)
            remark #15346: vector dependence: assumed ANTI dependence between imageTemp[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (413:12) and image (413:12)
            remark #25439: unrolled with remainder by 2  
         LOOP END

         LOOP BEGIN at src/utilsFits.c(411,10)
         <Remainder>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at src/utilsFits.c(425,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between image (511:12) and image (511:12)
   remark #15346: vector dependence: assumed OUTPUT dependence between image (511:12) and image (511:12)

   LOOP BEGIN at src/utilsFits.c(426,8)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between image (511:12) and image (511:12)
      remark #15346: vector dependence: assumed OUTPUT dependence between image (511:12) and image (511:12)

      LOOP BEGIN at src/utilsFits.c(427,9)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between image (511:12) and image (511:12)
         remark #15346: vector dependence: assumed OUTPUT dependence between image (511:12) and image (511:12)

         LOOP BEGIN at src/utilsFits.c(428,10)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization
            remark #15346: vector dependence: assumed FLOW dependence between image (511:12) and imageTemp[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (511:12)
            remark #15346: vector dependence: assumed ANTI dependence between imageTemp[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (511:12) and image (511:12)
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

src/utilsFits.c(273,19):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/utilsFits.c(365,21):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/utilsFits.c(267,82):remark #34051: REGISTER ALLOCATION : [readFitsSpectroImage..0] src/utilsFits.c:267

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :     351
            Global    :     134
            Local     :     217
        Regenerable   :      97
        Spilled       :      56
        
    Routine stack
        Variables     :     181 bytes*
            Reads     :      28 [1.43e+00 ~ 2.6%]
            Writes    :       6 [4.01e+00 ~ 7.2%]
        Spills        :     408 bytes*
            Reads     :      85 [1.45e+00 ~ 2.6%]
            Writes    :      62 [4.25e-01 ~ 0.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: writeFitsImageModels(const char *, int, int, Init_Model *, float *, int *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (writeFitsImageModels(const char *, int, int, Init_Model *, float *, int *, int)) [12/70=17.1%] src/utilsFits.c(1330,152)
  -> EXTERN: (1341,16) ?1memcpy
  -> EXTERN: (1349,4) remove(const char *)
  -> EXTERN: (1351,8) ffinit(fitsfile **, const char *, int *)
  -> (1352,5) printerror(int) (isz = 3) (sz = 8)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (1359,7) ffcrim(fitsfile *, int, int, long *, int *)
  -> (1360,3) printerror(int) (isz = 3) (sz = 8)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (1364,19) calloc(size_t, size_t)
  -> EXTERN: (1422,9) ffppr(fitsfile *, int, LONGLONG, LONGLONG, void *, int *)
  -> (1423,3) printerror(int) (isz = 3) (sz = 8)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (1424,3) free(void *)
  -> EXTERN: (1429,2) free(void *)
  -> EXTERN: (1440,7) ffclos(fitsfile *, int *)
  -> (1441,3) printerror(int) (isz = 3) (sz = 8)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]



Non-optimizable loops:


LOOP BEGIN at src/utilsFits.c(1366,2)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ src/utilsFits.c(1370,5) ]

   LOOP BEGIN at src/utilsFits.c(1367,3)
      remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ src/utilsFits.c(1370,5) ]

      LOOP BEGIN at src/utilsFits.c(1368,4)
         remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ src/utilsFits.c(1370,5) ]
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

src/utilsFits.c(1341,16):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/utilsFits.c(1330,152):remark #34051: REGISTER ALLOCATION : [writeFitsImageModels] src/utilsFits.c:1330

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rsi rdi r8-r15 zmm0]
        
    Routine temporaries
        Total         :     106
            Global    :      41
            Local     :      65
        Regenerable   :      21
        Spilled       :      15
        
    Routine stack
        Variables     :      36 bytes*
            Reads     :      13 [8.76e+00 ~ 0.5%]
            Writes    :       6 [5.50e+00 ~ 0.3%]
        Spills        :      80 bytes*
            Reads     :      12 [1.69e+02 ~ 8.9%]
            Writes    :      12 [1.48e+02 ~ 7.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: writeFitsImageProfiles(const char *, const char *, FitsImage *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (writeFitsImageProfiles(const char *, const char *, FitsImage *)) [13/70=18.6%] src/utilsFits.c(1697,105)
  -> EXTERN: (1703,17) ?1memcpy
  -> EXTERN: (1707,2) remove(const char *)
  -> EXTERN: (1709,4) ffopentest(int, fitsfile **, const char *, int, int *)
  -> EXTERN: (1710,4) ffinit(fitsfile **, const char *, int *)
  -> EXTERN: (1712,3) ffrprt(FILE *, int)
  -> EXTERN: (1717,2) ffgipr(fitsfile *, int, int *, int *, long *, int *)
  -> EXTERN: (1719,4) ffcrim(fitsfile *, int, int, long *, int *)
  -> EXTERN: (1721,3) ffrprt(FILE *, int)
  -> EXTERN: (1725,2) ffghsp(fitsfile *, int *, int *, int *)
  -> EXTERN: (1728,3) ffgrec(fitsfile *, int, char *, int *)
  -> EXTERN: (1729,3) ffgkyn(fitsfile *, int, char *, char *, char *, int *)
  -> EXTERN: (1730,3) ffucrd(fitsfile *, const char *, const char *, int *)
  -> EXTERN: (1735,2) ffclos(fitsfile *, int *)
  -> EXTERN: (1737,3) ffrprt(FILE *, int)
  -> EXTERN: (1744,24) calloc(size_t, size_t)
  -> EXTERN: (1848,7) ffppr(fitsfile *, int, LONGLONG, LONGLONG, void *, int *)
  -> (1849,3) printerror(int) (isz = 3) (sz = 8)
     [[ Callee not marked with inlining pragma  <1>]]
  -> EXTERN: (1850,3) free(void *)
  -> EXTERN: (1854,2) free(void *)
  -> EXTERN: (1855,2) ffclos(fitsfile *, int *)
  -> (1857,3) printerror(int) (isz = 3) (sz = 8)
     [[ Callee not marked with inlining pragma  <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/utilsFits.c(1727,2)
   remark #15523: loop was not vectorized: loop control variable ii was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at src/utilsFits.c(1753,2)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6) and outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6)
   remark #15346: vector dependence: assumed OUTPUT dependence between outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6) and outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6)

   LOOP BEGIN at src/utilsFits.c(1754,3)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6) and outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6)
      remark #15346: vector dependence: assumed OUTPUT dependence between outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6) and outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6)

      LOOP BEGIN at src/utilsFits.c(1755,4)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6) and outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6)
         remark #15346: vector dependence: assumed OUTPUT dependence between outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6) and outputImage[naxes[0]*((i*naxes[2])*naxes[1]+j*naxes[1]+k)+h] (1840:6)

         LOOP BEGIN at src/utilsFits.c(1756,5)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization
            remark #15346: vector dependence: assumed FLOW dependence between currentLambda (1765:8) and currentLambda (1840:6)
            remark #15346: vector dependence: assumed ANTI dependence between currentLambda (1840:6) and currentLambda (1765:8)
            remark #15346: vector dependence: assumed ANTI dependence between currentLambda (1840:6) and currentLambda (1765:8)
            remark #15346: vector dependence: assumed FLOW dependence between currentLambda (1765:8) and currentLambda (1840:6)
            remark #15346: vector dependence: assumed FLOW dependence between currentLambda (1769:8) and currentLambda (1840:6)
            remark #15346: vector dependence: assumed ANTI dependence between currentLambda (1840:6) and currentLambda (1769:8)
            remark #15346: vector dependence: assumed ANTI dependence between currentLambda (1840:6) and currentLambda (1769:8)
            remark #15346: vector dependence: assumed FLOW dependence between currentLambda (1769:8) and currentLambda (1840:6)
            remark #15346: vector dependence: assumed FLOW dependence between currentLambda (1773:8) and currentLambda (1840:6)
            remark #15346: vector dependence: assumed ANTI dependence between currentLambda (1840:6) and currentLambda (1773:8)
            remark #15346: vector dependence: assumed ANTI dependence between currentLambda (1840:6) and currentLambda (1773:8)
            remark #15346: vector dependence: assumed FLOW dependence between currentLambda (1773:8) and currentLambda (1840:6)
            remark #15346: vector dependence: assumed FLOW dependence between currentLambda (1777:8) and currentLambda (1840:6)
            remark #15346: vector dependence: assumed ANTI dependence between currentLambda (1840:6) and currentLambda (1777:8)
            remark #15346: vector dependence: assumed ANTI dependence between currentLambda (1840:6) and currentLambda (1777:8)
            remark #15346: vector dependence: assumed FLOW dependence between currentLambda (1777:8) and currentLambda (1840:6)
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

src/utilsFits.c(1703,17):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/utilsFits.c(1697,105):remark #34051: REGISTER ALLOCATION : [writeFitsImageProfiles] src/utilsFits.c:1697

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :     169
            Global    :      59
            Local     :     110
        Regenerable   :      49
        Spilled       :      37
        
    Routine stack
        Variables     :     307 bytes*
            Reads     :      28 [2.15e+01 ~ 0.2%]
            Writes    :       4 [4.00e+00 ~ 0.0%]
        Spills        :     256 bytes*
            Reads     :      46 [1.90e+03 ~ 16.7%]
            Writes    :      37 [6.00e+02 ~ 5.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: readFileCuanticLines(const char *, double *, int, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (readFileCuanticLines(const char *, double *, int, int)) [14/70=20.0%] src/readConfig.c(388,112)
  -> EXTERN: (396,7) fopen(const char *__restrict__, const char *__restrict__)
  -> EXTERN: (407,17) getline(char **__restrict__, size_t *__restrict__, FILE *__restrict__)
  -> EXTERN: (407,17) getline(char **__restrict__, size_t *__restrict__, FILE *__restrict__)
  -> EXTERN: (408,3) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (477,3) printf(const char *__restrict__, ...)
  -> EXTERN: (478,3) printf(const char *__restrict__, ...)
  -> EXTERN: (479,3) printf(const char *__restrict__, ...)
  -> EXTERN: (480,3) printf(const char *__restrict__, ...)
  -> EXTERN: (481,3) printf(const char *__restrict__, ...)
  -> EXTERN: (482,3) printf(const char *__restrict__, ...)
  -> EXTERN: (483,3) printf(const char *__restrict__, ...)
  -> EXTERN: (484,3) printf(const char *__restrict__, ...)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]



Non-optimizable loops:


LOOP BEGIN at src/readConfig.c(407,2)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ src/readConfig.c(410,4) ]
LOOP END

    Report from: Code generation optimizations [cg]

src/readConfig.c(388,112):remark #34051: REGISTER ALLOCATION : [readFileCuanticLines] src/readConfig.c:388

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm6]
        
    Routine temporaries
        Total         :     120
            Global    :      47
            Local     :      73
        Regenerable   :      62
        Spilled       :      14
        
    Routine stack
        Variables     :      84 bytes*
            Reads     :      12 [1.36e+01 ~ 7.1%]
            Writes    :       4 [4.16e+00 ~ 2.2%]
        Spills        :      72 bytes*
            Reads     :      13 [6.80e+00 ~ 3.6%]
            Writes    :      23 [8.14e+00 ~ 4.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: create_cuantic(double *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (create_cuantic(double *, int)) [15/70=21.4%] src/create_cuantic.c(9,1)
  -> EXTERN: (17,12) calloc(size_t, size_t)
  -> INLINE: (21,3) Cuanten(Cuantic *, double, double, double, double, double, double, double, int) (isz = 863) (sz = 886)
    -> EXTERN: (62,7) calloc(size_t, size_t)
    -> EXTERN: (68,7) calloc(size_t, size_t)
    -> EXTERN: (85,7) calloc(size_t, size_t)
    -> EXTERN: (86,9) calloc(size_t, size_t)
    -> EXTERN: (87,9) calloc(size_t, size_t)
    -> EXTERN: (88,8) calloc(size_t, size_t)
    -> EXTERN: (89,10) calloc(size_t, size_t)
    -> EXTERN: (90,10) calloc(size_t, size_t)
    -> EXTERN: (218,3) printf(const char *__restrict__, ...)
    -> EXTERN: (219,3) printf(const char *__restrict__, ...)
    -> EXTERN: (220,3) printf(const char *__restrict__, ...)
    -> EXTERN: (221,3) printf(const char *__restrict__, ...)
    -> EXTERN: (222,3) printf(const char *__restrict__, ...)
    -> EXTERN: (223,3) printf(const char *__restrict__, ...)
    -> EXTERN: (224,3) printf(const char *__restrict__, ...)
    -> EXTERN: (225,3) printf(const char *__restrict__, ...)
    -> EXTERN: (228,5) printf(const char *__restrict__, ...)
    -> EXTERN: (230,5) printf(const char *__restrict__, ...)
    -> EXTERN: (232,3) printf(const char *__restrict__, ...)
    -> EXTERN: (235,5) printf(const char *__restrict__, ...)
    -> EXTERN: (237,5) printf(const char *__restrict__, ...)
    -> EXTERN: (239,3) printf(const char *__restrict__, ...)
    -> EXTERN: (242,5) printf(const char *__restrict__, ...)
    -> EXTERN: (244,5) printf(const char *__restrict__, ...)
    -> EXTERN: (246,3) printf(const char *__restrict__, ...)
    -> EXTERN: (249,5) printf(const char *__restrict__, ...)
    -> EXTERN: (251,5) printf(const char *__restrict__, ...)
    -> EXTERN: (253,3) printf(const char *__restrict__, ...)
    -> EXTERN: (256,5) printf(const char *__restrict__, ...)
    -> EXTERN: (258,5) printf(const char *__restrict__, ...)
    -> EXTERN: (260,3) printf(const char *__restrict__, ...)
    -> EXTERN: (263,5) printf(const char *__restrict__, ...)
    -> EXTERN: (265,5) printf(const char *__restrict__, ...)
    -> EXTERN: (267,3) printf(const char *__restrict__, ...)
    -> EXTERN: (268,3) printf(const char *__restrict__, ...)
    -> EXTERN: (271,2) free(void *)
    -> EXTERN: (272,2) free(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/create_cuantic.c(19,2)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at src/create_cuantic.c(63,2) inlined into src/create_cuantic.c(21,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(69,2) inlined into src/create_cuantic.c(21,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25478: While Loop Unrolled by 2  
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(99,2) inlined into src/create_cuantic.c(21,3)
      remark #15523: loop was not vectorized: loop control variable j was found, but loop iteration count cannot be computed before executing the loop

      LOOP BEGIN at src/create_cuantic.c(101,3) inlined into src/create_cuantic.c(21,3)
         remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      LOOP END
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(170,2) inlined into src/create_cuantic.c(21,3)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(170,2) inlined into src/create_cuantic.c(21,3)
      remark #15388: vectorization support: reference pi[i] has aligned access   [ src/create_cuantic.c(172,19) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 4.100
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 5 
      remark #15477: vector cost: 1.250 
      remark #15478: estimated potential speedup: 3.480 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(170,2) inlined into src/create_cuantic.c(21,3)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(176,2) inlined into src/create_cuantic.c(21,3)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(176,2) inlined into src/create_cuantic.c(21,3)
      remark #15388: vectorization support: reference pi[i] has aligned access   [ src/create_cuantic.c(178,3) ]
      remark #15388: vectorization support: reference pi[i] has aligned access   [ src/create_cuantic.c(178,11) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.186
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 31 
      remark #15477: vector cost: 8.750 
      remark #15478: estimated potential speedup: 3.410 
      remark #15486: divides: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(176,2) inlined into src/create_cuantic.c(21,3)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference pi[i] has aligned access   [ src/create_cuantic.c(178,3) ]
      remark #15388: vectorization support: reference pi[i] has aligned access   [ src/create_cuantic.c(178,11) ]
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.371
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(176,2) inlined into src/create_cuantic.c(21,3)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(182,2) inlined into src/create_cuantic.c(21,3)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(182,2) inlined into src/create_cuantic.c(21,3)
      remark #15388: vectorization support: reference sig1[i] has aligned access   [ src/create_cuantic.c(184,23) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 4.100
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 5 
      remark #15477: vector cost: 1.250 
      remark #15478: estimated potential speedup: 3.480 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(182,2) inlined into src/create_cuantic.c(21,3)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(186,2) inlined into src/create_cuantic.c(21,3)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(186,2) inlined into src/create_cuantic.c(21,3)
      remark #25045: Fused Loops: ( 186 192 )

      remark #15388: vectorization support: reference sig1[i] has aligned access   [ src/create_cuantic.c(188,3) ]
      remark #15388: vectorization support: reference sig1[i] has aligned access   [ src/create_cuantic.c(188,13) ]
      remark #15388: vectorization support: reference sig2[i] has aligned access   [ src/create_cuantic.c(194,23) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.600
      remark #15301: FUSED LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 2 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 36 
      remark #15477: vector cost: 10.000 
      remark #15478: estimated potential speedup: 3.420 
      remark #15486: divides: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(192,2) inlined into src/create_cuantic.c(21,3)
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(186,2) inlined into src/create_cuantic.c(21,3)
   <Alternate Alignment Vectorized Loop>
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(186,2) inlined into src/create_cuantic.c(21,3)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference sig1[i] has aligned access   [ src/create_cuantic.c(188,3) ]
      remark #15388: vectorization support: reference sig1[i] has aligned access   [ src/create_cuantic.c(188,13) ]
      remark #15389: vectorization support: reference sig2[i] has unaligned access   [ src/create_cuantic.c(194,23) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 1.119
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(186,2) inlined into src/create_cuantic.c(21,3)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(196,2) inlined into src/create_cuantic.c(21,3)
   <Peeled loop for vectorization>
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(196,2) inlined into src/create_cuantic.c(21,3)
      remark #15388: vectorization support: reference sig2[i] has aligned access   [ src/create_cuantic.c(198,3) ]
      remark #15388: vectorization support: reference sig2[i] has aligned access   [ src/create_cuantic.c(198,13) ]
      remark #15305: vectorization support: vector length 4
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.186
      remark #15300: LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 31 
      remark #15477: vector cost: 8.750 
      remark #15478: estimated potential speedup: 3.410 
      remark #15486: divides: 1 
      remark #15488: --- end vector cost summary ---
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(196,2) inlined into src/create_cuantic.c(21,3)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference sig2[i] has aligned access   [ src/create_cuantic.c(198,3) ]
      remark #15388: vectorization support: reference sig2[i] has aligned access   [ src/create_cuantic.c(198,13) ]
      remark #15305: vectorization support: vector length 4
      remark #15309: vectorization support: normalized vectorization overhead 0.371
      remark #15301: REMAINDER LOOP WAS VECTORIZED
      remark #15442: entire loop may be executed in remainder
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(196,2) inlined into src/create_cuantic.c(21,3)
   <Remainder loop for vectorization>
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(226,3) inlined into src/create_cuantic.c(21,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(233,3) inlined into src/create_cuantic.c(21,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(240,3) inlined into src/create_cuantic.c(21,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(247,3) inlined into src/create_cuantic.c(21,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(254,3) inlined into src/create_cuantic.c(21,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END

   LOOP BEGIN at src/create_cuantic.c(261,3) inlined into src/create_cuantic.c(21,3)
      remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

src/create_cuantic.c(9,1):remark #34051: REGISTER ALLOCATION : [create_cuantic] src/create_cuantic.c:9

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     560
            Global    :     185
            Local     :     375
        Regenerable   :     103
        Spilled       :      47
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     360 bytes*
            Reads     :     125 [7.16e+02 ~ 6.0%]
            Writes    :      51 [1.89e+02 ~ 1.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: readFitsStrayLightFile(const char *, int *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (readFitsStrayLightFile(const char *, int *, int)) [16/70=22.9%] src/utilsFits.c(1224,105)
  -> EXTERN: (1230,17) ?1memcpy
  -> EXTERN: (1235,7) ffopentest(int, fitsfile **, const char *, int, int *)
  -> EXTERN: (1236,8) ffgipr(fitsfile *, int, int *, int *, long *, int *)
  -> EXTERN: (1258,6) printf(const char *__restrict__, ...)
  -> EXTERN: (1264,19) calloc(size_t, size_t)
  -> EXTERN: (1265,21) ?1memcpy
  -> EXTERN: (1266,5) ffgpxv(fitsfile *, int, long *, LONGLONG, void *, void *, int *, int *)
  -> EXTERN: (1268,6) ffrprt(FILE *, int)
  -> EXTERN: (1271,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1274,5) printf(const char *__restrict__, ...)
  -> EXTERN: (1278,4) ffclos(fitsfile *, int *)
  -> EXTERN: (1280,5) ffrprt(FILE *, int)
  -> EXTERN: (1285,4) printf(const char *__restrict__, ...)
  -> EXTERN: (1286,16) ffrprt(FILE *, int)
  -> EXTERN: (1291,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1292,15) ffrprt(FILE *, int)
  -> EXTERN: (1295,2) printf(const char *__restrict__, ...)
  -> EXTERN: (1296,2) printf(const char *__restrict__, ...)


    Report from: Code generation optimizations [cg]

src/utilsFits.c(1230,17):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/utilsFits.c(1265,21):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
src/utilsFits.c(1224,105):remark #34051: REGISTER ALLOCATION : [readFitsStrayLightFile] src/utilsFits.c:1224

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   14[ rax rdx rcx rbx rsi rdi r8-r12 r14 zmm0-zmm1]
        
    Routine temporaries
        Total         :     108
            Global    :      23
            Local     :      85
        Regenerable   :      50
        Spilled       :       3
        
    Routine stack
        Variables     :      88 bytes*
            Reads     :      11 [2.32e+00 ~ 4.5%]
            Writes    :       6 [4.12e+00 ~ 7.9%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: AllocateMemoryDerivedSynthesis(int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (AllocateMemoryDerivedSynthesis(int)) [17/70=24.3%] src/calculosCompartidos.c(38,1)
  -> EXTERN: (41,10) calloc(size_t, size_t)
  -> EXTERN: (42,13) calloc(size_t, size_t)
  -> EXTERN: (43,9) calloc(size_t, size_t)
  -> EXTERN: (44,9) calloc(size_t, size_t)
  -> EXTERN: (45,9) calloc(size_t, size_t)
  -> EXTERN: (46,9) calloc(size_t, size_t)
  -> EXTERN: (50,6) malloc(size_t)
  -> EXTERN: (51,9) malloc(size_t)
  -> EXTERN: (52,9) malloc(size_t)
  -> EXTERN: (56,9) calloc(size_t, size_t)
  -> EXTERN: (57,15) calloc(size_t, size_t)
  -> EXTERN: (58,15) calloc(size_t, size_t)
  -> EXTERN: (63,12) calloc(size_t, size_t)
  -> EXTERN: (64,16) calloc(size_t, size_t)
  -> EXTERN: (65,14) calloc(size_t, size_t)
  -> EXTERN: (67,8) calloc(size_t, size_t)
  -> EXTERN: (69,17) calloc(size_t, size_t)
  -> EXTERN: (70,17) calloc(size_t, size_t)
  -> EXTERN: (71,17) calloc(size_t, size_t)
  -> EXTERN: (73,8) calloc(size_t, size_t)
  -> EXTERN: (74,8) calloc(size_t, size_t)
  -> EXTERN: (75,8) calloc(size_t, size_t)
  -> EXTERN: (76,8) calloc(size_t, size_t)
  -> EXTERN: (77,8) calloc(size_t, size_t)
  -> EXTERN: (78,8) calloc(size_t, size_t)
  -> EXTERN: (79,7) calloc(size_t, size_t)
  -> EXTERN: (80,8) calloc(size_t, size_t)
  -> EXTERN: (82,11) calloc(size_t, size_t)
  -> EXTERN: (84,9) calloc(size_t, size_t)
  -> EXTERN: (85,9) calloc(size_t, size_t)
  -> EXTERN: (86,9) calloc(size_t, size_t)
  -> EXTERN: (87,9) calloc(size_t, size_t)
  -> EXTERN: (88,9) calloc(size_t, size_t)
  -> EXTERN: (89,9) calloc(size_t, size_t)
  -> EXTERN: (90,9) calloc(size_t, size_t)
  -> EXTERN: (92,9) calloc(size_t, size_t)
  -> EXTERN: (93,9) calloc(size_t, size_t)
  -> EXTERN: (94,9) calloc(size_t, size_t)
  -> EXTERN: (95,9) calloc(size_t, size_t)
  -> EXTERN: (96,9) calloc(size_t, size_t)
  -> EXTERN: (97,9) calloc(size_t, size_t)
  -> EXTERN: (98,9) calloc(size_t, size_t)
  -> EXTERN: (99,8) calloc(size_t, size_t)
  -> EXTERN: (100,9) calloc(size_t, size_t)
  -> EXTERN: (102,9) calloc(size_t, size_t)
  -> EXTERN: (103,9) calloc(size_t, size_t)
  -> EXTERN: (104,9) calloc(size_t, size_t)
  -> EXTERN: (105,10) calloc(size_t, size_t)
  -> EXTERN: (106,10) calloc(size_t, size_t)
  -> EXTERN: (107,10) calloc(size_t, size_t)
  -> EXTERN: (109,10) calloc(size_t, size_t)
  -> EXTERN: (110,10) calloc(size_t, size_t)
  -> EXTERN: (111,10) calloc(size_t, size_t)
  -> EXTERN: (112,10) calloc(size_t, size_t)
  -> EXTERN: (113,10) calloc(size_t, size_t)
  -> EXTERN: (114,10) calloc(size_t, size_t)
  -> EXTERN: (115,10) calloc(size_t, size_t)
  -> EXTERN: (117,9) calloc(size_t, size_t)
  -> EXTERN: (118,9) calloc(size_t, size_t)
  -> EXTERN: (119,9) calloc(size_t, size_t)
  -> EXTERN: (120,9) calloc(size_t, size_t)
  -> EXTERN: (121,9) calloc(size_t, size_t)
  -> EXTERN: (122,9) calloc(size_t, size_t)
  -> EXTERN: (123,9) calloc(size_t, size_t)
  -> EXTERN: (125,13) calloc(size_t, size_t)
  -> EXTERN: (126,13) calloc(size_t, size_t)
  -> EXTERN: (127,13) calloc(size_t, size_t)
  -> EXTERN: (129,9) calloc(size_t, size_t)
  -> EXTERN: (130,9) calloc(size_t, size_t)
  -> EXTERN: (131,9) calloc(size_t, size_t)
  -> EXTERN: (133,20) calloc(size_t, size_t)
  -> EXTERN: (138,24) calloc(size_t, size_t)
  -> EXTERN: (141,19) calloc(size_t, size_t)
  -> EXTERN: (145,23) calloc(size_t, size_t)
  -> EXTERN: (148,19) calloc(size_t, size_t)
  -> EXTERN: (151,23) calloc(size_t, size_t)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/calculosCompartidos.c(136,2)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at src/calculosCompartidos.c(143,2)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at src/calculosCompartidos.c(149,2)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

    Report from: Code generation optimizations [cg]

src/calculosCompartidos.c(38,1):remark #34051: REGISTER ALLOCATION : [AllocateMemoryDerivedSynthesis] src/calculosCompartidos.c:38

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   12[ rax rdx rsi rdi r12-r15 zmm0-zmm3]
        
    Routine temporaries
        Total         :     362
            Global    :     181
            Local     :     181
        Regenerable   :      79
        Spilled       :       6
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      16 bytes*
            Reads     :       2 [2.00e+00 ~ 0.4%]
            Writes    :       2 [2.00e+00 ~ 0.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FreeMemoryDerivedSynthesis()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (FreeMemoryDerivedSynthesis()) src/calculosCompartidos.c(157,1)

===========================================================================

Begin optimization report for: fgauss(double, double *, int, double, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (fgauss(double, double *, int, double, int)) src/fgauss.c(16,1)

===========================================================================

Begin optimization report for: fgauss_WL(double, double, double, double, int, int *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (fgauss_WL(double, double, double, double, int, int *)) src/fgauss.c(122,1)

===========================================================================

Begin optimization report for: fvoigt(double, float *, int, float *, float *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (fvoigt(double, float *, int, float *, float *)) src/fvoigt.c(7,1)

===========================================================================

Begin optimization report for: direct_convolution_double(double *, int, double *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (direct_convolution_double(double *, int, double *, int)) src/convolution.c(34,1)

===========================================================================

Begin optimization report for: direct_convolution(float *, int, double *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (direct_convolution(float *, int, double *, int)) src/convolution.c(69,1)

===========================================================================

Begin optimization report for: convCircular(float *, double *, int, float *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (convCircular(float *, double *, int, float *)) src/convolution.c(201,1)

===========================================================================

Begin optimization report for: stat(const char *, struct stat *)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (stat(const char *, struct stat *))/usr/include/x86_64-linux-gnu/sys/stat.h(454,1)

===========================================================================

Begin optimization report for: fchisqr(float *, int, float *, float *, float *, float)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (fchisqr(float *, int, float *, float *, float *, float)) src/lib.c(62,86)

===========================================================================

Begin optimization report for: multmatrixIDLValue(float *, int, int, float *, int, int, float *, int *, int *, float)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (multmatrixIDLValue(float *, int, int, float *, int, int, float *, int *, int *, float)) src/lib.c(98,114)

===========================================================================

Begin optimization report for: totalParcialf(float *, int, int, float *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (totalParcialf(float *, int, int, float *)) src/lib.c(126,56)

===========================================================================

Begin optimization report for: totalParcialMatrixf(float *, int, int, int, float *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (totalParcialMatrixf(float *, int, int, int, float *)) src/lib.c(140,67)

===========================================================================

Begin optimization report for: multmatrix_transpose(float *, int, int, float *, int, int, float *, int *, int *, float)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (multmatrix_transpose(float *, int, int, float *, int, int, float *, int *, int *, float)) src/lib.c(200,117)

===========================================================================

Begin optimization report for: mean(double *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (mean(double *, int)) src/lib.c(230,41)

===========================================================================

Begin optimization report for: CalculaNfree(int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (CalculaNfree(int)) src/lib.c(247,1)

===========================================================================

Begin optimization report for: printProgress(double)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (printProgress(double)) src/lib.c(259,1)

===========================================================================

Begin optimization report for: isDirectory(const char *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (isDirectory(const char *)) src/lib.c(269,35)

===========================================================================

Begin optimization report for: myMemCpy(double *, double *, size_t)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (myMemCpy(double *, double *, size_t)) src/lib.c(278,1)

===========================================================================

Begin optimization report for: strip_ext(char *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (strip_ext(char *)) src/lib.c(289,1)

===========================================================================

Begin optimization report for: Cuanten(Cuantic *, double, double, double, double, double, double, double, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (Cuanten(Cuantic *, double, double, double, double, double, double, double, int)) src/create_cuantic.c(32,1)

===========================================================================

Begin optimization report for: freeVpixels(vpixels *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (freeVpixels(vpixels *, int)) src/utilsFits.c(13,49)

===========================================================================

Begin optimization report for: readFitsSpectroImage(const char *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (readFitsSpectroImage(const char *, int)) src/utilsFits.c(267,82)

===========================================================================

Begin optimization report for: readFitsSpectroNPixels(const char *, int, int, int, int, int, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (readFitsSpectroNPixels(const char *, int, int, int, int, int, int)) src/utilsFits.c(554,152)

===========================================================================

Begin optimization report for: readFitsLambdaFile(const char *, FitsImage *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (readFitsLambdaFile(const char *, FitsImage *)) src/utilsFits.c(1011,77)

===========================================================================

Begin optimization report for: readFitsLambdaToArray(const char *, int *, int *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (readFitsLambdaToArray(const char *, int *, int *)) src/utilsFits.c(1137,97)

===========================================================================

Begin optimization report for: freeFitsImage(FitsImage *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (freeFitsImage(FitsImage *)) src/utilsFits.c(1302,38)

===========================================================================

Begin optimization report for: writeFitsImageModelsSubSet(const char *, int, int, int, int, int, int, Init_Model *, float *, int *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (writeFitsImageModelsSubSet(const char *, int, int, int, int, int, int, Init_Model *, float *, int *, int)) src/utilsFits.c(1454,219)

===========================================================================

Begin optimization report for: writeFitsImageModelsWithArray(char *, int, int, double *, double *, double *, double *, double *, double *, double *, double *, double *, double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (writeFitsImageModelsWithArray(char *, int, int, double *, double *, double *, double *, double *, double *, double *, double *, double *, double *, double *, double *)) src/utilsFits.c(1863,283)

===========================================================================

Begin optimization report for: readSizeImageSpectro(const char *, int *, int *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (readSizeImageSpectro(const char *, int *, int *)) src/utilsFits.c(1972,78)

===========================================================================

Begin optimization report for: spectral_synthesis_convolution(int *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (spectral_synthesis_convolution(int *)) src/milosUtils.c(48,1)

===========================================================================

Begin optimization report for: response_functions_convolution(int *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (response_functions_convolution(int *)) src/milosUtils.c(80,1)

===========================================================================

Begin optimization report for: AplicaSlight(float *, int, double, double *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (AplicaSlight(float *, int, double, double *)) src/milosUtils.c(119,82)

===========================================================================

Begin optimization report for: AplicaDelta(Init_Model *, double *, int *, Init_Model *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (AplicaDelta(Init_Model *, double *, int *, Init_Model *)) src/milosUtils.c(141,1)

===========================================================================

Begin optimization report for: check(Init_Model *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (check(Init_Model *)) src/milosUtils.c(216,1)

===========================================================================

Begin optimization report for: FijaACeroDerivadasNoNecesarias(float *, int *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (FijaACeroDerivadasNoNecesarias(float *, int *, int)) src/milosUtils.c(298,1)

===========================================================================

Begin optimization report for: mil_svd(double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (mil_svd(double *, double *, double *)) src/milosUtils.c(317,1)

===========================================================================

Begin optimization report for: multmatrix(double *, int, int, double *, int, int, double *, int *, int *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (multmatrix(double *, int, int, double *, int, int, double *, int *, int *)) src/lib.c(166,111)

===========================================================================

Begin optimization report for: weights_init(double *, double **, double)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (weights_init(double *, double **, double)) src/milosUtils.c(363,1)

===========================================================================

Begin optimization report for: interpolationSplinePSF(double *, double *, double *, size_t, double *, size_t)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (interpolationSplinePSF(double *, double *, double *, size_t, double *, size_t)) src/milosUtils.c(720,154)

===========================================================================

Begin optimization report for: interpolationLinearPSF(double *, double *, double *, size_t, double *, size_t, double)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (interpolationLinearPSF(double *, double *, double *, size_t, double *, size_t, double)) src/milosUtils.c(761,168)

===========================================================================

Begin optimization report for: direct_convolution2(float *, int, double *, int, float *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (direct_convolution2(float *, int, double *, int, float *, int)) src/convolution.c(104,1)

===========================================================================

Begin optimization report for: convolve(float *, size_t, double *, size_t, float *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (convolve(float *, size_t, double *, size_t, float *, int)) src/convolution.c(139,1)

===========================================================================

Begin optimization report for: atof(const char *)

    Report from: Interprocedural optimizations [ipo]

NEVER EMIT DEFINITION FUNCTION: (atof(const char *))/usr/include/x86_64-linux-gnu/bits/stdlib-float.h(26,1)

===========================================================================

Begin optimization report for: readMallaGrid(const char *, double *, double *, double *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (readMallaGrid(const char *, double *, double *, double *, int)) src/readConfig.c(626,130)

===========================================================================

Begin optimization report for: readPSFFile(double *, double *, const char *, double)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (readPSFFile(double *, double *, const char *, double)) src/readConfig.c(673,114)

===========================================================================

Begin optimization report for: readParametersFileInput(char *, ConfigControl *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (readParametersFileInput(char *, ConfigControl *, int)) src/readConfig.c(743,94)

===========================================================================

Begin optimization report for: file_ext(const char *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (file_ext(const char *)) src/readConfig.c(2276,1)

===========================================================================

Begin optimization report for: get_basefilename(const char *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (get_basefilename(const char *)) src/readConfig.c(2297,1)

===========================================================================

Begin optimization report for: readTrolFile(char *, ConfigControl *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (readTrolFile(char *, ConfigControl *, int)) [66/70=94.3%] src/readConfig.c(1418,83)
  -> EXTERN: (1425,20) fopen(const char *__restrict__, const char *__restrict__)
  -> EXTERN: (1428,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1429,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1436,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1438,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1441,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1442,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1450,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1454,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1456,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1460,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1461,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1465,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1469,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1471,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1473,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1474,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1478,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1482,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1484,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1486,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1487,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1491,5) access(const char *, int)
  -> INLINE (MANUAL): (1492,17) atof(const char *) (isz = 2) (sz = 9)
    -> EXTERN: /usr/include/x86_64-linux-gnu/bits/stdlib-float.h:(27,10) strtod(const char *__restrict__, char **__restrict__)
  -> EXTERN: (1497,17) printf(const char *__restrict__, ...)
  -> EXTERN: (1506,6) strcmp(const char *, const char *)
  -> INLINE: (1506,13) file_ext(const char *) (isz = 56) (sz = 65)
    -> EXTERN: (2277,5) __assert_fail(const char *, const char *, unsigned int, const char *)
    -> EXTERN: (2278,17) strrchr(const char *, int)
    -> EXTERN: (2281,33) strlen(const char *)
    -> EXTERN: (2284,14) __ctype_b_loc(void)
    -> EXTERN: (2285,37) strlen(const char *)
  -> EXTERN: (1510,4) printf(const char *__restrict__, ...)
  -> EXTERN: (1511,4) exit(int)
  -> EXTERN: (1516,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1520,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1522,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1524,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1525,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1529,5) access(const char *, int)
  -> EXTERN: (1530,6) strcmp(const char *, const char *)
  -> INLINE: (1530,13) file_ext(const char *) (isz = 56) (sz = 65)
    -> EXTERN: (2277,5) __assert_fail(const char *, const char *, unsigned int, const char *)
    -> EXTERN: (2278,17) strrchr(const char *, int)
    -> EXTERN: (2281,33) strlen(const char *)
    -> EXTERN: (2284,14) __ctype_b_loc(void)
    -> EXTERN: (2285,37) strlen(const char *)
  -> EXTERN: (1531,4) strcpy(char *__restrict__, const char *__restrict__)
  -> EXTERN: (1532,4) ?1memset
  -> EXTERN: (1535,11) strcmp(const char *, const char *)
  -> INLINE: (1535,18) file_ext(const char *) (isz = 56) (sz = 65)
    -> EXTERN: (2277,5) __assert_fail(const char *, const char *, unsigned int, const char *)
    -> EXTERN: (2278,17) strrchr(const char *, int)
    -> EXTERN: (2281,33) strlen(const char *)
    -> EXTERN: (2284,14) __ctype_b_loc(void)
    -> EXTERN: (2285,37) strlen(const char *)
  -> EXTERN: (1536,4) ?1memset
  -> EXTERN: (1540,4) printf(const char *__restrict__, ...)
  -> EXTERN: (1541,4) exit(int)
  -> EXTERN: (1545,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1549,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1551,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1553,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1554,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1558,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1562,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1564,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1566,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1567,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1571,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1575,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1577,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1581,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1582,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1586,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1590,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1592,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1594,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1595,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1599,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1603,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1605,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1607,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1608,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1613,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1617,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1619,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1621,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1622,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1627,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1631,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1633,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1635,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1636,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1641,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1645,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1647,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1649,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1650,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1655,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1660,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1662,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1664,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1665,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1669,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1678,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1680,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1682,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1683,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1687,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1691,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1693,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1695,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1696,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1700,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1704,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1706,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1708,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1709,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1713,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1717,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1719,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1721,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1722,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1726,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1730,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1732,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1734,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1735,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1739,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1743,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1745,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1747,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1748,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1752,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1756,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1758,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1760,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1761,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1765,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1769,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1771,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1773,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1774,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1778,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1782,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1784,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1786,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1787,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1791,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1796,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1798,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1800,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1801,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1805,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1814,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1816,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1818,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1819,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1823,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1827,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1829,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1831,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1832,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1836,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1840,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1842,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1844,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1845,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1849,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1853,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1855,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1857,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1858,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1862,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1866,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1868,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1870,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1871,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1875,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1879,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1881,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1883,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1884,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1888,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1892,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1894,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1896,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1897,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1901,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1905,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1907,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1909,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1910,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1914,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1918,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1920,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1922,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1923,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1927,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1931,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1933,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1935,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1936,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1940,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1944,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1946,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1948,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1949,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1954,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1959,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1961,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1963,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1964,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1968,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1973,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1975,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1977,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1978,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1982,15) printf(const char *__restrict__, ...)
  -> EXTERN: (1986,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (1988,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (1990,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1991,3) printf(const char *__restrict__, ...)
  -> EXTERN: (1995,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2009,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2011,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2013,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2014,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2019,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2024,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2026,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2028,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2029,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2034,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2038,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2040,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2042,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2043,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2047,15) printf(const char *__restrict__, ...)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/readConfig.c(2283,5) inlined into src/readConfig.c(1506,13)
   remark #15523: loop was not vectorized: loop control variable iter was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at src/readConfig.c(2283,5) inlined into src/readConfig.c(1530,13)
   remark #15523: loop was not vectorized: loop control variable iter was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at src/readConfig.c(2283,5) inlined into src/readConfig.c(1535,18)
   remark #15523: loop was not vectorized: loop control variable iter was found, but loop iteration count cannot be computed before executing the loop
LOOP END

    Report from: Code generation optimizations [cg]

src/readConfig.c(1532,4):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (1, 0)
src/readConfig.c(1536,4):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (1, 0)
src/readConfig.c(1418,83):remark #34051: REGISTER ALLOCATION : [readTrolFile] src/readConfig.c:1418

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rsi rdi r8-r10 r12-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    1164
            Global    :     216
            Local     :     948
        Regenerable   :     715
        Spilled       :      13
        
    Routine stack
        Variables     :    4400 bytes*
            Reads     :       5 [2.65e-04 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      64 bytes*
            Reads     :       9 [7.79e-02 ~ 0.1%]
            Writes    :       9 [8.02e-02 ~ 0.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: readInitFile(char *, ConfigControl *, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (readInitFile(char *, ConfigControl *, int)) [67/70=95.7%] src/readConfig.c(2060,83)
  -> EXTERN: (2066,20) fopen(const char *__restrict__, const char *__restrict__)
  -> EXTERN: (2070,4) printf(const char *__restrict__, ...)
  -> EXTERN: (2071,4) printf(const char *__restrict__, ...)
  -> EXTERN: (2080,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2082,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2084,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2085,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2088,15) printf(const char *__restrict__, ...)
  -> (2089,2) readTrolFile(char *, ConfigControl *, int) (isz = 2470) (sz = 2564)
     [[ Inlining would exceed -inline-max-total-size value (2470>2000) <4>]]
  -> EXTERN: (2093,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2095,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2097,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2098,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2102,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2106,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2108,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2110,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2111,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2115,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2118,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2120,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2122,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2123,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2127,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2130,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2132,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2134,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2135,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2139,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2142,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2144,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2146,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2147,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2151,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2155,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2157,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2159,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2160,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2164,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2167,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2169,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2171,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2172,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2176,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2179,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2181,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2183,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2184,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2188,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2192,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2193,3) exit(int)
  -> EXTERN: (2204,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2206,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2208,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2209,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2213,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2217,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2219,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2221,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2222,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2226,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2229,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2231,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2233,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2234,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2238,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2241,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2243,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2245,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2246,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2250,15) printf(const char *__restrict__, ...)
  -> EXTERN: (2253,15) fgets(char *__restrict__, int, FILE *__restrict__)
  -> EXTERN: (2255,12) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (2257,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2258,3) printf(const char *__restrict__, ...)
  -> EXTERN: (2262,15) printf(const char *__restrict__, ...)


    Report from: Code generation optimizations [cg]

src/readConfig.c(2060,83):remark #34051: REGISTER ALLOCATION : [readInitFile] src/readConfig.c:2060

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rsi rdi r8 r12-r15]
        
    Routine temporaries
        Total         :     420
            Global    :      77
            Local     :     343
        Regenerable   :     270
        Spilled       :       5
        
    Routine stack
        Variables     :    4396 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: loadInitialValues(ConfigControl *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (loadInitialValues(ConfigControl *)) [68/70=97.1%] src/readConfig.c(704,58)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/readConfig.c(707,2)
   remark #15389: vectorization support: reference configControlFile->WeightForStokes[_2] has unaligned access
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15427: loop was completely unrolled
   remark #15309: vectorization support: normalized vectorization overhead 0.600
   remark #15301: MATERIALIZED LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 3 
   remark #15477: vector cost: 1.250 
   remark #15478: estimated potential speedup: 1.500 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/readConfig.c(714,2)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at src/readConfig.c(714,2)
   remark #15388: vectorization support: reference configControlFile->fix[i] has aligned access   [ src/readConfig.c(715,3) ]
   remark #15389: vectorization support: reference configControlFile->fix2[i] has unaligned access   [ src/readConfig.c(716,3) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 1.250
   remark #15300: LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 1.150 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=2
LOOP END

LOOP BEGIN at src/readConfig.c(714,2)
<Remainder loop for vectorization>
LOOP END

LOOP BEGIN at src/readConfig.c(722,2)
   remark #25045: Fused Loops: ( 722 734 )

   remark #15389: vectorization support: reference configControlFile->sigma[_2] has unaligned access
   remark #15389: vectorization support: reference *(configControlFile+_2*4+49488) has unaligned access   [ src/readConfig.c(734,2) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15427: loop was completely unrolled
   remark #15309: vectorization support: normalized vectorization overhead 0.545
   remark #15301: FUSED LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 6 
   remark #15477: vector cost: 2.750 
   remark #15478: estimated potential speedup: 1.410 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at src/readConfig.c(734,2)
   remark #25046: Loop lost in Fusion 
LOOP END

    Report from: Code generation optimizations [cg]

src/readConfig.c(704,58):remark #34051: REGISTER ALLOCATION : [loadInitialValues] src/readConfig.c:704

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rsi rdi zmm0-zmm1]
        
    Routine temporaries
        Total         :      29
            Global    :      14
            Local     :      15
        Regenerable   :       8
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: readInitialModel(Init_Model *, char *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (readInitialModel(Init_Model *, char *)) [69/70=98.6%] src/readConfig.c(495,68)
  -> EXTERN: (503,19) fopen(const char *__restrict__, const char *__restrict__)
  -> EXTERN: (506,3) printf(const char *__restrict__, ...)
  -> EXTERN: (507,3) printf(const char *__restrict__, ...)
  -> EXTERN: (511,17) getline(char **__restrict__, size_t *__restrict__, FILE *__restrict__)
  -> EXTERN: (511,17) getline(char **__restrict__, size_t *__restrict__, FILE *__restrict__)
  -> EXTERN: (513,3) sscanf(const char *__restrict__, const char *__restrict__, ...)
  -> EXTERN: (514,6) strstr(const char *, const char *)
  -> EXTERN: (517,6) strstr(const char *, const char *)
  -> EXTERN: (520,6) strstr(const char *, const char *)
  -> EXTERN: (523,6) strstr(const char *, const char *)
  -> EXTERN: (526,6) strstr(const char *, const char *)
  -> EXTERN: (529,6) strstr(const char *, const char *)
  -> EXTERN: (532,6) strstr(const char *, const char *)
  -> EXTERN: (535,6) strstr(const char *, const char *)
  -> EXTERN: (538,6) strstr(const char *, const char *)
  -> EXTERN: (541,6) strstr(const char *, const char *)
  -> EXTERN: (544,6) strstr(const char *, const char *)
  -> EXTERN: (548,2) fclose(FILE *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at src/readConfig.c(511,2)
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

src/readConfig.c(495,68):remark #34051: REGISTER ALLOCATION : [readInitialModel] src/readConfig.c:495

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8 r12-r14]
        
    Routine temporaries
        Total         :     114
            Global    :      42
            Local     :      72
        Regenerable   :      58
        Spilled       :       3
        
    Routine stack
        Variables     :     324 bytes*
            Reads     :      12 [5.52e+01 ~ 11.3%]
            Writes    :       2 [2.00e+00 ~ 0.4%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: printerror(int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (printerror(int)) [70/70=100.0%] src/utilsFits.c(2072,1)
  -> EXTERN: (2078,8) ffrprt(FILE *, int)


    Report from: Code generation optimizations [cg]

src/utilsFits.c(2072,1):remark #34051: REGISTER ALLOCATION : [printerror] src/utilsFits.c:2072

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rsi rdi]
        
    Routine temporaries
        Total         :      11
            Global    :       7
            Local     :       4
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

    Report from: Profile guided optimizations [pgo]



Profile feedback used a statically estimated profile for the following routines:

  File: src/calculosCompartidos.c
        AllocateMemoryDerivedSynthesis(int)                               [Line    38]

  File: src/create_cuantic.c
        create_cuantic(double *, int)                                     [Line     9]

  File: src/lib.c
        covarm(float *, float *, float *, int, float *, float *, float *, float *)[Line    33]

  File: src/me_der.c
        me_der(Cuantic *, Init_Model *, double *, double *, int, float *, float *, float *, double, double *, int)[Line    67]
        funcionComponentFor(int, double, int, float *, float *, float *, float *, double, double, int)[Line   620]
        Resetear_Valores_Intermedios(int)                                 [Line   707]

  File: src/mil_sinrf.c
        mil_sinrf(Cuantic *, Init_Model *, double *, double *, int, float *, double, double *, float *, int)[Line    62]
        funcionComponentFor_sinrf(float *, int, int, float *, float *, float *, float *, double, double)[Line   472]

  File: src/milosMPI.c
        main(int, char **)                                                [Line    96]

  File: src/milosUtils.c
        estimacionesClasicas(double, double *, int, float *, Init_Model *, int)[Line   406]
        lm_mils(Cuantic *, double *, double *, int, float *, int, Init_Model *, float *, float *, double *, double, int, float *, int *, float *, float, int *, int *)[Line   579]

  File: src/readConfig.c
        readFileCuanticLines(const char *, double *, int, int)            [Line   388]
        readInitialModel(Init_Model *, char *)                            [Line   495]
        loadInitialValues(ConfigControl *)                                [Line   704]
        readTrolFile(char *, ConfigControl *, int)                        [Line  1418]
        readInitFile(char *, ConfigControl *, int)                        [Line  2060]

  File: src/utilsFits.c
        readFitsSpectroImage..0(const char *, int)                        [Line   267]
        readFitsSpectroImage..1(const char *, int)                        [Line   267]
        readFitsStrayLightFile(const char *, int *, int)                  [Line  1224]
        writeFitsImageModels(const char *, int, int, Init_Model *, float *, int *, int)[Line  1330]
        writeFitsImageProfiles(const char *, const char *, FitsImage *)   [Line  1697]
        printerror(int)                                                   [Line  2072]


  0 out of 22 routine(s) used training profile data for PGO feedback
  0 out of 22 routine(s) were unable to use training profile data for PGO feedback
  0 out of 22 routine(s) were unable to find training profile data for PGO feedback
  22 out of 22 routine(s) used a static estimate profile for PGO feedback




    Report from: Interprocedural optimizations [ipo]

INLINING FOOTNOTES:

<1> The compiler's heuristics indicate that the function is not profitable to 
    inline.  Override this decision by adding "inline 
    __attribute__((always_inline))" to the declaration of the called function, 
    or add "#pragma forceinline" before the call site.

<2> The function is larger than the inliner would normally inline.  Use the
    option -inline-max-size to increase the size of any function that would
    normally be inlined, add "inline __attribute__((always_inline))" to the
    declaration of the called function, or add "#pragma forceinline" before
    the call site.

<3> The function is larger than the inliner would normally inline.  Use the
    option -inline-max-size to increase the size of any function that would
    normally be inlined, add "inline __attribute__((always_inline))" to the
    declaration of the called function, or add "#pragma forceinline" before
    the call site.

<4> Inlining this function at this call site would increase the size of the 
    caller more than is currently acceptable. Use the option 
    -inline-max-total-size to increase the size that all functions can 
    grow through inlining, add "#pragma optimization_parameter 
    inline_max_total_size" to the caller, add "inline 
    __attribute__((always_inline))" to the declaration of the called 
    function, or add "#pragma forceinline" before the call site.

